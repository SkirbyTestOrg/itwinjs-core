"use strict";
/*---------------------------------------------------------------------------------------------
|  $Copyright: (c) 2017 Bentley Systems, Incorporated. All rights reserved. $
 *--------------------------------------------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Entity_1 = require("./Entity");
const Schema_1 = require("./Schema");
const BeSQLite_1 = require("@bentley/bentleyjs-core/lib/BeSQLite");
const Assert_1 = require("@bentley/bentleyjs-core/lib/Assert");
/** The mapping between a class name (schema.class) and its constructor function  */
class ClassRegistry {
    static getKey(schemaName, className) {
        return (schemaName + "." + className).toLowerCase();
    }
    static getKeyFromName(fullName) {
        return ClassRegistry.getKey(fullName.schema, fullName.name);
    }
    /** create an instance of a class from it properties */
    static createInstance(props) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!props.classFullName || !props.iModel)
                return { error: { status: BeSQLite_1.DbResult.BE_SQLITE_ERROR, message: "Invalid input props" } };
            props.classFullName = props.classFullName.toLowerCase();
            let ctor = ClassRegistry.ecClasses.get(props.classFullName);
            if (!ctor) {
                const cls = yield ClassRegistry.generateClass(props.classFullName, props.iModel);
                if (cls.error)
                    return { error: cls.error };
                ctor = cls.result;
                Assert_1.assert(!!ctor);
            }
            return { result: new ctor(props) };
        });
    }
    static registerSchema(schema) { Schema_1.Schemas.registerSchema(schema); }
    static getRegisteredSchema(domainName) { return Schema_1.Schemas.getRegisteredSchema(domainName); }
    static getSchemaBaseClass() { return Schema_1.Schema; }
    static generateProxySchema(schemaName) {
        // register it here, while `schemaName` is defined.
        return "class " + schemaName + " extends ClassRegistry.getSchemaBaseClass(){} ClassRegistry.registerSchema(" + schemaName + ");";
    }
    /**
     * Generate a JS class from an Entity definition
     * @param ecClass The Entity definition
     */
    static generateClassDefFromECClass(ecClass) {
        // static properties
        const classDefStaticProps = ecClass.name + ".schema = ClassRegistry.getRegisteredSchema('" + ecClass.schema + "');";
        // extends
        let classDefExtends = "";
        if (ecClass.baseClasses.length !== 0) {
            classDefExtends = "extends ClassRegistry.ecClasses.get('" + ClassRegistry.getKeyFromName(ecClass.baseClasses[0]) + "')";
        }
        // constructor -- all classes derived from Entity (Element) just defer to super. They don't set any of their own
        // properties. That is because the base class uses the class metadata to detect and set all auto-handled properties.
        // Therefore, none of these derived classes need constructors. The one generated by JS is sufficient.
        // make sure schema exists
        const domainDef = Schema_1.Schemas.getRegisteredSchema(ecClass.schema) ? "" : ClassRegistry.generateProxySchema(ecClass.schema);
        // The class as a whole
        return domainDef + "class " + ecClass.name + " " + classDefExtends + " { } " + classDefStaticProps;
    }
    static registerEcClass(ctor) {
        const key = ClassRegistry.getKey(ctor.schema.name, ctor.name);
        ClassRegistry.ecClasses.set(key, ctor);
    }
    /** register all of the classes that derive from Entity, that are found in a given module
     * @param moduleObj The module to search for subclasses of Entity
     * @param schema The schema for all found classes
     */
    static registerModuleClasses(moduleObj, schema) {
        for (const thisMember in moduleObj) {
            if (!thisMember)
                continue;
            const thisClass = moduleObj[thisMember];
            if (thisClass instanceof Entity_1.Entity.constructor) {
                thisClass.schema = schema;
                ClassRegistry.registerEcClass(thisClass);
            }
        }
    }
    /** This function fetches the specified Entity from the imodel, generates a JS class for it, and registers the generated
     *  class. This function also ensures that all of the base classes of the Entity exist and are registered.
     */
    static generateClass(classFullName, imodel) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!imodel.dgnDb)
                throw new Error("IModel must be open");
            const name = classFullName.split(".");
            Assert_1.assert(name.length === 2);
            const ret = yield imodel.dgnDb.getECClassMetaData(name[0], name[1]);
            if (ret.error)
                return { error: ret.error };
            const ecClassJson = ret.result;
            Assert_1.assert(!!ecClassJson);
            const ecclass = JSON.parse(ecClassJson);
            // Make sure that we have all base classes registered.
            // This recurses. I have to know that the super class is defined and registered before defining a derived class.
            // Therefore, I must await getRegisteredClass.
            if (ecclass.baseClasses && ecclass.baseClasses.length !== 0) {
                for (const base of ecclass.baseClasses) {
                    const { error } = yield ClassRegistry.getClass(base, imodel);
                    if (error)
                        return { error };
                }
            }
            // Now we can generate the class from the classDef.
            return { result: ClassRegistry.generateClassForECClass(ecclass) };
        });
    }
    /** This function generates a JS class for the specified Entity and registers it. It is up to the caller
     *  to make sure that all superclasses are already registered.
     */
    static generateClassForECClass(ecclass) {
        // Generate and register this class
        const jsDef = ClassRegistry.generateClassDefFromECClass(ecclass) + " ClassRegistry.registerEcClass(" + ecclass.name + "); ";
        // tslint:disable-next-line:no-eval NOTE: eval is OK here, because I generated the expression myself, and I know it's safe.
        eval(jsDef);
        const ctor = ClassRegistry.ecClasses.get(ClassRegistry.getKeyFromName(ecclass));
        Assert_1.assert(!!ctor);
        return ctor;
    }
    /**
     * Get the class for the specified Entity.
     * @param fullName The name of the Entity
     * @param imodel The IModel that contains the class definitions
     * @return A promise that resolves to an object containing a result property set to the Entity.
     * In case of errors, the error property is setup in the resolved object.
     */
    static getClass(fullName, imodel) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = ClassRegistry.getKeyFromName(fullName);
            if (!ClassRegistry.ecClasses.has(key)) {
                return ClassRegistry.generateClass(key, imodel);
            }
            const ctor = ClassRegistry.ecClasses.get(key);
            Assert_1.assert(!!ctor);
            return { result: ctor };
        });
    }
    /**
     * Check if the class for the specified Entity is in the registry.
     * @param ecclassFullName The name of the Entity
     */
    static isClassRegistered(schemaName, className) {
        return ClassRegistry.ecClasses.has(ClassRegistry.getKey(schemaName, className));
    }
}
ClassRegistry.ecClasses = new Map();
exports.ClassRegistry = ClassRegistry;
