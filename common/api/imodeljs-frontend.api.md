## API Report File for "@bentley/imodeljs-frontend"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AccessToken } from '@bentley/imodeljs-clients';
import { AmbientOcclusion } from '@bentley/imodeljs-common';
import { AnalysisStyle } from '@bentley/imodeljs-common';
import { Angle } from '@bentley/geometry-core';
import { AntiAliasPref } from '@bentley/imodeljs-common';
import { Arc3d } from '@bentley/geometry-core';
import { AuthorizedClientRequestContext } from '@bentley/imodeljs-clients';
import { AuxCoordSystem2dProps } from '@bentley/imodeljs-common';
import { AuxCoordSystem3dProps } from '@bentley/imodeljs-common';
import { AuxCoordSystemProps } from '@bentley/imodeljs-common';
import { AxisAlignedBox3d } from '@bentley/imodeljs-common';
import { BackgroundMapProps } from '@bentley/imodeljs-common';
import { BackgroundMapType } from '@bentley/imodeljs-common';
import { BatchType } from '@bentley/imodeljs-common';
import { BeDuration } from '@bentley/bentleyjs-core';
import { BeEvent } from '@bentley/bentleyjs-core';
import { BentleyStatus } from '@bentley/bentleyjs-core';
import { BeTimePoint } from '@bentley/bentleyjs-core';
import { BeUiEvent } from '@bentley/bentleyjs-core';
import { Camera } from '@bentley/imodeljs-common';
import { Cartographic } from '@bentley/imodeljs-common';
import { CartographicRange } from '@bentley/imodeljs-common';
import { CategorySelectorProps } from '@bentley/imodeljs-common';
import { ClientRequestContext } from '@bentley/bentleyjs-core';
import { ClipPlane } from '@bentley/geometry-core';
import { ClipShape } from '@bentley/geometry-core';
import { ClipVector } from '@bentley/geometry-core';
import { Code } from '@bentley/imodeljs-common';
import { CodeSpec } from '@bentley/imodeljs-common';
import { ColorDef } from '@bentley/imodeljs-common';
import { ColorDefProps } from '@bentley/imodeljs-common';
import { ColorIndex } from '@bentley/imodeljs-common';
import { ContextRealityModelProps } from '@bentley/imodeljs-common';
import { ConvexClipPlaneSet } from '@bentley/geometry-core';
import { CurvePrimitive } from '@bentley/geometry-core';
import { DevToolsStatsOptions } from '@bentley/imodeljs-common';
import { Dictionary } from '@bentley/bentleyjs-core';
import { DisplayStyle3dSettings } from '@bentley/imodeljs-common';
import { DisplayStyleProps } from '@bentley/imodeljs-common';
import { DisplayStyleSettings } from '@bentley/imodeljs-common';
import { EdgeArgs } from '@bentley/imodeljs-common';
import { ElementAlignedBox2d } from '@bentley/imodeljs-common';
import { ElementAlignedBox3d } from '@bentley/imodeljs-common';
import { ElementProps } from '@bentley/imodeljs-common';
import { EntityProps } from '@bentley/imodeljs-common';
import { EntityQueryParams } from '@bentley/imodeljs-common';
import { EnvironmentProps } from '@bentley/imodeljs-common';
import { Feature } from '@bentley/imodeljs-common';
import { FeatureIndex } from '@bentley/imodeljs-common';
import { FeatureIndexType } from '@bentley/imodeljs-common';
import { FeatureTable } from '@bentley/imodeljs-common';
import { FillFlags } from '@bentley/imodeljs-common';
import { FontMap } from '@bentley/imodeljs-common';
import { Format } from '@bentley/imodeljs-quantity';
import { FormatterSpec } from '@bentley/imodeljs-quantity';
import { Frustum } from '@bentley/imodeljs-common';
import { FrustumPlanes } from '@bentley/imodeljs-common';
import * as Fuse from 'fuse.js';
import { GeoCoordinatesResponseProps } from '@bentley/imodeljs-common';
import { GeometricModel2dProps } from '@bentley/imodeljs-common';
import { GeometryClass } from '@bentley/imodeljs-common';
import { GeometryQuery } from '@bentley/geometry-core';
import { GeometryStreamProps } from '@bentley/imodeljs-common';
import { Gradient } from '@bentley/imodeljs-common';
import { GraphicParams } from '@bentley/imodeljs-common';
import { GroundPlane } from '@bentley/imodeljs-common';
import { GuidString } from '@bentley/bentleyjs-core';
import { HiddenLine } from '@bentley/imodeljs-common';
import { Hilite } from '@bentley/imodeljs-common';
import { I18N } from '@bentley/imodeljs-i18n';
import { I18NNamespace } from '@bentley/imodeljs-i18n';
import { I18NOptions } from '@bentley/imodeljs-i18n';
import { IAuthorizationClient } from '@bentley/imodeljs-clients';
import { Id64 } from '@bentley/bentleyjs-core';
import { Id64Arg } from '@bentley/bentleyjs-core';
import { Id64Array } from '@bentley/bentleyjs-core';
import { Id64Set } from '@bentley/bentleyjs-core';
import { Id64String } from '@bentley/bentleyjs-core';
import { IDisposable } from '@bentley/bentleyjs-core';
import { ImageBuffer } from '@bentley/imodeljs-common';
import { ImageSource } from '@bentley/imodeljs-common';
import { ImageSourceFormat } from '@bentley/imodeljs-common';
import { IModel } from '@bentley/imodeljs-common';
import { IModelClient } from '@bentley/imodeljs-clients';
import { IModelCoordinatesResponseProps } from '@bentley/imodeljs-common';
import { IModelToken } from '@bentley/imodeljs-common';
import { IModelVersion } from '@bentley/imodeljs-common';
import { IndexedPolyface } from '@bentley/geometry-core';
import { IndexMap } from '@bentley/bentleyjs-core';
import { IOidcFrontendClient } from '@bentley/imodeljs-clients';
import { LinePixels } from '@bentley/imodeljs-common';
import { LogLevel } from '@bentley/bentleyjs-core';
import { Loop } from '@bentley/geometry-core';
import { LowAndHighXY } from '@bentley/geometry-core';
import { LowAndHighXYZ } from '@bentley/geometry-core';
import { Map4d } from '@bentley/geometry-core';
import { Matrix3d } from '@bentley/geometry-core';
import { Matrix4d } from '@bentley/geometry-core';
import { MeshEdges } from '@bentley/imodeljs-common';
import { MeshPolyline } from '@bentley/imodeljs-common';
import { MeshPolylineList } from '@bentley/imodeljs-common';
import { ModelProps } from '@bentley/imodeljs-common';
import { ModelQueryParams } from '@bentley/imodeljs-common';
import { ModelSelectorProps } from '@bentley/imodeljs-common';
import { OctEncodedNormal } from '@bentley/imodeljs-common';
import { OidcClient } from '@bentley/imodeljs-clients';
import { OidcFrontendClientConfiguration } from '@bentley/imodeljs-clients';
import { OpenMode } from '@bentley/bentleyjs-core';
import { ParseResult } from '@bentley/imodeljs-quantity';
import { ParserSpec } from '@bentley/imodeljs-quantity';
import { Path } from '@bentley/geometry-core';
import { Placement2d } from '@bentley/imodeljs-common';
import { PlacementProps } from '@bentley/imodeljs-common';
import { Plane3dByOriginAndUnitNormal } from '@bentley/geometry-core';
import { Point2d } from '@bentley/geometry-core';
import { Point3d } from '@bentley/geometry-core';
import { Point4d } from '@bentley/geometry-core';
import { PointWithStatus } from '@bentley/imodeljs-common';
import { Polyface } from '@bentley/geometry-core';
import { PolyfaceVisitor } from '@bentley/geometry-core';
import { PolylineData } from '@bentley/imodeljs-common';
import { PolylineEdgeArgs } from '@bentley/imodeljs-common';
import { PolylineFlags } from '@bentley/imodeljs-common';
import { PolylineTypeFlags } from '@bentley/imodeljs-common';
import { QParams2d } from '@bentley/imodeljs-common';
import { QParams3d } from '@bentley/imodeljs-common';
import { QPoint3d } from '@bentley/imodeljs-common';
import { QPoint3dList } from '@bentley/imodeljs-common';
import { QueryLimit } from '@bentley/imodeljs-common';
import { QueryPriority } from '@bentley/imodeljs-common';
import { QueryQuota } from '@bentley/imodeljs-common';
import { QueryResponse } from '@bentley/imodeljs-common';
import { Range1d } from '@bentley/geometry-core';
import { Range1dProps } from '@bentley/geometry-core';
import { Range2d } from '@bentley/geometry-core';
import { Range3d } from '@bentley/geometry-core';
import { Range3dProps } from '@bentley/geometry-core';
import { Ray3d } from '@bentley/geometry-core';
import { RelatedElement } from '@bentley/imodeljs-common';
import { RenderMaterial } from '@bentley/imodeljs-common';
import { RenderSchedule } from '@bentley/imodeljs-common';
import { RenderTexture } from '@bentley/imodeljs-common';
import { RgbColor } from '@bentley/imodeljs-common';
import { SceneLights } from '@bentley/imodeljs-common';
import { SettingsAdmin } from '@bentley/imodeljs-clients';
import { SettingsMapResult } from '@bentley/imodeljs-clients';
import { SettingsResult } from '@bentley/imodeljs-clients';
import { SettingsStatus } from '@bentley/imodeljs-clients';
import { SheetProps } from '@bentley/imodeljs-common';
import { SilhouetteEdgeArgs } from '@bentley/imodeljs-common';
import { SkyBoxProps } from '@bentley/imodeljs-common';
import { SkyCubeProps } from '@bentley/imodeljs-common';
import { SnapRequestProps } from '@bentley/imodeljs-common';
import { SnapResponseProps } from '@bentley/imodeljs-common';
import { SolarShadows } from '@bentley/imodeljs-common';
import { SortedArray } from '@bentley/bentleyjs-core';
import { SpatialClassificationProps } from '@bentley/imodeljs-common';
import { SpatialViewDefinitionProps } from '@bentley/imodeljs-common';
import { StopWatch } from '@bentley/bentleyjs-core';
import { StrokeOptions } from '@bentley/geometry-core';
import { SubCategoryAppearance } from '@bentley/imodeljs-common';
import { SubCategoryOverride } from '@bentley/imodeljs-common';
import { TextureMapping } from '@bentley/imodeljs-common';
import { ThumbnailProps } from '@bentley/imodeljs-common';
import { TileProps } from '@bentley/imodeljs-common';
import { TileTreeProps } from '@bentley/imodeljs-common';
import { Transform } from '@bentley/geometry-core';
import { TransientIdSequence } from '@bentley/bentleyjs-core';
import { UnitConversion } from '@bentley/imodeljs-quantity';
import { UnitProps } from '@bentley/imodeljs-quantity';
import { UnitsProvider } from '@bentley/imodeljs-quantity';
import { Vector3d } from '@bentley/geometry-core';
import { ViewAttachmentProps } from '@bentley/imodeljs-common';
import { ViewDefinition2dProps } from '@bentley/imodeljs-common';
import { ViewDefinition3dProps } from '@bentley/imodeljs-common';
import { ViewDefinitionProps } from '@bentley/imodeljs-common';
import { ViewFlag } from '@bentley/imodeljs-common';
import { ViewFlags } from '@bentley/imodeljs-common';
import { ViewQueryParams } from '@bentley/imodeljs-common';
import { ViewStateProps } from '@bentley/imodeljs-common';
import { XAndY } from '@bentley/geometry-core';
import { XYAndZ } from '@bentley/geometry-core';
import { XYZ } from '@bentley/geometry-core';
import { XYZProps } from '@bentley/geometry-core';

// @internal
export class AccuDraw {
    // (undocumented)
    accountForAuxRotationPlane(rot: ThreeAxes, plane: RotationMode): void;
    // (undocumented)
    protected _acsPickId?: string;
    // (undocumented)
    activate(): void;
    // (undocumented)
    adjustPoint(pointActive: Point3d, vp: ScreenViewport, fromSnap: boolean): boolean;
    // (undocumented)
    alwaysShowCompass: boolean;
    // (undocumented)
    angleLock(): void;
    // (undocumented)
    protected _animationFrames: number;
    // (undocumented)
    autoFocusFields: boolean;
    // (undocumented)
    autoPointPlacement: boolean;
    // (undocumented)
    readonly axes: ThreeAxes;
    // (undocumented)
    axisIndexing: boolean;
    // (undocumented)
    readonly baseAxes: ThreeAxes;
    // (undocumented)
    changeBaseRotationMode(mode: RotationMode): void;
    // (undocumented)
    changeCompassMode(animate?: boolean): void;
    // (undocumented)
    clearTentative(): boolean;
    // (undocumented)
    compassMode: CompassMode;
    // (undocumented)
    protected _compassSizeInches: number;
    // (undocumented)
    contextSensitive: boolean;
    // (undocumented)
    currentState: CurrentState;
    // (undocumented)
    currentView?: ScreenViewport;
    // (undocumented)
    deactivate(): void;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    readonly delta: Vector3d;
    // (undocumented)
    disableForSession(): void;
    // (undocumented)
    distanceIndexing: boolean;
    // (undocumented)
    distanceLock(synchText: boolean, saveInHistory: boolean): void;
    // (undocumented)
    doAutoPoint(index: ItemField, mode: CompassMode): Promise<void>;
    // (undocumented)
    doLockAngle(isSnapped: boolean): void;
    // (undocumented)
    dontMoveFocus: boolean;
    // (undocumented)
    downgradeInactiveState(): boolean;
    // (undocumented)
    enableForSession(): void;
    // (undocumented)
    protected readonly _fillColor: ColorDef;
    // (undocumented)
    protected readonly _fillColorNoFocus: ColorDef;
    // (undocumented)
    fixPointPolar(vp: Viewport): void;
    // (undocumented)
    fixPointRectangular(vp: Viewport): void;
    // (undocumented)
    readonly flags: Flags;
    // (undocumented)
    floatingOrigin: boolean;
    // (undocumented)
    protected readonly _frameColor: ColorDef;
    // (undocumented)
    protected readonly _frameColorNoFocus: ColorDef;
    // (undocumented)
    static getCurrentOrientation(vp: Viewport, checkAccuDraw: boolean, checkACS: boolean, rMatrix?: Matrix3d): Matrix3d | undefined;
    // (undocumented)
    getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    // (undocumented)
    getFieldLock(index: ItemField): boolean;
    // (undocumented)
    getKeyinStatus(index: ItemField): KeyinStatus;
    // (undocumented)
    getRotation(rMatrix?: Matrix3d): Matrix3d;
    // (undocumented)
    static getSnapRotation(snap: SnapDetail, currentVp: Viewport | undefined, out?: Matrix3d): Matrix3d | undefined;
    // (undocumented)
    static getStandardRotation(nStandard: StandardViewId, vp: Viewport | undefined, useACS: boolean, out?: Matrix3d): Matrix3d;
    // (undocumented)
    getValueByIndex(index: ItemField): number;
    grabInputFocus(): void;
    // (undocumented)
    hardConstructionPlane(outPtP: Point3d, inPtP: Point3d, pointOnPlaneP: Point3d, normalVectorP: Vector3d, vp: Viewport, isSnap: boolean): boolean;
    // (undocumented)
    readonly hasInputFocus: boolean;
    // (undocumented)
    protected readonly _indexColor: ColorDef;
    // (undocumented)
    indexed: LockedStates;
    // (undocumented)
    protected _indexToleranceInches: number;
    // (undocumented)
    readonly isActive: boolean;
    // (undocumented)
    readonly isDeactivated: boolean;
    // (undocumented)
    readonly isEnabled: boolean;
    // (undocumented)
    readonly isInactive: boolean;
    // (undocumented)
    isZLocked(vp: Viewport): boolean;
    // (undocumented)
    readonly lastAxes: ThreeAxes;
    // (undocumented)
    locked: LockedStates;
    // (undocumented)
    newFocus: ItemField;
    // (undocumented)
    onBeginDynamics(): boolean;
    // (undocumented)
    onCompassModeChange(): void;
    // (undocumented)
    onEndDynamics(): boolean;
    // (undocumented)
    onFieldLockChange(_index: ItemField): void;
    // (undocumented)
    onFieldValueChange(_index: ItemField): void;
    // (undocumented)
    onInitialized(): void;
    // (undocumented)
    onInputCollectorExit(): boolean;
    // (undocumented)
    onInputCollectorInstall(): boolean;
    onMotion(_ev: BeButtonEvent): void;
    // (undocumented)
    onPostButtonEvent(ev: BeButtonEvent): boolean;
    // (undocumented)
    onPreButtonEvent(ev: BeButtonEvent): boolean;
    // (undocumented)
    onPrimitiveToolInstall(): boolean;
    // (undocumented)
    onRotationModeChange(): void;
    // (undocumented)
    onSelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void;
    // (undocumented)
    onSnap(snap: SnapDetail): boolean;
    // (undocumented)
    onTentative(): boolean;
    // (undocumented)
    onViewToolExit(): boolean;
    // (undocumented)
    onViewToolInstall(): boolean;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    readonly planePt: Point3d;
    // (undocumented)
    readonly point: Point3d;
    // (undocumented)
    processFieldInput(index: ItemField, input: string, synchText: boolean): Promise<void>;
    // (undocumented)
    processHints(): void;
    // (undocumented)
    readonly published: AccudrawData;
    // (undocumented)
    refreshDecorationsAndDynamics(): void;
    // (undocumented)
    restoreState(stateBuffer: SavedState): void;
    // (undocumented)
    rotationMode: RotationMode;
    // (undocumented)
    saveCoordinate(index: ItemField, value: number): void;
    // (undocumented)
    readonly savedStateInputCollector: SavedState;
    // (undocumented)
    readonly savedStateViewTool: SavedState;
    // (undocumented)
    saveState(stateBuffer: SavedState): void;
    // (undocumented)
    sendDataPoint(pt: Point3d, viewport: ScreenViewport): Promise<void>;
    // (undocumented)
    setCompassMode(mode: CompassMode): void;
    // (undocumented)
    setContext(flags: AccuDrawFlags, originP?: Point3d, orientationP?: Matrix3d | Vector3d, deltaP?: Vector3d, distanceP?: number, angleP?: number, transP?: Transform): BentleyStatus;
    // (undocumented)
    setContextRotation(rMatrix: Matrix3d, locked: boolean, animate: boolean): void;
    // (undocumented)
    setFieldLock(index: ItemField, locked: boolean): void;
    // (undocumented)
    setFocusItem(_index: ItemField): void;
    // (undocumented)
    setKeyinStatus(index: ItemField, status: KeyinStatus): void;
    // (undocumented)
    setLastPoint(pt: Point3d): void;
    // (undocumented)
    protected setNewFocus(index: ItemField): void;
    // (undocumented)
    setRotationMode(mode: RotationMode): void;
    // (undocumented)
    setValueByIndex(index: ItemField, value: number): void;
    // (undocumented)
    smartKeyin: boolean;
    // (undocumented)
    softConstructionPlane(outPtP: Point3d, inPtP: Point3d, pointOnPlaneP: Point3d, normalVectorP: Vector3d, vp: Viewport, isSnap: boolean): boolean;
    // (undocumented)
    stickyZLock: boolean;
    // (undocumented)
    testDecorationHit(id: string): boolean;
    // (undocumented)
    unlockAllFields(): void;
    // (undocumented)
    static updateAuxCoordinateSystem(acs: AuxCoordSystemState, vp: Viewport, allViews?: boolean): void;
    // (undocumented)
    updateFieldLock(index: ItemField, locked: boolean): void;
    // (undocumented)
    updateRotation(animate?: boolean, newRotationIn?: Matrix3d): void;
    // (undocumented)
    upgradeToActiveState(): boolean;
    // (undocumented)
    readonly vector: Vector3d;
    // (undocumented)
    protected readonly _xColor: ColorDef;
    // (undocumented)
    protected readonly _yColor: ColorDef;
    }

// @internal (undocumented)
export class AccudrawData {
    // (undocumented)
    angle: number;
    // (undocumented)
    readonly delta: Point3d;
    // (undocumented)
    distance: number;
    // (undocumented)
    flags: number;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    readonly rMatrix: Matrix3d;
    // (undocumented)
    readonly vector: Vector3d;
    // (undocumented)
    zero(): void;
}

// @internal (undocumented)
export enum AccuDrawFlags {
    // (undocumented)
    AlwaysSetOrigin = 2097156,
    // (undocumented)
    Disable = 4096,
    // (undocumented)
    FixedOrigin = 8,
    // (undocumented)
    Lock_X = 512,
    // (undocumented)
    Lock_Y = 1024,
    // (undocumented)
    Lock_Z = 2048,
    // (undocumented)
    LockAngle = 524288,
    // (undocumented)
    LockDistance = 256,
    // (undocumented)
    OrientACS = 131072,
    // (undocumented)
    OrientDefault = 16384,
    // (undocumented)
    RedrawCompass = 4194304,
    // (undocumented)
    SetDistance = 128,
    // (undocumented)
    SetFocus = 32768,
    // (undocumented)
    SetModePolar = 1,
    // (undocumented)
    SetModeRect = 2,
    // (undocumented)
    SetNormal = 64,
    // (undocumented)
    SetOrigin = 4,
    // (undocumented)
    SetRMatrix = 16,
    // (undocumented)
    SetXAxis = 32,
    // (undocumented)
    SetXAxis2 = 262144,
    // (undocumented)
    SmartRotation = 16777216,
    // (undocumented)
    UpdateRotation = 8388608
}

// @beta
export class AccuDrawHintBuilder {
    // (undocumented)
    static activate(): void;
    // (undocumented)
    static deactivate(): void;
    // (undocumented)
    enableSmartRotation: boolean;
    sendHints(activate?: boolean): boolean;
    // (undocumented)
    setAngle(angle: number): void;
    // (undocumented)
    setDistance(distance: number): void;
    // (undocumented)
    setLockAngle: boolean;
    // (undocumented)
    setLockDistance: boolean;
    // (undocumented)
    setLockX: boolean;
    // (undocumented)
    setLockY: boolean;
    // (undocumented)
    setLockZ: boolean;
    // (undocumented)
    setModePolar(): void;
    // (undocumented)
    setModeRectangular(): void;
    // (undocumented)
    setNormal(normal: Vector3d): void;
    // (undocumented)
    setOrigin(origin: Point3d): void;
    // (undocumented)
    setOriginAlways: boolean;
    // (undocumented)
    setOriginFixed: boolean;
    // (undocumented)
    setRotation(rMatrix: Matrix3d): void;
    // (undocumented)
    setXAxis(xAxis: Vector3d): void;
    // (undocumented)
    setXAxis2(xAxis: Vector3d): void;
}

// @alpha
export class AccuDrawShortcuts {
    // (undocumented)
    static alignView(): void;
    // (undocumented)
    static changeCompassMode(): void;
    // (undocumented)
    static defineACSByElement(): void;
    // (undocumented)
    static defineACSByPoints(): void;
    // (undocumented)
    static getACS(acsName: string | undefined, useOrigin: boolean, useRotation: boolean): BentleyStatus;
    // Warning: (ae-incompatible-release-tags) The symbol "itemFieldAcceptInput" is marked as @alpha, but its signature references "ItemField" which is marked as @internal
    // 
    // (undocumented)
    static itemFieldAcceptInput(index: ItemField, str: string): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "itemFieldLockToggle" is marked as @alpha, but its signature references "ItemField" which is marked as @internal
    // 
    // (undocumented)
    static itemFieldLockToggle(index: ItemField): void;
    // Warning: (ae-incompatible-release-tags) The symbol "itemFieldNavigate" is marked as @alpha, but its signature references "ItemField" which is marked as @internal
    // 
    // (undocumented)
    static itemFieldNavigate(index: ItemField, str: string, forward: boolean): Promise<void>;
    // Warning: (ae-incompatible-release-tags) The symbol "itemFieldNewInput" is marked as @alpha, but its signature references "ItemField" which is marked as @internal
    // 
    // (undocumented)
    static itemFieldNewInput(index: ItemField): void;
    // (undocumented)
    static itemFieldUnlockAll(): void;
    // (undocumented)
    static itemRotationModeChange(rotation: RotationMode): void;
    // (undocumented)
    static lockAngle(): void;
    // (undocumented)
    static lockDistance(): void;
    // (undocumented)
    lockIndex(): void;
    // (undocumented)
    static lockSmart(): void;
    // (undocumented)
    static lockX(): void;
    // (undocumented)
    static lockY(): void;
    // (undocumented)
    static lockZ(): void;
    // (undocumented)
    static processPendingHints(): void;
    // @internal
    static processShortcutKey(keyEvent: KeyboardEvent): boolean;
    // (undocumented)
    static requestInputFocus(): void;
    // (undocumented)
    static rotate90(axis: number): void;
    // (undocumented)
    static rotateAxes(aboutCurrentZ: boolean): void;
    // (undocumented)
    static rotateAxesByPoint(isSnapped: boolean, aboutCurrentZ: boolean): boolean;
    // (undocumented)
    static rotateCycle(updateCurrentACS: boolean): void;
    // (undocumented)
    static rotateToACS(): void;
    // (undocumented)
    static rotateToBase(): void;
    // (undocumented)
    static rotateToElement(updateCurrentACS: boolean): void;
    // (undocumented)
    static setOrigin(explicitOrigin?: Point3d): void;
    // (undocumented)
    static setStandardRotation(rotation: RotationMode): void;
    // (undocumented)
    static updateACSByPoints(acs: AuxCoordSystemState, vp: Viewport, points: Point3d[], isDynamics: boolean): boolean;
    // (undocumented)
    static writeACS(_acsName: string): BentleyStatus;
}

// @internal (undocumented)
export abstract class AccuDrawTool {
    // (undocumented)
    activateAccuDrawOnStart(): boolean;
    // (undocumented)
    abstract doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): Promise<boolean>;
    // (undocumented)
    doManipulationStart(): void;
    // (undocumented)
    doManipulationStop(cancel: boolean): void;
    // (undocumented)
    static installTool(shortcut: AccuDrawTool): boolean;
    // (undocumented)
    onDecorate(_context: DecorateContext): void;
    // (undocumented)
    onManipulationComplete(): AccuDrawFlags;
    // (undocumented)
    static outputPrompt(messageKey: string): void;
}

// @public
export class AccuSnap implements Decorator {
    // @internal (undocumented)
    adjustPointIfHot(pt: Point3d, view: Viewport): void;
    readonly areFlashed: Set<Viewport>;
    aSnapHits?: HitList<HitDetail>;
    clear(): void;
    // @internal (undocumented)
    clearIfElement(sourceId: string): void;
    // @internal (undocumented)
    clearToolTip(ev?: BeButtonEvent): void;
    readonly cross: SpriteLocation;
    currHit?: HitDetail;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    destroy(): void;
    // @internal (undocumented)
    displayToolTip(viewPt: XAndY, vp: ScreenViewport, uorPt?: Point3d): void;
    enableLocate(yesNo: boolean): void;
    enableSnap(yesNo: boolean): void;
    // @internal (undocumented)
    erase(): void;
    readonly errorIcon: SpriteLocation;
    errorKey?: string;
    explanation?: string;
    getActiveSnapModes(): SnapMode[];
    // @internal (undocumented)
    getCurrSnapDetail(): SnapDetail | undefined;
    // @internal (undocumented)
    getHitAndList(holder: HitListHolder): HitDetail | undefined;
    readonly icon: SpriteLocation;
    // @internal (undocumented)
    intersectXY(tpSnap: SnapDetail, second: SnapDetail): IntersectDetail | undefined;
    readonly isActive: boolean;
    readonly isHot: boolean;
    readonly isLocateEnabled: boolean;
    readonly isSnapEnabled: boolean;
    readonly isSnapEnabledByUser: boolean;
    readonly keypointDivisor: number;
    readonly needFlash: Set<Viewport>;
    // @internal
    onEnabledStateChange(_isEnabled: boolean, _wasEnabled: boolean): void;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal
    onMotion(ev: BeButtonEvent): Promise<void>;
    // @internal (undocumented)
    onMotionStopped(_ev: BeButtonEvent): void;
    // @internal (undocumented)
    onNoMotion(ev: BeButtonEvent): Promise<void>;
    // @internal (undocumented)
    onPreButtonEvent(ev: BeButtonEvent): boolean;
    // @internal
    onStartTool(): void;
    // @internal (undocumented)
    onTouchCancel(ev: BeTouchEvent): void;
    // @internal (undocumented)
    onTouchEnd(ev: BeTouchEvent): void;
    // @internal (undocumented)
    onTouchMove(ev: BeTouchEvent): boolean;
    // @internal (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): boolean;
    // @internal (undocumented)
    onTouchStart(ev: BeTouchEvent): void;
    // @internal (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<boolean>;
    // @internal
    reEvaluate(): Promise<void>;
    // @internal (undocumented)
    static requestSnap(thisHit: HitDetail, snapModes: SnapMode[], hotDistanceInches: number, keypointDivisor: number, hitList?: HitList<HitDetail>, out?: LocateResponse): Promise<SnapDetail | undefined>;
    // @internal
    resetButton(): Promise<SnapStatus>;
    // @internal (undocumented)
    setCurrHit(newHit?: HitDetail): void;
    // @internal (undocumented)
    protected _settings: AccuSnap.Settings;
    // @internal (undocumented)
    showElemInfo(viewPt: XAndY, vp: ScreenViewport, hit: HitDetail): void;
    // @internal (undocumented)
    suppress(doSuppress: boolean): number;
    // @internal (undocumented)
    suspend(doSuspend: boolean): void;
    // @internal
    synchSnapMode(): void;
    // @internal (undocumented)
    readonly toolState: AccuSnap.ToolState;
    // @internal (undocumented)
    touchCursor?: TouchCursor;
    }

// @public (undocumented)
export namespace AccuSnap {
    // (undocumented)
    export class Settings {
        // (undocumented)
        enableFlag: boolean;
        // (undocumented)
        hiliteColdHits: boolean;
        // (undocumented)
        hotDistanceFactor: number;
        // (undocumented)
        searchDistance: number;
        // (undocumented)
        stickyFactor: number;
        // (undocumented)
        toolTip: boolean;
        // (undocumented)
        toolTipDelay: BeDuration;
    }
    // (undocumented)
    export class ToolState {
        // (undocumented)
        clone(): ToolState;
        // (undocumented)
        enabled: boolean;
        // (undocumented)
        locate: boolean;
        // (undocumented)
        setFrom(other: ToolState): void;
        // (undocumented)
        suspended: number;
    }
}

// @public (undocumented)
export enum ACSDisplayOptions {
    // (undocumented)
    Active = 1,
    // (undocumented)
    CheckVisible = 8,
    // (undocumented)
    Deemphasized = 2,
    // (undocumented)
    Dynamics = 16,
    // (undocumented)
    Hilite = 4,
    // (undocumented)
    None = 0
}

// @public (undocumented)
export enum ACSType {
    // (undocumented)
    Cylindrical = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    Rectangular = 1,
    // (undocumented)
    Spherical = 3
}

// @alpha (undocumented)
export enum ActiveClipStatus {
    // (undocumented)
    Modified = 3,
    // (undocumented)
    None = 0,
    // (undocumented)
    Saved = 2,
    // (undocumented)
    Unsaved = 1
}

// @public
export class ActivityMessageDetails {
    constructor(showProgressBar: boolean, showPercentInMessage: boolean, supportsCancellation: boolean, showDialogInitially?: boolean);
    onActivityCancelled(): void;
    onActivityCompleted(): void;
    // (undocumented)
    showDialogInitially: boolean;
    // (undocumented)
    showPercentInMessage: boolean;
    // (undocumented)
    showProgressBar: boolean;
    // (undocumented)
    supportsCancellation: boolean;
    // (undocumented)
    wasCancelled: boolean;
}

// @public
export enum ActivityMessageEndReason {
    // (undocumented)
    Cancelled = 1,
    // (undocumented)
    Completed = 0
}

// @internal
export class AnimationBranchState {
    constructor(transform?: Transform, clip?: RenderClipVolume, omit?: boolean);
    // (undocumented)
    readonly clip?: RenderClipVolume;
    // (undocumented)
    readonly omit?: boolean;
    // (undocumented)
    readonly transform?: Transform;
}

// @internal
export type AnimationBranchStates = Map<string, AnimationBranchState>;

// @internal (undocumented)
export interface AppearanceOverrideProps {
    // (undocumented)
    color?: ColorDefProps;
    // (undocumented)
    ids?: Id64Set;
    // (undocumented)
    overrideType?: FeatureOverrideType;
}

// @beta
export interface ArrayValue extends BasePropertyValue {
    // (undocumented)
    items: PropertyRecord[];
    // (undocumented)
    itemsTypeName: string;
    // (undocumented)
    valueFormat: PropertyValueFormat.Array;
}

// @internal (undocumented)
export namespace Attachments {
    // (undocumented)
    export abstract class Attachment {
        protected constructor(props: ViewAttachmentProps, view: ViewState);
        clearClipping(): void;
        // (undocumented)
        clip: ClipVector;
        static readonly DEBUG_BOUNDING_BOX_COLOR: ColorDef;
        debugDrawBorder(context: SceneContext): void;
        // (undocumented)
        displayPriority: number;
        getOrCreateClip(transform?: Transform): ClipVector;
        // (undocumented)
        id: Id64String;
        abstract readonly is2d: boolean;
        readonly isReady: boolean;
        abstract load(sheetView: SheetViewState, sceneContext: SceneContext): State;
        // (undocumented)
        placement: Placement2d;
        // (undocumented)
        scale: number;
        tree: Tree | undefined;
        // (undocumented)
        protected _tree?: Tree;
        // (undocumented)
        readonly view: ViewState;
    }
    // (undocumented)
    export class Attachment2d extends Attachment {
        constructor(props: ViewAttachmentProps, view: ViewState2d);
        // (undocumented)
        readonly is2d: boolean;
        // (undocumented)
        load(_sheetView: SheetViewState, _sceneContext: SceneContext): State;
    }
    // (undocumented)
    export class Attachment3d extends Attachment {
        constructor(props: ViewAttachmentProps, view: ViewState3d);
        getState(depth: number): State;
        // (undocumented)
        readonly is2d: boolean;
        // (undocumented)
        load(sheetView: SheetViewState, sceneContext: SceneContext): State;
        setState(depth: number, state: State): void;
        }
    // (undocumented)
    export class AttachmentList {
        constructor();
        add(attachment: Attachment): void;
        readonly allReady: boolean;
        clear(): void;
        drop(attachment: Attachment): void;
        readonly length: number;
        // (undocumented)
        readonly list: Attachment[];
        load(idx: number, sheetView: SheetViewState, sceneContext: SceneContext): State;
        }
    // (undocumented)
    export abstract class AttachmentTileLoader extends TileLoader {
        // (undocumented)
        getChildrenProps(_parent: Tile): Promise<TileProps[]>;
        // (undocumented)
        abstract readonly is3dAttachment: boolean;
        // (undocumented)
        readonly priority: Tile.LoadPriority;
        // (undocumented)
        requestTileContent(_tile: Tile): Promise<TileRequest.Response>;
        // (undocumented)
        tileRequiresLoading(_params: Tile.Params): boolean;
    }
    // (undocumented)
    export class AttachmentViewport extends OffScreenViewport {
        // (undocumented)
        createScene(currentState: State): State;
        // (undocumented)
        readonly isAspectRatioLocked: boolean;
        // (undocumented)
        renderImage(): ImageBuffer | undefined;
        // (undocumented)
        rendering: boolean;
        // (undocumented)
        renderTexture(): void;
        // (undocumented)
        setSceneDepth(depth: number, tree: Tree3d): void;
        // (undocumented)
        readonly texture: RenderTexture | undefined;
        // (undocumented)
        toParent: Transform;
    }
    export const enum State {
        // (undocumented)
        Empty = 1,
        // (undocumented)
        Loading = 2,
        // (undocumented)
        NotLoaded = 0,
        // (undocumented)
        Ready = 3
    }
    // (undocumented)
    export class Tile2d extends Tile {
        constructor(root: Tree2d, range: ElementAlignedBox2d);
        // (undocumented)
        drawGraphics(args: Tile.DrawArgs): void;
        // (undocumented)
        readonly hasChildren: boolean;
        // (undocumented)
        readonly hasGraphics: boolean;
    }
    // (undocumented)
    export class Tile3d extends Tile {
        // (undocumented)
        static create(root: Tree3d, parent: Tile3d | undefined, placement: Tile3dPlacement): Tile3d;
        // (undocumented)
        createGraphics(context: SceneContext): void;
        // (undocumented)
        createPolyfaces(context: SceneContext): void;
        // (undocumented)
        drawGraphics(args: Tile.DrawArgs): void;
        // (undocumented)
        readonly hasChildren: boolean;
        // (undocumented)
        readonly hasGraphics: boolean;
        // (undocumented)
        prepareChildren(): Tile[] | undefined;
        // (undocumented)
        selectTiles(selected: Tile[], args: Tile.DrawArgs, _numSkipped?: number): Tile.SelectParent;
        }
    export const enum Tile3dPlacement {
        // (undocumented)
        LowerLeft = 2,
        // (undocumented)
        LowerRight = 3,
        // (undocumented)
        Root = 4,
        // (undocumented)
        UpperLeft = 0,
        // (undocumented)
        UpperRight = 1
    }
    // (undocumented)
    export abstract class Tree extends TileTree {
        constructor(loader: AttachmentTileLoader, iModel: IModelConnection, modelId: Id64String);
        // (undocumented)
        dispose(): void;
        // (undocumented)
        graphicsClip?: RenderClipVolume;
    }
    // (undocumented)
    export class Tree2d extends Tree {
        static create(attachment: Attachment2d): State;
        // (undocumented)
        readonly drawingToAttachment: Transform;
        // (undocumented)
        readonly symbologyOverrides: FeatureSymbology.Overrides;
        // (undocumented)
        readonly view: ViewState2d;
        // (undocumented)
        readonly viewRoot: TileTree;
    }
    // (undocumented)
    export class Tree3d extends Tree {
        // (undocumented)
        readonly attachment: Attachment3d;
        // (undocumented)
        readonly biasDistance: number;
        // (undocumented)
        static create(sheetView: SheetViewState, attachment: Attachment3d, sceneContext: SceneContext): Tree3d;
        // (undocumented)
        readonly featureTable: PackedFeatureTable;
        getRootRange(result?: Range3d): Range3d;
        getState(depth: number): State;
        setState(depth: number, state: State): void;
        // (undocumented)
        readonly sheetView: SheetViewState;
        // (undocumented)
        readonly tileColor: ColorDef;
        // (undocumented)
        readonly viewport: AttachmentViewport;
    }
}

// @public
export class AuthorizedFrontendRequestContext extends AuthorizedClientRequestContext {
    constructor(accessToken: AccessToken, activityId?: string);
    static create(activityId?: string): Promise<AuthorizedFrontendRequestContext>;
}

// @public
export class AuxCoordSystem2dState extends AuxCoordSystemState implements AuxCoordSystem2dProps {
    constructor(props: AuxCoordSystem2dProps, iModel: IModelConnection);
    // (undocumented)
    angle: number;
    // @internal (undocumented)
    static readonly className: string;
    // (undocumented)
    getOrigin(result?: Point3d): Point3d;
    // (undocumented)
    getRotation(result?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly origin: Point2d;
    // (undocumented)
    setOrigin(val: XYAndZ | XAndY): void;
    // (undocumented)
    setRotation(val: Matrix3d): void;
    // (undocumented)
    toJSON(): AuxCoordSystem2dProps;
}

// @public
export class AuxCoordSystem3dState extends AuxCoordSystemState implements AuxCoordSystem3dProps {
    constructor(props: AuxCoordSystem3dProps, iModel: IModelConnection);
    // @internal (undocumented)
    static readonly className: string;
    // (undocumented)
    getOrigin(result?: Point3d): Point3d;
    // (undocumented)
    getRotation(result?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    pitch: number;
    // (undocumented)
    roll: number;
    // (undocumented)
    setOrigin(val: XYAndZ | XAndY): void;
    // (undocumented)
    setRotation(rMatrix: Matrix3d): void;
    // (undocumented)
    toJSON(): AuxCoordSystem3dProps;
    // (undocumented)
    yaw: number;
}

// @public
export class AuxCoordSystemSpatialState extends AuxCoordSystem3dState {
    // @internal (undocumented)
    static readonly className: string;
}

// @public
export abstract class AuxCoordSystemState extends ElementState implements AuxCoordSystemProps {
    constructor(props: AuxCoordSystemProps, iModel: IModelConnection);
    // @internal (undocumented)
    static readonly className: string;
    static createNew(acsName: string, iModel: IModelConnection): AuxCoordSystemState;
    // (undocumented)
    description?: string;
    // (undocumented)
    display(context: DecorateContext, options: ACSDisplayOptions): void;
    // (undocumented)
    drawGrid(context: DecorateContext): void;
    // (undocumented)
    static fromProps(props: AuxCoordSystemProps, iModel: IModelConnection): AuxCoordSystemState;
    // (undocumented)
    abstract getOrigin(result?: Point3d): Point3d;
    abstract getRotation(result?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly is3d: boolean;
    static isOriginInView(drawOrigin: Point3d, viewport: Viewport, adjustOrigin: boolean): boolean;
    // (undocumented)
    isValidForView(view: ViewState): boolean;
    // (undocumented)
    abstract setOrigin(val: XYAndZ | XAndY): void;
    // (undocumented)
    abstract setRotation(val: Matrix3d): void;
    // (undocumented)
    toJSON(): AuxCoordSystemProps;
    // (undocumented)
    type: number;
}

// @internal
export class BackgroundMapProvider extends BaseTiledMapProvider implements TiledGraphicsProvider.Provider {
    constructor(json: BackgroundMapProps, iModel: IModelConnection);
    // (undocumented)
    equalsProps(props: BackgroundMapProps): boolean;
    // (undocumented)
    getTileTree(viewport: Viewport): TiledGraphicsProvider.Tree | undefined;
    // (undocumented)
    mapType: BackgroundMapType;
    // (undocumented)
    providerName: string;
}

// @alpha
export interface BasePropertyEditorParams {
    // (undocumented)
    type: PropertyEditorParamTypes;
}

// @beta
export interface BasePropertyValue {
    // (undocumented)
    valueFormat: PropertyValueFormat;
}

// @internal
export class BaseTiledMapProvider {
    constructor(iModel: IModelConnection, groundBias: number);
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    getPlane(): Plane3dByOriginAndUnitNormal;
    // (undocumented)
    getTilesForView(viewport: ScreenViewport): Tile[];
    // (undocumented)
    protected _groundBias: number;
    // (undocumented)
    protected _imageryProvider?: ImageryProvider;
    // (undocumented)
    protected _iModel: IModelConnection;
    // (undocumented)
    protected loadTileTree(): TileTree.LoadStatus;
    // (undocumented)
    setTileTree(props: TileTreeProps, loader: TileLoader): void;
    // (undocumented)
    protected _tileTree?: TileTree;
}

// @public (undocumented)
export enum BeButton {
    // (undocumented)
    Data = 0,
    // (undocumented)
    Middle = 2,
    // (undocumented)
    Reset = 1
}

// @public
export class BeButtonEvent implements BeButtonEventProps {
    constructor(props?: BeButtonEventProps);
    button: BeButton;
    clone(): this;
    coordsFrom: CoordSource;
    init(props: BeButtonEventProps): void;
    inputSource: InputSource;
    invalidate(): void;
    readonly isAltKey: boolean;
    readonly isControlKey: boolean;
    isDoubleClick: boolean;
    isDown: boolean;
    isDragging: boolean;
    readonly isShiftKey: boolean;
    readonly isValid: boolean;
    keyModifiers: BeModifierKeys;
    point: Point3d;
    rawPoint: Point3d;
    setFrom(src: BeButtonEvent): this;
    viewPoint: Point3d;
    viewport?: ScreenViewport;
}

// @public
export interface BeButtonEventProps {
    button?: BeButton;
    coordsFrom?: CoordSource;
    inputSource?: InputSource;
    isDoubleClick?: boolean;
    isDown?: boolean;
    isDragging?: boolean;
    // (undocumented)
    keyModifiers?: BeModifierKeys;
    point?: Point3d;
    rawPoint?: Point3d;
    viewPoint?: Point3d;
    viewport?: ScreenViewport;
}

// @public (undocumented)
export class BeButtonState {
    // (undocumented)
    downRawPt: Point3d;
    // (undocumented)
    downTime: number;
    // (undocumented)
    downUorPt: Point3d;
    // (undocumented)
    init(downUorPt: Point3d, downRawPt: Point3d, downTime: number, isDown: boolean, isDoubleClick: boolean, isDragging: boolean, source: InputSource): void;
    // (undocumented)
    inputSource: InputSource;
    // (undocumented)
    isDoubleClick: boolean;
    // (undocumented)
    isDown: boolean;
    // (undocumented)
    isDragging: boolean;
}

// @public
export enum BeModifierKeys {
    // (undocumented)
    Alt = 4,
    // (undocumented)
    Control = 1,
    // (undocumented)
    None = 0,
    // (undocumented)
    Shift = 2
}

// @public
export class BeTouchEvent extends BeButtonEvent implements BeTouchEventProps {
    constructor(props: BeTouchEventProps);
    // (undocumented)
    static findTouchById(list: TouchList, id: number): Touch | undefined;
    // (undocumented)
    static getTouchListCentroid(list: TouchList, vp: ScreenViewport): Point2d | undefined;
    // (undocumented)
    static getTouchPosition(touch: Touch, vp: ScreenViewport): Point2d;
    // (undocumented)
    readonly isDoubleTap: boolean;
    // (undocumented)
    readonly isSingleTap: boolean;
    // (undocumented)
    readonly isSingleTouch: boolean;
    // (undocumented)
    readonly isTwoFingerTap: boolean;
    // (undocumented)
    readonly isTwoFingerTouch: boolean;
    // (undocumented)
    setFrom(src: BeTouchEvent): this;
    // (undocumented)
    tapCount: number;
    // (undocumented)
    readonly touchCount: number;
    // (undocumented)
    touchEvent: TouchEvent;
}

// @public
export interface BeTouchEventProps extends BeButtonEventProps {
    // (undocumented)
    touchEvent: TouchEvent;
}

// @public
export class BeWheelEvent extends BeButtonEvent implements BeWheelEventProps {
    constructor(props?: BeWheelEventProps);
    // (undocumented)
    setFrom(src: BeWheelEvent): this;
    // (undocumented)
    wheelDelta: number;
}

// @public
export interface BeWheelEventProps extends BeButtonEventProps {
    // (undocumented)
    wheelDelta?: number;
}

// @internal (undocumented)
export function bisectRange2d(range: Range3d, takeUpper: boolean): void;

// @internal (undocumented)
export function bisectRange3d(range: Range3d, takeUpper: boolean): void;

// @alpha
export interface ButtonGroupEditorParams extends BasePropertyEditorParams {
    // (undocumented)
    buttons: IconDefinition[];
    // (undocumented)
    type: PropertyEditorParamTypes.ButtonGroupData;
}

// @internal
export interface CachedIModelCoordinatesResponseProps {
    missing?: XYZProps[];
    result: Array<PointWithStatus | undefined>;
}

// @beta
export function calculateSolarAngles(date: Date, location: Cartographic): {
    azimuth: number;
    elevation: number;
};

// @beta
export function calculateSolarDirection(date: Date, location: Cartographic): Vector3d;

// @beta
export function calculateSunriseOrSunset(date: Date, location: Cartographic, sunrise: boolean): Date;

// @public
export interface CanvasDecoration {
    decorationCursor?: string;
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    onMouseButton?(ev: BeButtonEvent): boolean;
    onMouseEnter?(ev: BeButtonEvent): void;
    onMouseLeave?(): void;
    onMouseMove?(ev: BeButtonEvent): void;
    onWheel?(ev: BeWheelEvent): boolean;
    pick?(pt: XAndY): boolean;
    position?: XAndY;
}

// @public
export type CanvasDecorationList = CanvasDecoration[];

// @public
export class CategorySelectorState extends ElementState {
    constructor(props: CategorySelectorProps, iModel: IModelConnection);
    addCategories(arg: Id64Arg): void;
    // (undocumented)
    categories: Set<string>;
    changeCategoryDisplay(arg: Id64Arg, add: boolean): void;
    // @internal (undocumented)
    static readonly className: string;
    dropCategories(arg: Id64Arg): void;
    equalState(other: CategorySelectorState): boolean;
    has(id: Id64String): boolean;
    isCategoryViewed(categoryId: Id64String): boolean;
    readonly name: string;
    // (undocumented)
    toJSON(): CategorySelectorProps;
}

// @beta
export enum ChangeFlag {
    // (undocumented)
    All = 268435455,
    // (undocumented)
    AlwaysDrawn = 1,
    // (undocumented)
    DisplayStyle = 16,
    // (undocumented)
    FeatureOverrideProvider = 32,
    // (undocumented)
    Initial = 28,
    // (undocumented)
    NeverDrawn = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    Overrides = 268435447,
    // (undocumented)
    ViewedCategories = 4,
    // (undocumented)
    ViewedCategoriesPerModel = 64,
    // (undocumented)
    ViewedModels = 8
}

// @beta
export class ChangeFlags {
    constructor(flags?: ChangeFlag);
    readonly alwaysDrawn: boolean;
    areAllSet(flags: ChangeFlag): boolean;
    readonly areFeatureOverridesDirty: boolean;
    clear(flags?: ChangeFlag): void;
    readonly displayStyle: boolean;
    readonly featureOverrideProvider: boolean;
    readonly hasChanges: boolean;
    isSet(flags: ChangeFlag): boolean;
    readonly neverDrawn: boolean;
    set(flags: ChangeFlag): void;
    // (undocumented)
    setAlwaysDrawn(): void;
    // (undocumented)
    setDisplayStyle(): void;
    // (undocumented)
    setFeatureOverrideProvider(): void;
    // (undocumented)
    setNeverDrawn(): void;
    // (undocumented)
    setViewedCategories(): void;
    // (undocumented)
    setViewedCategoriesPerModel(): void;
    // (undocumented)
    setViewedModels(): void;
    // (undocumented)
    readonly value: ChangeFlag;
    readonly viewedCategories: boolean;
    // @alpha
    readonly viewedCategoriesPerModel: boolean;
    readonly viewedModels: boolean;
}

// @public
export interface ChangeViewedModel2dOptions {
    doFit?: boolean;
}

// @alpha
export interface CheckBoxIconsEditorParams extends BasePropertyEditorParams {
    // (undocumented)
    offIconDefinition?: IconDefinition;
    // (undocumented)
    onIconDefinition?: IconDefinition;
    // (undocumented)
    type: PropertyEditorParamTypes.CheckBoxIcons;
}

// @beta
export const enum ClassifierType {
    // (undocumented)
    Planar = 1,
    // (undocumented)
    Volume = 0
}

// @alpha
export enum ClipEventType {
    // (undocumented)
    Activate = 4,
    // (undocumented)
    Clear = 3,
    // (undocumented)
    Modify = 2,
    // (undocumented)
    New = 0,
    // (undocumented)
    NewPlane = 1
}

// @alpha
export enum ClipOrientation {
    // (undocumented)
    Back = 4,
    // (undocumented)
    Bottom = 3,
    // (undocumented)
    Face = 7,
    // (undocumented)
    Front = 1,
    // (undocumented)
    Left = 2,
    // (undocumented)
    Right = 5,
    // (undocumented)
    Top = 0,
    // (undocumented)
    View = 6
}

// @beta
export const enum ClippingType {
    Mask = 1,
    None = 0,
    Planes = 2
}

// @internal
export enum ClipResult {
    NewElements = 1,
    NotSupported = 0,
    OriginalElements = 2
}

// @internal
export class Clips {
    // (undocumented)
    clear(): void;
    // (undocumented)
    readonly count: number;
    // (undocumented)
    readonly isValid: boolean;
    // (undocumented)
    set(numPlanes: number, texture: TextureHandle): void;
    // (undocumented)
    readonly texture: TextureHandle | undefined;
    }

// @public
export class Cluster<T extends Marker> {
    constructor(markers: T[]);
    // (undocumented)
    clusterMarker?: Marker;
    // (undocumented)
    readonly markers: T[];
    // (undocumented)
    readonly rect: ViewRect;
}

// @alpha
export interface ColorEditorParams extends BasePropertyEditorParams {
    colorValues: number[];
    numColumns?: number;
    // (undocumented)
    type: PropertyEditorParamTypes.ColorData;
}

// @internal (undocumented)
export enum CompassMode {
    // (undocumented)
    Polar = 0,
    // (undocumented)
    Rectangular = 1
}

// @internal (undocumented)
export enum ContextMode {
    // (undocumented)
    Locked = 0,
    // (undocumented)
    None = 15,
    // (undocumented)
    XAxis = 1,
    // (undocumented)
    XAxis2 = 4,
    // (undocumented)
    YAxis = 2,
    // (undocumented)
    ZAxis = 3
}

// @internal (undocumented)
export class ContextRealityModelState implements TileTreeModelState {
    constructor(props: ContextRealityModelProps, iModel: IModelConnection);
    static findAvailableRealityModels(projectid: string, modelCartographicRange?: CartographicRange | undefined): Promise<ContextRealityModelProps[]>;
    static findAvailableUnattachedRealityModels(projectid: string, iModel?: IModelConnection, modelCartographicRange?: CartographicRange | undefined): Promise<ContextRealityModelProps[]>;
    // (undocumented)
    readonly iModel: IModelConnection;
    // (undocumented)
    protected _iModel: IModelConnection;
    intersectsProjectExtents(): Promise<boolean>;
    // (undocumented)
    readonly jsonProperties: {
        [key: string]: any;
    };
    // (undocumented)
    protected _jsonProperties: {
        [key: string]: any;
    };
    // (undocumented)
    readonly loadStatus: TileTree.LoadStatus;
    // (undocumented)
    loadTree(_edgesRequired: boolean, _animationId?: Id64String): TileTree.LoadStatus;
    matches(other: ContextRealityModelState): boolean;
    // (undocumented)
    protected _modelId: Id64String;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    protected _name: string;
    // (undocumented)
    protected _tilesetUrl: string;
    // (undocumented)
    readonly tileTree: TileTree | undefined;
    // (undocumented)
    protected _tileTreeState: TileTreeState;
    // (undocumented)
    readonly treeModelId: Id64String;
    // (undocumented)
    readonly url: string;
}

// @alpha
export class ConversionData implements UnitConversion {
    // (undocumented)
    factor: number;
    // (undocumented)
    offset: number;
}

// @public (undocumented)
export enum CoordinateLockOverrides {
    // (undocumented)
    ACS = 2,
    // (undocumented)
    All = 65535,
    // (undocumented)
    Grid = 4,
    // (undocumented)
    None = 0
}

// @public
export enum CoordSource {
    ElemSnap = 3,
    Precision = 1,
    TentativePoint = 2,
    User = 0
}

// @public
export enum CoordSystem {
    Npc = 1,
    View = 0,
    World = 2
}

// @internal (undocumented)
export class CurrentInputState {
    // (undocumented)
    adjustLastDataPoint(ev: BeButtonEvent): void;
    // (undocumented)
    button: BeButtonState[];
    // (undocumented)
    changeButtonToDownPoint(ev: BeButtonEvent): void;
    // (undocumented)
    clearKeyQualifiers(): void;
    // (undocumented)
    clearViewport(vp: Viewport): void;
    // (undocumented)
    fromButton(vp: ScreenViewport, pt: XAndY, source: InputSource, applyLocks: boolean): void;
    // (undocumented)
    fromPoint(vp: ScreenViewport, pt: XAndY, source: InputSource): void;
    // (undocumented)
    readonly hasMotionStopped: boolean;
    // (undocumented)
    inputSource: InputSource;
    // (undocumented)
    readonly isAltDown: boolean;
    // (undocumented)
    readonly isControlDown: boolean;
    // (undocumented)
    isDragging(button: BeButton): boolean;
    // (undocumented)
    readonly isShiftDown: boolean;
    // (undocumented)
    isStartDrag(button: BeButton): boolean;
    // (undocumented)
    lastButton: BeButton;
    // (undocumented)
    lastMotion: Point2d;
    // (undocumented)
    lastTouchStart?: BeTouchEvent;
    // (undocumented)
    lastWheelEvent?: BeWheelEvent;
    // (undocumented)
    motionTime: number;
    // (undocumented)
    onButtonDown(button: BeButton): void;
    // (undocumented)
    onButtonUp(button: BeButton): void;
    // (undocumented)
    onInstallTool(): void;
    // (undocumented)
    onMotion(pt2d: XAndY): void;
    // (undocumented)
    onStartDrag(button: BeButton): void;
    // (undocumented)
    qualifiers: BeModifierKeys;
    // (undocumented)
    rawPoint: Point3d;
    // (undocumented)
    setKeyQualifiers(ev: MouseEvent | KeyboardEvent | TouchEvent): void;
    // (undocumented)
    toEvent(ev: BeButtonEvent, useSnap: boolean): void;
    // (undocumented)
    toEventFromLastDataPoint(ev: BeButtonEvent): void;
    // (undocumented)
    touchTapCount?: number;
    // (undocumented)
    touchTapTimer?: number;
    // (undocumented)
    uorPoint: Point3d;
    // (undocumented)
    updateDownPoint(ev: BeButtonEvent): void;
    // (undocumented)
    viewPoint: Point3d;
    // (undocumented)
    viewport?: ScreenViewport;
    // (undocumented)
    readonly wasMotion: boolean;
}

// @internal (undocumented)
export enum CurrentState {
    // (undocumented)
    Active = 3,
    // (undocumented)
    Deactivated = 1,
    // (undocumented)
    Inactive = 2,
    // (undocumented)
    NotEnabled = 0
}

// @alpha
export interface CustomFormattedNumberParams extends BasePropertyEditorParams {
    // (undocumented)
    formatFunction: (numberValue: number, quantityType?: QuantityType | string) => string;
    // (undocumented)
    parseFunction: (stringValue: string, quantityType?: QuantityType | string) => ParseResults;
    // (undocumented)
    type: PropertyEditorParamTypes.CustomFormattedNumber;
}

// @public
export class DecorateContext extends RenderContext {
    // @internal
    constructor(vp: ScreenViewport, _decorations: Decorations);
    addCanvasDecoration(decoration: CanvasDecoration, atFront?: boolean): void;
    addDecoration(type: GraphicType, decoration: RenderGraphic): void;
    addDecorationFromBuilder(builder: GraphicBuilder): void;
    addHtmlDecoration(decoration: HTMLElement): void;
    createGraphicBuilder(type: GraphicType, transform?: Transform, id?: Id64String): GraphicBuilder;
    decorationDiv: HTMLDivElement;
    // @internal (undocumented)
    static drawGrid(graphic: GraphicBuilder, doIsogrid: boolean, drawDots: boolean, gridOrigin: Point3d, xVec: Vector3d, yVec: Vector3d, gridsPerRef: number, repetitions: Point2d, vp: Viewport): void;
    // @internal (undocumented)
    drawStandardGrid(gridOrigin: Point3d, rMatrix: Matrix3d, spacing: XAndY, gridsPerRef: number, isoGrid?: boolean, fixedRepetitions?: Point2d): void;
    // @internal (undocumented)
    static getGridDimension(props: {
        nRepetitions: number;
        min: number;
    }, gridSize: number, org: Point3d, dir: Point3d, points: Point3d[]): boolean;
    // @internal (undocumented)
    static getGridPlaneViewIntersections(planePoint: Point3d, planeNormal: Vector3d, vp: Viewport, useProjectExtents: boolean): Point3d[];
    readonly screenViewport: ScreenViewport;
    setSkyBox(graphic: RenderGraphic): void;
    setViewBackground(graphic: RenderGraphic): void;
}

// @alpha
export class DecorationAnimator implements ViewportAnimator {
    constructor(duration: BeDuration);
    // (undocumented)
    animate(vp: Viewport): RemoveMe;
    animateDecorations(_viewport: Viewport, _durationPercent: number): RemoveMe;
    // (undocumented)
    onInterrupted(vp: Viewport): void;
    }

// @public
export class Decorations implements IDisposable {
    // (undocumented)
    canvasDecorations?: CanvasDecorationList;
    // (undocumented)
    dispose(): void;
    normal: GraphicList | undefined;
    skyBox: RenderGraphic | undefined;
    viewBackground: RenderGraphic | undefined;
    viewOverlay: GraphicList | undefined;
    world: GraphicList | undefined;
    worldOverlay: GraphicList | undefined;
    }

// @public
export interface Decorator {
    decorate(context: DecorateContext): void;
    getDecorationGeometry?(hit: HitDetail): GeometryStreamProps | undefined;
    getDecorationToolTip?(hit: HitDetail): Promise<HTMLElement | string>;
    onDecorationButtonEvent?(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    testDecorationHit?(id: string): boolean;
}

// @internal (undocumented)
export class DefaultViewTouchTool extends ViewManip {
    constructor(startEv: BeTouchEvent, _ev: BeTouchEvent);
    // (undocumented)
    onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onStart(ev: BeTouchEvent): void;
    // (undocumented)
    onTouchCancel(_ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(_ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    static toolId: string;
}

// @public
export interface DepthRangeNpc {
    maximum: number;
    minimum: number;
}

// @internal
export class DevTools {
    static connectToBackendInstance(iModelToken: IModelToken): DevTools;
    ping(count: number): Promise<PingTestResult>;
    setLogLevel(inLoggerCategory: string, newLevel: LogLevel): Promise<LogLevel | undefined>;
    stats(options?: DevToolsStatsOptions): Promise<any>;
    // (undocumented)
    versions(): Promise<any>;
}

// @public
export class DisplayStyle2dState extends DisplayStyleState {
    constructor(props: DisplayStyleProps, iModel: IModelConnection);
    // @internal (undocumented)
    static readonly className: string;
    // (undocumented)
    readonly settings: DisplayStyleSettings;
    }

// @public
export class DisplayStyle3dState extends DisplayStyleState {
    constructor(props: DisplayStyleProps, iModel: IModelConnection);
    // @internal (undocumented)
    static readonly className: string;
    // @internal (undocumented)
    clone(iModel: IModelConnection): this;
    environment: Environment;
    // @internal
    loadSkyBoxParams(system: RenderSystem, vp?: Viewport): SkyBox.CreateParams | undefined;
    // @beta
    setSunTime(time: number): void;
    // (undocumented)
    readonly settings: DisplayStyle3dSettings;
    // @beta (undocumented)
    readonly sunDirection: Vector3d | undefined;
    }

// @public
export abstract class DisplayStyleState extends ElementState implements DisplayStyleProps {
    constructor(props: DisplayStyleProps, iModel: IModelConnection);
    // @internal (undocumented)
    addContextRealityModel(contextRealityModel: ContextRealityModelProps, iModel: IModelConnection): void;
    analysisStyle: AnalysisStyle | undefined;
    backgroundColor: ColorDef;
    // @internal (undocumented)
    readonly backgroundMap: BackgroundMapProvider;
    // @internal (undocumented)
    readonly backgroundMapPlane: Plane3dByOriginAndUnitNormal | undefined;
    // @internal (undocumented)
    static readonly className: string;
    // @internal (undocumented)
    containsContextRealityModel(contextRealityModel: ContextRealityModelState): boolean;
    // @internal (undocumented)
    contextRealityModels: ContextRealityModelState[];
    dropSubCategoryOverride(id: Id64String): void;
    equalState(other: DisplayStyleState): boolean;
    // @internal (undocumented)
    forEachContextRealityModel(func: (model: TileTreeModelState) => void): void;
    // @internal (undocumented)
    getAnimationBranches(scheduleTime: number): AnimationBranchStates | undefined;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    readonly hasSubCategoryOverride: boolean;
    is3d(): this is DisplayStyle3dState;
    // @internal (undocumented)
    loadContextRealityModels(): Promise<void>;
    monochromeColor: ColorDef;
    readonly name: string;
    overrideSubCategory(id: Id64String, ovr: SubCategoryOverride): void;
    // @internal (undocumented)
    removeContextRealityModel(index: number): void;
    // @internal (undocumented)
    readonly scheduleScript: RenderScheduleState.Script | undefined;
    // @alpha
    setBackgroundMap(mapProps: BackgroundMapProps): void;
    abstract readonly settings: DisplayStyleSettings;
    viewFlags: ViewFlags;
}

// @public
export class DrawingModelState extends GeometricModel2dState {
    // @internal (undocumented)
    static readonly className: string;
}

// @public
export class DrawingViewState extends ViewState2d {
    // @internal (undocumented)
    static readonly className: string;
    // (undocumented)
    static createFromProps(props: ViewStateProps, iModel: IModelConnection): ViewState | undefined;
    // (undocumented)
    readonly defaultExtentLimits: ExtentLimits;
    }

// @public
export class DynamicsContext extends RenderContext {
    addGraphic(graphic: RenderGraphic): void;
    // @internal (undocumented)
    changeDynamics(): void;
    }

// @alpha
export namespace EditManipulator {
    // (undocumented)
    export enum EventType {
        // (undocumented)
        Accept = 2,
        // (undocumented)
        Cancel = 1,
        // (undocumented)
        Synch = 0
    }
    // (undocumented)
    export abstract class HandleProvider {
        constructor(iModel: IModelConnection);
        // (undocumented)
        protected clearControls(): void;
        protected abstract createControls(): Promise<boolean>;
        // (undocumented)
        decorate(_context: DecorateContext): void;
        // (undocumented)
        iModel: IModelConnection;
        // (undocumented)
        protected _isActive: boolean;
        protected abstract modifyControls(_hit: HitDetail, _ev: BeButtonEvent): boolean;
        // (undocumented)
        onDecorationButtonEvent(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        protected onDoubleClick(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onManipulatorEvent(_eventType: EventType): void;
        // (undocumented)
        onManipulatorToolEvent(_tool: Tool, event: ManipulatorToolEvent): void;
        // (undocumented)
        protected onRightClick(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onSelectionChanged(ev: SelectionSetEvent): void;
        // (undocumented)
        protected onTouchTap(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        protected _removeDecorationListener?: () => void;
        // (undocumented)
        protected _removeManipulatorToolListener?: () => void;
        // (undocumented)
        protected _removeSelectionListener?: () => void;
        // (undocumented)
        protected stop(): void;
        // (undocumented)
        protected updateControls(): Promise<void>;
        // (undocumented)
        protected updateDecorationListener(add: boolean): void;
    }
    // (undocumented)
    export abstract class HandleTool extends InputCollector {
        constructor(manipulator: HandleProvider);
        // (undocumented)
        protected abstract accept(_ev: BeButtonEvent): boolean;
        // (undocumented)
        protected cancel(_ev: BeButtonEvent): boolean;
        // (undocumented)
        static hidden: boolean;
        protected init(): void;
        // (undocumented)
        manipulator: HandleProvider;
        // (undocumented)
        onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onPostInstall(): void;
        // (undocumented)
        onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
        // (undocumented)
        onTouchCancel(ev: BeTouchEvent): Promise<void>;
        // (undocumented)
        onTouchComplete(ev: BeTouchEvent): Promise<void>;
        // (undocumented)
        onTouchMove(ev: BeTouchEvent): Promise<void>;
        // (undocumented)
        static toolId: string;
    }
    // (undocumented)
    export class HandleUtils {
        static getArrowShape(baseStart?: number, baseWidth?: number, tipStart?: number, tipEnd?: number, tipWidth?: number, flangeStart?: number, flangeWidth?: number): Point3d[];
        static getArrowTransform(vp: Viewport, base: Point3d, direction: Vector3d, sizeInches: number): Transform | undefined;
        // (undocumented)
        static getBoresite(origin: Point3d, vp: Viewport, checkAccuDraw?: boolean, checkACS?: boolean): Ray3d;
        // (undocumented)
        static projectPointToLineInView(spacePt: Point3d, linePt: Point3d, lineDirection: Vector3d, vp: Viewport, checkAccuDraw?: boolean, checkACS?: boolean): Point3d | undefined;
        // (undocumented)
        static projectPointToPlaneInView(spacePt: Point3d, planePt: Point3d, planeNormal: Vector3d, vp: Viewport, checkAccuDraw?: boolean, checkACS?: boolean): Point3d | undefined;
    }
}

// @beta
export interface EditorPosition {
    columnIndex: number;
    columnSpan?: number;
    rowPriority: number;
}

// @internal (undocumented)
export class ElementAgenda {
    constructor(iModel: IModelConnection);
    add(arg: Id64Arg): boolean;
    clear(): void;
    // (undocumented)
    readonly count: number;
    // (undocumented)
    readonly elements: string[];
    find(id: Id64String): boolean;
    getSource(): ModifyElementSource.Unknown | ModifyElementSource;
    // (undocumented)
    readonly groupMarks: GroupMark[];
    // (undocumented)
    has(id: string): boolean;
    hilite(): void;
    // (undocumented)
    hilitedState: HilitedState;
    hiliteOnAdd: boolean;
    // (undocumented)
    iModel: IModelConnection;
    invert(arg: Id64Arg): boolean;
    // (undocumented)
    readonly isEmpty: boolean;
    // (undocumented)
    readonly length: number;
    popGroup(): void;
    // (undocumented)
    remove(arg: Id64Arg): boolean;
    setSource(val: ModifyElementSource): void;
}

// @public (undocumented)
export class ElementLocateManager {
    // (undocumented)
    readonly apertureInches: number;
    // (undocumented)
    clear(): void;
    // (undocumented)
    currHit?: HitDetail;
    // (undocumented)
    doLocate(response: LocateResponse, newSearch: boolean, testPoint: Point3d, view: ScreenViewport | undefined, source: InputSource, filterHits?: boolean): Promise<HitDetail | undefined>;
    // (undocumented)
    filterHit(hit: HitDetail, _action: LocateAction, out: LocateResponse): Promise<LocateFilterStatus>;
    static getFailureMessageKey(key: string): string;
    // (undocumented)
    getNextHit(): HitDetail | undefined;
    getPreLocatedHit(): HitDetail | undefined;
    // (undocumented)
    hitList?: HitList<HitDetail>;
    // (undocumented)
    initLocateOptions(): void;
    // (undocumented)
    initToolLocate(): void;
    // (undocumented)
    onInitialized(): void;
    // (undocumented)
    readonly options: LocateOptions;
    // (undocumented)
    readonly picker: ElementPicker;
    // (undocumented)
    setCurrHit(hit?: HitDetail): void;
    // (undocumented)
    setHitList(list?: HitList<HitDetail>): void;
    // (undocumented)
    readonly touchApertureInches: number;
}

// @public (undocumented)
export class ElementPicker {
    doPick(vp: ScreenViewport, pickPointWorld: Point3d, pickRadiusView: number, options: LocateOptions): number;
    // (undocumented)
    empty(): void;
    getHit(i: number): HitDetail | undefined;
    getHitList(takeOwnership: boolean): HitList<HitDetail>;
    // (undocumented)
    getNextHit(): HitDetail | undefined;
    // (undocumented)
    hitList?: HitList<HitDetail>;
    // (undocumented)
    readonly pickPointWorld: Point3d;
    // (undocumented)
    resetCurrentHit(): void;
    // (undocumented)
    testHit(hit: HitDetail, vp: ScreenViewport, pickPointWorld: Point3d, pickRadiusView: number, options: LocateOptions): boolean;
    // (undocumented)
    viewport?: Viewport;
}

// @public
export class ElementState extends EntityState implements ElementProps {
    constructor(props: ElementProps, iModel: IModelConnection);
    // @internal (undocumented)
    static readonly className: string;
    readonly code: Code;
    readonly federationGuid?: GuidString;
    readonly model: Id64String;
    readonly parent?: RelatedElement;
    // @internal (undocumented)
    toJSON(): ElementProps;
    readonly userLabel?: string;
}

// @internal
export enum ElemMethod {
    Add = 0,
    Invert = 1
}

// @internal
export enum ElemSource {
    Fence = 1,
    Pick = 0,
    SelectionSet = 2
}

// @internal
export class EmphasizeElements implements FeatureOverrideProvider {
    addFeatureOverrides(overrides: FeatureSymbology.Overrides, vp: Viewport): void;
    static clear(vp: Viewport, inactiveOnly?: boolean): void;
    clearAlwaysDrawnElements(vp: Viewport): boolean;
    clearEmphasizedElements(vp: Viewport): boolean;
    clearEmphasizedIsolatedElements(vp: Viewport, setToAlwaysDrawn: boolean): boolean;
    clearHiddenElements(vp: Viewport): boolean;
    clearIsolatedElements(vp: Viewport): boolean;
    clearNeverDrawnElements(vp: Viewport): boolean;
    clearOverriddenElements(vp: Viewport, key?: number): boolean;
    // (undocumented)
    protected createAppearanceFromKey(key: number): FeatureSymbology.Appearance;
    createDefaultAppearance(): FeatureSymbology.Appearance;
    createOverrideKey(color: ColorDef, override: FeatureOverrideType): number | undefined;
    defaultAppearance: FeatureSymbology.Appearance | undefined;
    emphasizeElements(ids: Id64Arg, vp: Viewport, defaultAppearance?: FeatureSymbology.Appearance, replace?: boolean): boolean;
    emphasizeSelectedElements(vp: Viewport, defaultAppearance?: FeatureSymbology.Appearance, replace?: boolean, clearSelection?: boolean): boolean;
    // (undocumented)
    fromJSON(props: EmphasizeElementsProps, vp: Viewport): boolean;
    static get(vp: Viewport): EmphasizeElements | undefined;
    getAlwaysDrawnElements(vp: Viewport): Id64Set | undefined;
    getEmphasizedElements(vp: Viewport): Id64Set | undefined;
    getEmphasizedIsolatedElements(): Id64Set | undefined;
    getHiddenElements(vp: Viewport): Id64Set | undefined;
    getIsolatedElements(vp: Viewport): Id64Set | undefined;
    getNeverDrawnElements(vp: Viewport): Id64Set | undefined;
    static getOrCreate(vp: Viewport): EmphasizeElements;
    getOverriddenElements(): Map<number, Id64Set> | undefined;
    getOverriddenElementsByKey(key: number): Id64Set | undefined;
    getOverrideFromKey(key: number, color: ColorDef): FeatureOverrideType;
    hideElements(ids: Id64Arg, vp: Viewport, replace?: boolean): boolean;
    hideSelectedElements(vp: Viewport, replace?: boolean, clearSelection?: boolean): boolean;
    isActive(vp: Viewport): boolean;
    isolateElements(ids: Id64Arg, vp: Viewport, replace?: boolean): boolean;
    isolateSelectedElements(vp: Viewport, replace?: boolean, clearSelection?: boolean): boolean;
    overrideElements(ids: Id64Arg, vp: Viewport, color: ColorDef, override?: FeatureOverrideType, replace?: boolean): boolean;
    overrideSelectedElements(vp: Viewport, color: ColorDef, override?: FeatureOverrideType, replace?: boolean, clearSelection?: boolean): boolean;
    setAlwaysDrawnElements(ids: Id64Arg, vp: Viewport, exclusive?: boolean, replace?: boolean): boolean;
    setNeverDrawnElements(ids: Id64Arg, vp: Viewport, replace?: boolean): boolean;
    // (undocumented)
    toJSON(vp: Viewport): EmphasizeElementsProps;
    // (undocumented)
    protected updateIdSet(ids: Id64Arg, replace: boolean, existingIds?: Id64Set): Id64Set | undefined;
}

// @internal (undocumented)
export interface EmphasizeElementsProps {
    // (undocumented)
    alwaysDrawn?: Id64Set;
    // (undocumented)
    alwaysDrawnExclusiveEmphasized?: Id64Set;
    // (undocumented)
    appearanceOverride?: AppearanceOverrideProps[];
    // (undocumented)
    defaultAppearance?: FeatureSymbology.AppearanceProps;
    // (undocumented)
    isAlwaysDrawnExclusive?: boolean;
    // (undocumented)
    neverDrawn?: Id64Set;
}

// @public
export class EntityState implements EntityProps {
    constructor(props: EntityProps, iModel: IModelConnection, _state?: EntityState);
    readonly classFullName: string;
    static readonly classFullName: string;
    readonly className: string;
    static readonly className: string;
    clone(iModel?: IModelConnection): this;
    equals(other: this): boolean;
    readonly id: Id64String;
    readonly iModel: IModelConnection;
    readonly jsonProperties: {
        [key: string]: any;
    };
    static readonly schemaName: string;
    // @internal (undocumented)
    toJSON(): EntityProps;
}

// @beta
export interface EnumerationChoice {
    // (undocumented)
    label: string;
    // (undocumented)
    value: string | number;
}

// @beta
export interface EnumerationChoicesInfo {
    // (undocumented)
    choices: EnumerationChoice[];
    // (undocumented)
    isStrict?: boolean;
    // (undocumented)
    maxDisplayedRows?: number;
}

// @public
export class Environment implements EnvironmentProps {
    constructor(json?: EnvironmentProps);
    // (undocumented)
    readonly ground: GroundPlane;
    // (undocumented)
    readonly sky: SkyBox;
    // (undocumented)
    toJSON(): EnvironmentProps;
}

// @internal
export enum ErrorNums {
    NoFence = 0,
    NoFenceElems = 1,
    NoFenceElemsOutside = 2,
    NoSSElems = 3,
    NotSupportedElmType = 4
}

// @public
export class EventController {
    constructor(vp: ScreenViewport);
    // (undocumented)
    destroy(): void;
    // (undocumented)
    vp: ScreenViewport;
}

// @public (undocumented)
export enum EventHandled {
    // (undocumented)
    No = 0,
    // (undocumented)
    Yes = 1
}

// @public
export interface ExtentLimits {
    max: number;
    min: number;
}

// @public
export function extractImageSourceDimensions(source: ImageSource): Promise<Point2d>;

// @public
export interface FeatureOverrideProvider {
    addFeatureOverrides(overrides: FeatureSymbology.Overrides, viewport: Viewport): void;
}

// @internal
export enum FeatureOverrideType {
    // (undocumented)
    AlphaOnly = 1,
    // (undocumented)
    ColorAndAlpha = 2,
    // (undocumented)
    ColorOnly = 0
}

// @public
export namespace FeatureSymbology {
    export class Appearance implements AppearanceProps {
        static readonly defaults: Appearance;
        // (undocumented)
        equals(other: Appearance): boolean;
        extendAppearance(base: Appearance): Appearance;
        // (undocumented)
        static fromJSON(props?: AppearanceProps): Appearance;
        static fromRgb(color: ColorDef): Appearance;
        static fromRgba(color: ColorDef): Appearance;
        static fromSubCategoryOverride(ovr: SubCategoryOverride): Appearance;
        static fromTransparency(transparencyValue: number): Appearance;
        readonly ignoresMaterial?: true | undefined;
        // (undocumented)
        readonly isFullyTransparent: boolean;
        readonly linePixels?: LinePixels;
        readonly nonLocatable?: true | undefined;
        // (undocumented)
        readonly overridesLinePixels: boolean;
        // (undocumented)
        readonly overridesRgb: boolean;
        // (undocumented)
        readonly overridesSymbology: boolean;
        // (undocumented)
        readonly overridesTransparency: boolean;
        // (undocumented)
        readonly overridesWeight: boolean;
        readonly rgb?: RgbColor;
        // (undocumented)
        toJSON(): AppearanceProps;
        readonly transparency?: number;
        readonly weight?: number;
    }
    export interface AppearanceProps {
        ignoresMaterial?: true | undefined;
        linePixels?: LinePixels;
        nonLocatable?: true | undefined;
        rgb?: RgbColor;
        transparency?: number;
        weight?: number;
    }
    export class Overrides {
        constructor(view?: ViewState | Viewport);
        // @internal
        protected readonly _alwaysDrawn: Id64.Uint32Set;
        // @internal
        readonly animationNodeOverrides: Map<number, Appearance>;
        // @internal
        protected _constructions: boolean;
        readonly defaultOverrides: Appearance;
        // @internal
        protected _defaultOverrides: Appearance;
        // @internal
        protected _dimensions: boolean;
        // @internal
        protected readonly _elementOverrides: Id64.Uint32Map<Appearance>;
        // @internal
        getAppearance(elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, geomClass: GeometryClass, modelLo: number, modelHi: number, type: BatchType, animationNodeId: number): Appearance | undefined;
        // @internal
        protected getClassifierAppearance(elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, modelLo: number, modelHi: number): Appearance | undefined;
        // @internal (undocumented)
        protected getElementOverrides(idLo: number, idHi: number, animationNodeId: number): Appearance | undefined;
        getElementOverridesById(id: Id64String): Appearance | undefined;
        getFeatureAppearance(feature: Feature, modelId: Id64String, type?: BatchType): Appearance | undefined;
        // @internal (undocumented)
        protected getModelOverrides(idLo: number, idHi: number): Appearance | undefined;
        getModelOverridesById(id: Id64String): Appearance | undefined;
        // @internal (undocumented)
        protected getSubCategoryOverrides(idLo: number, idHi: number): Appearance | undefined;
        getSubCategoryOverridesById(id: Id64String): Appearance | undefined;
        // @internal
        initFromView(view: ViewState): void;
        // @internal
        initFromViewport(viewport: Viewport): void;
        // @internal (undocumented)
        protected isAlwaysDrawn(idLo: number, idHi: number): boolean;
        isAlwaysDrawnExclusive: boolean;
        // @internal (undocumented)
        isClassVisible(geomClass: GeometryClass): boolean;
        isFeatureVisible(feature: Feature): boolean;
        // @internal (undocumented)
        protected isNeverDrawn(elemIdLo: number, elemIdHi: number, animationNodeId: number): boolean;
        isSubCategoryIdVisible(id: Id64String): boolean;
        // @internal
        isSubCategoryVisible(idLo: number, idHi: number): boolean;
        // @internal (undocumented)
        isSubCategoryVisibleInModel(subcatLo: number, subcatHi: number, modelLo: number, modelHi: number): boolean;
        readonly lineWeights: boolean;
        // @internal
        protected _lineWeights: boolean;
        // @internal
        protected readonly _modelOverrides: Id64.Uint32Map<Appearance>;
        // @internal
        protected readonly _modelSubCategoryOverrides: Id64.Uint32Map<Id64.Uint32Set>;
        // @internal
        protected readonly _neverDrawn: Id64.Uint32Set;
        // @internal
        readonly neverDrawnAnimationNodes: Set<number>;
        overrideAnimationNode(id: number, app: Appearance): void;
        overrideElement(id: Id64String, app: Appearance, replaceExisting?: boolean): void;
        overrideModel(id: Id64String, app: Appearance, replaceExisting?: boolean): void;
        overrideSubCategory(id: Id64String, app: Appearance, replaceExisting?: boolean): void;
        // @internal
        protected _patterns: boolean;
        setAlwaysDrawn(id: Id64String): void;
        setAlwaysDrawnSet(ids: Id64Set, exclusive: boolean): void;
        setAnimationNodeNeverDrawn(id: number): void;
        setDefaultOverrides(appearance: Appearance, replaceExisting?: boolean): void;
        setNeverDrawn(id: Id64String): void;
        setNeverDrawnSet(ids: Id64Set): void;
        setVisibleSubCategory(id: Id64String): void;
        // @internal
        protected readonly _subCategoryOverrides: Id64.Uint32Map<Appearance>;
        // @internal
        protected readonly _visibleSubCategories: Id64.Uint32Set;
        }
}

// @public
export class FitViewTool extends ViewTool {
    constructor(viewport: ScreenViewport, oneShot: boolean, doAnimate?: boolean, isolatedOnly?: boolean);
    // (undocumented)
    doAnimate: boolean;
    // (undocumented)
    doFit(viewport: ScreenViewport, oneShot: boolean, doAnimate?: boolean, isolatedOnly?: boolean): Promise<boolean>;
    // (undocumented)
    isolatedOnly: boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export class Flags {
    // (undocumented)
    animateRotation: boolean;
    // (undocumented)
    auxRotationPlane: RotationMode;
    // (undocumented)
    baseMode: number;
    // (undocumented)
    baseRotation: RotationMode;
    // (undocumented)
    bearingFixToPlane2D: boolean;
    // (undocumented)
    contextRotMode: number;
    // (undocumented)
    dialogNeedsUpdate: boolean;
    // (undocumented)
    fixedOrg: boolean;
    // (undocumented)
    haveValidOrigin: boolean;
    // (undocumented)
    ignoreDataButton: boolean;
    // (undocumented)
    inDataPoint: boolean;
    // (undocumented)
    indexLocked: boolean;
    // (undocumented)
    lockedRotation: boolean;
    // (undocumented)
    pointIsOnPlane: boolean;
    // (undocumented)
    redrawCompass: boolean;
    // (undocumented)
    rotationNeedsUpdate: boolean;
    // (undocumented)
    softAngleLock: boolean;
}

// @public
export class FlyViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export function fromSumOf(p: Point3d, v: Vector3d, scale: number, out?: Point3d): Point3d;

// @public
export enum FrontendLoggerCategory {
    FrontendRequestContext = "imodeljs-frontend.FrontendRequestContext",
    IModelConnection = "imodeljs-frontend.IModelConnection",
    OidcBrowserClient = "imodeljs-frontend.OidcBrowserClient",
    OidcIOSClient = "imodeljs-frontend.OidcIOSClient",
    // (undocumented)
    Package = "imodeljs-frontend"
}

// @public
export class FrontendRequestContext extends ClientRequestContext {
    constructor(activityId?: string);
}

// @internal
export class FrustumUniforms {
    constructor();
    // (undocumented)
    readonly farPlane: number;
    // (undocumented)
    readonly frustum: Float32Array;
    // (undocumented)
    readonly frustumPlanes: Float32Array;
    // (undocumented)
    readonly is2d: boolean;
    // (undocumented)
    readonly nearPlane: number;
    // (undocumented)
    setFrustum(nearPlane: number, farPlane: number, type: FrustumUniformType): void;
    // (undocumented)
    setPlanes(top: number, bottom: number, left: number, right: number): void;
    // (undocumented)
    readonly type: FrustumUniformType;
}

// @internal (undocumented)
export const enum FrustumUniformType {
    // (undocumented)
    Orthographic = 1,
    // (undocumented)
    Perspective = 2,
    // (undocumented)
    TwoDee = 0
}

// @public (undocumented)
export class FuzzySearch<T> {
    onGetMultiWordSearchOptions(): Fuse.FuseOptions<T>;
    onGetSingleWordSearchOptions(): Fuse.FuseOptions<T>;
    search(searchedObjects: T[], keys: Array<keyof T>, pattern: string): FuzzySearchResults<T>;
}

// @public
export interface FuzzySearchResult<T> {
    getBoldMask(): boolean[];
    getMatchedKey(): string;
    getMatchedValue(): string;
    getResult(): T;
}

// @public
export class FuzzySearchResults<T> implements Iterable<T> {
    // (undocumented)
    [Symbol.iterator](): any;
    constructor(results: any[] | undefined);
    // (undocumented)
    getResult(resultIndex: number): FuzzySearchResult<T> | undefined;
    // (undocumented)
    readonly length: number;
    // (undocumented)
    results: any[];
}

// @internal
export class GeoConverter {
    constructor(iModel: IModelConnection, datum: string);
    // (undocumented)
    getCachedIModelCoordinatesFromGeoCoordinates(geoPoints: XYZProps[]): CachedIModelCoordinatesResponseProps;
    // (undocumented)
    getGeoCoordinatesFromIModelCoordinates(iModelPoints: XYZProps[]): Promise<GeoCoordinatesResponseProps>;
    // (undocumented)
    getIModelCoordinatesFromGeoCoordinates(geoPoints: XYZProps[]): Promise<IModelCoordinatesResponseProps>;
    }

// @public
export class GeometricModel2dState extends GeometricModelState implements GeometricModel2dProps {
    constructor(props: GeometricModel2dProps, iModel: IModelConnection);
    // @internal (undocumented)
    readonly asGeometricModel2d: GeometricModel2dState;
    // @internal (undocumented)
    static readonly className: string;
    // @internal (undocumented)
    readonly globalOrigin: Point2d;
    // @internal (undocumented)
    readonly is3d: boolean;
    // (undocumented)
    toJSON(): GeometricModel2dProps;
}

// @public
export class GeometricModel3dState extends GeometricModelState {
    // @internal (undocumented)
    readonly asGeometricModel3d: GeometricModel3dState;
    // @internal (undocumented)
    static readonly className: string;
    // @internal (undocumented)
    readonly is3d: boolean;
}

// @public
export abstract class GeometricModelState extends ModelState {
    // @internal (undocumented)
    readonly asGeometricModel: GeometricModelState;
    // @internal (undocumented)
    readonly classifierTileTree: TileTree | undefined;
    // @internal (undocumented)
    protected _classifierTileTreeState: TileTreeState;
    // @internal (undocumented)
    static readonly className: string;
    readonly is2d: boolean;
    abstract readonly is3d: boolean;
    // @internal (undocumented)
    readonly isGeometricModel: boolean;
    // @internal (undocumented)
    loadClassifierTileTree(type: BatchType.PlanarClassifier | BatchType.VolumeClassifier, expansion: number): TileTree.LoadStatus;
    // @internal (undocumented)
    loadStatus: TileTree.LoadStatus;
    // @internal (undocumented)
    loadTileTree(treeId: IModelTile.TreeId): TileTree.LoadStatus;
    // @internal (undocumented)
    loadTree(edgesRequired: boolean, animationId?: Id64String): TileTree.LoadStatus;
    // @internal (undocumented)
    onIModelConnectionClose(): void;
    queryModelRange(): Promise<Range3d>;
    // @internal (undocumented)
    readonly tileTree: TileTree | undefined;
    // @internal (undocumented)
    protected _tileTreeState: TileTreeState;
    // @internal (undocumented)
    readonly treeModelId: Id64String;
}

// @internal
export class GeoServices {
    constructor(iModel: IModelConnection);
    // (undocumented)
    getConverter(datum?: string): GeoConverter;
    }

// @public
export function getImageSourceFormatForMimeType(mimeType: string): ImageSourceFormat | undefined;

// @public
export function getImageSourceMimeType(format: ImageSourceFormat): string;

// @public
export class GraphicBranch implements IDisposable {
    constructor(ownsEntries?: boolean);
    add(graphic: RenderGraphic): void;
    // @internal
    animationId?: string;
    clear(): void;
    // @internal (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    dispose(): void;
    readonly entries: RenderGraphic[];
    // @internal (undocumented)
    getViewFlags(flags: ViewFlags, out?: ViewFlags): ViewFlags;
    // (undocumented)
    readonly isEmpty: boolean;
    readonly ownsEntries: boolean;
    // @internal (undocumented)
    setViewFlagOverrides(ovr: ViewFlag.Overrides): void;
    // @internal (undocumented)
    setViewFlags(flags: ViewFlags): void;
    symbologyOverrides?: FeatureSymbology.Overrides;
    }

// @public
export abstract class GraphicBuilder {
    // @internal
    protected constructor(placement: Transform | undefined, type: GraphicType, viewport: Viewport, pickId?: Id64String);
    abstract activateGraphicParams(graphicParams: GraphicParams): void;
    abstract addArc(arc: Arc3d, isEllipse: boolean, filled: boolean): void;
    abstract addArc2d(ellipse: Arc3d, isEllipse: boolean, filled: boolean, zDepth: number): void;
    abstract addLineString(points: Point3d[]): void;
    abstract addLineString2d(points: Point2d[], zDepth: number): void;
    abstract addLoop(loop: Loop): void;
    abstract addPath(path: Path): void;
    abstract addPointString(points: Point3d[]): void;
    abstract addPointString2d(points: Point2d[], zDepth: number): void;
    abstract addPolyface(meshData: Polyface, filled: boolean): void;
    addRangeBox(range: Range3d): void;
    abstract addShape(points: Point3d[]): void;
    abstract addShape2d(points: Point2d[], zDepth: number): void;
    abstract finish(): RenderGraphic;
    // @internal (undocumented)
    readonly iModel: IModelConnection;
    // @internal (undocumented)
    readonly isOverlay: boolean;
    // @internal (undocumented)
    readonly isSceneGraphic: boolean;
    // @internal (undocumented)
    readonly isViewBackground: boolean;
    // @internal (undocumented)
    readonly isViewCoordinates: boolean;
    // @internal (undocumented)
    readonly isWorldCoordinates: boolean;
    // (undocumented)
    pickId?: string;
    placement: Transform;
    // @internal
    setBlankingFill(fillColor: ColorDef): void;
    setSymbology(lineColor: ColorDef, fillColor: ColorDef, lineWidth: number, linePixels?: LinePixels): void;
    readonly type: GraphicType;
    readonly viewport: Viewport;
}

// @public
export type GraphicList = RenderGraphic[];

// @public
export enum GraphicType {
    Scene = 1,
    ViewBackground = 0,
    ViewOverlay = 4,
    WorldDecoration = 2,
    WorldOverlay = 3
}

// @public
export enum GridOrientationType {
    AuxCoord = 4,
    View = 0,
    WorldXY = 1,
    WorldXZ = 3,
    WorldYZ = 2
}

// @internal (undocumented)
export interface GroupMark {
    // (undocumented)
    source: ModifyElementSource;
    // (undocumented)
    start: number;
}

// @internal (undocumented)
export enum HilitedState {
    No = 2,
    Unknown = 0,
    Yes = 1
}

// @internal (undocumented)
export interface Hilites {
    // (undocumented)
    readonly elements: Id64.Uint32Set;
    // (undocumented)
    readonly isEmpty: boolean;
    // (undocumented)
    readonly models: Id64.Uint32Set;
    // (undocumented)
    readonly subcategories: Id64.Uint32Set;
}

// @alpha
export class HiliteSet {
    constructor(iModel: IModelConnection, syncWithSelectionSet?: boolean);
    clear(): void;
    // (undocumented)
    readonly elements: Id64.Uint32Set;
    // (undocumented)
    iModel: IModelConnection;
    // (undocumented)
    readonly isEmpty: boolean;
    // (undocumented)
    readonly models: Id64.Uint32Set;
    setHilite(arg: Id64Arg, onOff: boolean): void;
    // (undocumented)
    readonly subcategories: Id64.Uint32Set;
    wantSyncWithSelectionSet: boolean;
}

// @public
export class HitDetail {
    constructor(testPoint: Point3d, viewport: ScreenViewport, hitSource: HitSource, hitPoint: Point3d, sourceId: string, priority: HitPriority, distXY: number, distFraction: number, subCategoryId?: string | undefined, geometryClass?: GeometryClass | undefined);
    clone(): HitDetail;
    // (undocumented)
    readonly distFraction: number;
    // (undocumented)
    readonly distXY: number;
    draw(_context: DecorateContext): void;
    // (undocumented)
    readonly geometryClass?: GeometryClass | undefined;
    getHitType(): HitDetailType;
    getPoint(): Point3d;
    getToolTip(): Promise<HTMLElement | string>;
    // (undocumented)
    readonly hitPoint: Point3d;
    // (undocumented)
    readonly hitSource: HitSource;
    readonly isElementHit: boolean;
    // (undocumented)
    readonly isModelHit: boolean;
    isSameHit(otherHit?: HitDetail): boolean;
    // (undocumented)
    readonly priority: HitPriority;
    // (undocumented)
    readonly sourceId: string;
    // (undocumented)
    readonly subCategoryId?: string | undefined;
    // (undocumented)
    readonly testPoint: Point3d;
    // (undocumented)
    readonly viewport: ScreenViewport;
}

// @public (undocumented)
export enum HitDetailType {
    // (undocumented)
    Hit = 1,
    // (undocumented)
    Intersection = 3,
    // (undocumented)
    Snap = 2
}

// @public
export enum HitGeomType {
    // (undocumented)
    Arc = 4,
    // (undocumented)
    Curve = 3,
    // (undocumented)
    None = 0,
    // (undocumented)
    Point = 1,
    // (undocumented)
    Segment = 2,
    // (undocumented)
    Surface = 5
}

// @public
export class HitList<T extends HitDetail> {
    addHit(newHit: T): number;
    compare(hit1: HitDetail | undefined, hit2: HitDetail | undefined): -1 | 1 | 0;
    // (undocumented)
    currHit: number;
    // (undocumented)
    dropNulls(): void;
    // (undocumented)
    empty(): void;
    // (undocumented)
    getCurrentHit(): T | undefined;
    getHit(hitNum: number): T | undefined;
    // (undocumented)
    getNextHit(): T | undefined;
    // (undocumented)
    hits: T[];
    insertHit(i: number, hit: T): void;
    // (undocumented)
    readonly length: number;
    removeCurrentHit(): void;
    removeHit(hitNum: number): void;
    removeHitsFrom(sourceId: string): boolean;
    // (undocumented)
    resetCurrentHit(): void;
    // (undocumented)
    setCurrentHit(hit: T): void;
    setHit(i: number, p: T | undefined): void;
}

// @public (undocumented)
export interface HitListHolder {
    // (undocumented)
    setHitList(list: HitList<HitDetail> | undefined): void;
}

// @public
export enum HitParentGeomType {
    // (undocumented)
    Mesh = 4,
    // (undocumented)
    None = 0,
    // (undocumented)
    Sheet = 2,
    // (undocumented)
    Solid = 3,
    // (undocumented)
    Text = 5,
    // (undocumented)
    Wire = 1
}

// @public (undocumented)
export enum HitPriority {
    // (undocumented)
    NonPlanarEdge = 2,
    // (undocumented)
    NonPlanarSurface = 5,
    // (undocumented)
    PlanarEdge = 1,
    // (undocumented)
    PlanarSurface = 4,
    // (undocumented)
    SilhouetteEdge = 3,
    // (undocumented)
    Unknown = 6,
    // (undocumented)
    WireEdge = 0
}

// @public
export enum HitSource {
    // (undocumented)
    AccuSnap = 3,
    // (undocumented)
    Application = 6,
    // (undocumented)
    DataPoint = 5,
    // (undocumented)
    EditAction = 7,
    // (undocumented)
    EditActionSS = 8,
    // (undocumented)
    FromUser = 1,
    // (undocumented)
    MotionLocate = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    TentativeSnap = 4
}

// @alpha
export interface IconDefinition {
    iconClass: string;
    // (undocumented)
    isEnabledFunction?: () => boolean;
}

// @alpha
export interface IconEditorParams extends BasePropertyEditorParams {
    // (undocumented)
    definition: IconDefinition;
    // (undocumented)
    type: PropertyEditorParamTypes.Icon;
}

// @public
export class IconSprites {
    static emptyAll(): void;
    static getSpriteFromUrl(spriteUrl: string): Sprite;
    }

// @public
export class IdleTool extends InteractiveTool {
    // (undocumented)
    exitTool(): void;
    // (undocumented)
    static hidden: boolean;
    // (undocumented)
    onMiddleButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseWheel(ev: BeWheelEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static toolId: string;
}

// @public
export function imageBufferToBase64EncodedPng(buffer: ImageBuffer): string | undefined;

// @public
export function imageBufferToPngDataUrl(buffer: ImageBuffer): string | undefined;

// @public
export function imageElementFromImageSource(source: ImageSource): Promise<HTMLImageElement>;

// @public
export function imageElementFromUrl(url: string): Promise<HTMLImageElement>;

// @internal (undocumented)
export abstract class ImageryProvider {
    constructor(mapType: BackgroundMapType);
    // (undocumented)
    abstract constructUrl(row: number, column: number, zoomLevel: number): string;
    // (undocumented)
    abstract getCopyrightImage(tileProvider: BaseTiledMapProvider): HTMLImageElement | undefined;
    // (undocumented)
    abstract getCopyrightMessage(tileProvider: BaseTiledMapProvider, viewport: ScreenViewport): HTMLElement | undefined;
    // (undocumented)
    abstract initialize(): Promise<void>;
    // (undocumented)
    loadTile(row: number, column: number, zoomLevel: number): Promise<ImageSource | undefined>;
    // (undocumented)
    mapType: BackgroundMapType;
    // (undocumented)
    matchesMissingTile(_tileData: Uint8Array): boolean;
    // (undocumented)
    abstract readonly maximumZoomLevel: number;
    // (undocumented)
    abstract readonly minimumZoomLevel: number;
    // (undocumented)
    protected _requestContext: ClientRequestContext;
    // (undocumented)
    abstract readonly tileHeight: number;
    // (undocumented)
    abstract readonly tileWidth: number;
}

// @internal (undocumented)
export abstract class ImageryProviderEPSG3857 extends ImageryProvider {
    // (undocumented)
    getEPSG3857Extent(row: number, column: number, zoomLevel: number): {
        left: number;
        right: number;
        top: number;
        bottom: number;
    };
    // (undocumented)
    getEPSG3857X(longitude: number): number;
    // (undocumented)
    getEPSG3857Y(latitude: number): number;
}

// @public
export class IModelApp {
    // @internal
    static readonly accuDraw: AccuDraw;
    static readonly accuSnap: AccuSnap;
    static readonly applicationId: string;
    static readonly applicationVersion: string;
    static authorizationClient?: IAuthorizationClient;
    // @internal (undocumented)
    static createRenderSys(opts?: RenderSystem.Options): RenderSystem;
    // @internal (undocumented)
    static readonly hasRenderSystem: boolean;
    static readonly i18n: I18N;
    static readonly iModelClient: IModelClient;
    // @internal (undocumented)
    static readonly initialized: boolean;
    // @internal (undocumented)
    static readonly locateManager: ElementLocateManager;
    // @internal (undocumented)
    static lookupEntityClass(classFullName: string): typeof EntityState | undefined;
    static readonly notifications: NotificationManager;
    // @alpha
    static readonly quantityFormatter: QuantityFormatter;
    // @beta
    static queryRenderCompatibility(): WebGLRenderCompatibilityInfo;
    // @internal
    static registerEntityState(classFullName: string, classType: typeof EntityState): void;
    // @internal
    static registerModuleEntities(moduleObj: any): void;
    static readonly renderSystem: RenderSystem;
    static sessionId: GuidString;
    static readonly settings: SettingsAdmin;
    static shutdown(): void;
    static startup(opts?: IModelAppOptions): void;
    // @internal (undocumented)
    static readonly tentativePoint: TentativePoint;
    // @internal (undocumented)
    static readonly terrainProvider: TerrainProvider | undefined;
    // @alpha
    static readonly tileAdmin: TileAdmin;
    static readonly toolAdmin: ToolAdmin;
    static readonly tools: ToolRegistry;
    static readonly viewManager: ViewManager;
    }

// @public
export interface IModelAppOptions {
    // @internal
    accuDraw?: AccuDraw;
    accuSnap?: AccuSnap;
    applicationId?: string;
    applicationVersion?: string;
    authorizationClient?: IAuthorizationClient;
    i18n?: I18N | I18NOptions;
    imodelClient?: IModelClient;
    // @internal (undocumented)
    locateManager?: ElementLocateManager;
    notifications?: NotificationManager;
    // @internal (undocumented)
    quantityFormatter?: QuantityFormatter;
    // @internal (undocumented)
    renderSys?: RenderSystem | RenderSystem.Options;
    // @internal (undocumented)
    sessionId?: GuidString;
    settings?: SettingsAdmin;
    // @internal (undocumented)
    tentativePoint?: TentativePoint;
    // @internal (undocumented)
    terrainProvider?: TerrainProvider;
    // @alpha
    tileAdmin?: TileAdmin;
    toolAdmin?: ToolAdmin;
    viewManager?: ViewManager;
}

// @public
export class IModelConnection extends IModel {
    // @internal
    attachChangeCache(): Promise<void>;
    cartographicToSpatial(cartographic: Cartographic, result?: Point3d): Promise<Point3d>;
    cartographicToSpatialFromGcs(cartographic: Cartographic, result?: Point3d): Promise<Point3d>;
    // @internal
    changeCacheAttached(): Promise<boolean>;
    close(): Promise<void>;
    // @beta
    closeSnapshot(): Promise<void>;
    readonly codeSpecs: IModelConnection.CodeSpecs;
    static connectionTimeout: number;
    // @internal
    detachChangeCache(): Promise<void>;
    readonly elements: IModelConnection.Elements;
    findClassFor<T extends typeof EntityState>(className: string, defaultClass: T | undefined): Promise<T | undefined>;
    fontMap?: FontMap;
    // @internal
    readonly geoServices: GeoServices;
    // @internal
    getContextRealityModelTileTree(url: string): TileTreeState;
    getToolTipMessage(id: string): Promise<string[]>;
    // @alpha
    readonly hilited: HiliteSet;
    // @alpha
    readonly isClosed: boolean;
    // @alpha
    readonly isOpen: boolean;
    readonly isReadonly: boolean;
    loadFontMap(): Promise<FontMap>;
    readonly models: IModelConnection.Models;
    // @internal
    protected _noGcsDefined?: boolean;
    static readonly onClose: BeEvent<(_imodel: IModelConnection) => void>;
    static open(contextId: string, iModelId: string, openMode?: OpenMode, version?: IModelVersion): Promise<IModelConnection>;
    readonly openMode: OpenMode;
    // @beta
    static openSnapshot(fileName: string): Promise<IModelConnection>;
    // @alpha
    query(ecsql: string, bindings?: any[] | object, limitRows?: number, quota?: QueryQuota, priority?: QueryPriority): AsyncIterableIterator<any>;
    queryEntityIds(params: EntityQueryParams): Promise<Id64Set>;
    queryRowCount(ecsql: string, bindings?: any[] | object): Promise<number>;
    // @internal
    queryRows(ecsql: string, bindings?: any[] | object, limit?: QueryLimit, quota?: QueryQuota, priority?: QueryPriority): Promise<QueryResponse>;
    requestSnap(props: SnapRequestProps): Promise<SnapResponseProps>;
    saveChanges(description?: string): Promise<void>;
    readonly selectionSet: SelectionSet;
    spatialToCartographic(spatial: XYAndZ, result?: Cartographic): Promise<Cartographic>;
    spatialToCartographicFromGcs(spatial: XYAndZ, result?: Cartographic): Promise<Cartographic>;
    // @internal
    readonly subcategories: SubCategoriesCache;
    // @internal
    readonly tiles: IModelConnection.Tiles;
    readonly transientIds: TransientIdSequence;
    updateProjectExtents(newExtents: AxisAlignedBox3d): Promise<void>;
    readonly views: IModelConnection.Views;
}

// @public (undocumented)
export namespace IModelConnection {
    export class CodeSpecs {
        // @internal
        constructor(_iModel: IModelConnection);
        getById(codeSpecId: Id64String): Promise<CodeSpec>;
        getByName(name: string): Promise<CodeSpec>;
        }
    export class Elements {
        // @internal
        constructor(_iModel: IModelConnection);
        getProps(arg: Id64Arg): Promise<ElementProps[]>;
        queryIds(params: EntityQueryParams): Promise<Id64Set>;
        queryProps(params: EntityQueryParams): Promise<ElementProps[]>;
        readonly rootSubjectId: Id64String;
    }
    export class Models {
        // @internal
        constructor(_iModel: IModelConnection);
        getLoaded(id: string): ModelState | undefined;
        getProps(modelIds: Id64Arg): Promise<ModelProps[]>;
        load(modelIds: Id64Arg): Promise<void>;
        loaded: Map<string, ModelState>;
        onIModelConnectionClose(): void;
        // @alpha
        query(queryParams: ModelQueryParams): AsyncIterableIterator<ModelProps>;
        queryModelRanges(modelIds: Id64Arg): Promise<Range3dProps[]>;
        queryProps(queryParams: ModelQueryParams): Promise<ModelProps[]>;
        readonly repositoryModelId: string;
    }
    // @internal
    export class Tiles {
        constructor(iModel: IModelConnection);
        // (undocumented)
        getTileContent(treeId: string, contentId: string): Promise<Uint8Array>;
        // (undocumented)
        getTileTreeProps(id: string): Promise<TileTreeProps>;
        }
    export class Views {
        // @internal
        constructor(_iModel: IModelConnection);
        getThumbnail(viewId: Id64String): Promise<ThumbnailProps>;
        getViewList(queryParams: ViewQueryParams): Promise<ViewSpec[]>;
        load(viewDefinitionId: Id64String): Promise<ViewState>;
        queryDefaultViewId(): Promise<Id64String>;
        queryProps(queryParams: ViewQueryParams): Promise<ViewDefinitionProps[]>;
        saveThumbnail(viewId: Id64String, thumbnail: ThumbnailProps): Promise<void>;
    }
    export interface ViewSpec {
        class: string;
        id: string;
        name: string;
    }
}

// @public
export abstract class InputCollector extends InteractiveTool {
    // (undocumented)
    exitTool(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    run(): boolean;
}

// @alpha
export interface InputEditorSizeParams extends BasePropertyEditorParams {
    maxLength?: number;
    size?: number;
    // (undocumented)
    type: PropertyEditorParamTypes.InputEditorSize;
}

// @public
export enum InputSource {
    Mouse = 1,
    Touch = 2,
    Unknown = 0
}

// @internal
export interface InstancedGraphicParams {
    readonly count: number;
    readonly featureIds?: Uint8Array;
    readonly symbologyOverrides?: Uint8Array;
    readonly transformCenter: Point3d;
    readonly transforms: Float32Array;
}

// @public
export abstract class InteractiveTool extends Tool {
    // @beta
    applyToolSettingPropertyChange(_updatedValue: ToolSettingsPropertySyncItem): boolean;
    beginDynamics(): void;
    changeLocateState(enableLocate: boolean, enableSnap?: boolean, cursor?: string, coordLockOvr?: CoordinateLockOverrides): void;
    decorate(_context: DecorateContext): void;
    decorateSuspended(_context: DecorateContext): void;
    endDynamics(): void;
    // (undocumented)
    abstract exitTool(): void;
    filterHit(_hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus>;
    getCurrentButtonEvent(ev: BeButtonEvent): void;
    getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined;
    getToolTip(_hit: HitDetail): Promise<HTMLElement | string>;
    initLocateElements(enableLocate?: boolean, enableSnap?: boolean, cursor?: string, coordLockOvr?: CoordinateLockOverrides): void;
    // (undocumented)
    isCompatibleViewport(_vp: Viewport, _isSelectedViewChange: boolean): boolean;
    readonly isDynamicsStarted: boolean;
    // (undocumented)
    isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean;
    onCleanup(): void;
    onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    onDynamicFrame(_ev: BeButtonEvent, _context: DynamicsContext): void;
    onInstall(): boolean;
    onKeyTransition(_wentDown: boolean, _keyEvent: KeyboardEvent): Promise<EventHandled>;
    onMiddleButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    onMiddleButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    onModifierKeyTransition(_wentDown: boolean, _modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled>;
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    onMouseMotion(_ev: BeButtonEvent): Promise<void>;
    onMouseMotionStopped(_ev: BeButtonEvent): Promise<void>;
    onMouseNoMotion(_ev: BeButtonEvent): Promise<void>;
    onMouseStartDrag(_ev: BeButtonEvent): Promise<EventHandled>;
    onMouseWheel(_ev: BeWheelEvent): Promise<EventHandled>;
    onPostInstall(): void;
    onReinitialize(): void;
    onResetButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    onSelectedViewportChanged(_previous: Viewport | undefined, _current: Viewport | undefined): void;
    onSuspend(): void;
    onTouchCancel(_ev: BeTouchEvent): Promise<void>;
    onTouchComplete(_ev: BeTouchEvent): Promise<void>;
    onTouchEnd(_ev: BeTouchEvent): Promise<void>;
    onTouchMove(_ev: BeTouchEvent): Promise<void>;
    onTouchMoveStart(_ev: BeTouchEvent, _startEv: BeTouchEvent): Promise<EventHandled>;
    onTouchStart(_ev: BeTouchEvent): Promise<void>;
    onTouchTap(_ev: BeTouchEvent): Promise<EventHandled>;
    onUnsuspend(): void;
    receivedDownEvent: boolean;
    // @beta
    supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined;
    // @beta
    syncToolSettingsProperties(syncData: ToolSettingsPropertySyncItem[]): void;
    testDecorationHit(_id: string): boolean;
}

// @public (undocumented)
export class IntersectDetail extends SnapDetail {
    constructor(from: SnapDetail, heat: SnapHeat | undefined, snapPoint: XYZProps, otherPrimitive: CurvePrimitive, otherId: string);
    // (undocumented)
    draw(context: DecorateContext): void;
    // (undocumented)
    readonly otherId: string;
    // (undocumented)
    readonly otherPrimitive: CurvePrimitive;
}

// @internal (undocumented)
export enum ItemField {
    // (undocumented)
    ANGLE_Item = 1,
    // (undocumented)
    DIST_Item = 0,
    // (undocumented)
    X_Item = 2,
    // (undocumented)
    Y_Item = 3,
    // (undocumented)
    Z_Item = 4
}

// @alpha
export interface JsonEditorParams extends BasePropertyEditorParams {
    // (undocumented)
    json: any;
    // (undocumented)
    type: PropertyEditorParamTypes.JSON;
}

// @internal (undocumented)
export enum KeyinStatus {
    // (undocumented)
    DontUpdate = 2,
    // (undocumented)
    Dynamic = 0,
    // (undocumented)
    Partial = 1
}

// @internal (undocumented)
export function linePlaneIntersect(outP: Point3d, linePt: Point3d, lineNormal: Vector3d | undefined, planePt: Point3d, planeNormal: Vector3d, perpendicular: boolean): void;

// @beta
export interface LinkElementsInfo {
    matcher?: (displayValue: string) => Array<{
        start: number;
        end: number;
    }>;
    onClick: (record: PropertyRecord, text: string) => void;
}

// @public
export enum LocateAction {
    // (undocumented)
    AutoLocate = 1,
    // (undocumented)
    Identify = 0
}

// @public
export enum LocateFilterStatus {
    // (undocumented)
    Accept = 0,
    // (undocumented)
    Reject = 1
}

// @public
export class LocateOptions {
    allowDecorations: boolean;
    allowNonLocatable: boolean;
    clone(): LocateOptions;
    hitSource: HitSource;
    // (undocumented)
    init(): void;
    maxHits: number;
    // (undocumented)
    setFrom(other: LocateOptions): void;
}

// @public (undocumented)
export class LocateResponse {
    // (undocumented)
    explanation: string;
    // (undocumented)
    reason?: string;
    // (undocumented)
    snapStatus: SnapStatus;
}

// @internal (undocumented)
export enum LockedStates {
    // (undocumented)
    ANGLE_BM = 7,
    // (undocumented)
    DIST_BM = 8,
    // (undocumented)
    NONE_LOCKED = 0,
    // (undocumented)
    VEC_BM = 4,
    // (undocumented)
    X_BM = 1,
    // (undocumented)
    XY_BM = 3,
    // (undocumented)
    Y_BM = 2
}

// @public
export class LookViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export enum ManipulatorToolEvent {
    // (undocumented)
    Start = 1,
    // (undocumented)
    Stop = 2,
    // (undocumented)
    Suspend = 3,
    // (undocumented)
    Unsuspend = 4
}

// @public
export class MarginPercent {
    constructor(left: number, top: number, right: number, bottom: number);
    // (undocumented)
    bottom: number;
    // (undocumented)
    left: number;
    // (undocumented)
    right: number;
    // (undocumented)
    top: number;
}

// @public
export class Marker implements CanvasDecoration {
    constructor(worldLocation: XYAndZ, size: XAndY);
    addDecoration(context: DecorateContext): void;
    addMarker(context: DecorateContext): void;
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    drawFunc?(ctx: CanvasRenderingContext2D): void;
    protected drawHilited(ctx: CanvasRenderingContext2D): boolean;
    protected _hiliteColor?: ColorDef;
    image?: MarkerImage;
    imageOffset?: XAndY;
    imageSize?: XAndY;
    protected _isHilited: boolean;
    label?: string;
    labelAlign?: MarkerTextAlign;
    labelBaseline?: MarkerTextBaseline;
    labelColor?: MarkerFillStyle;
    labelFont?: string;
    labelOffset?: XAndY;
    static makeFrom<T extends Marker>(other: Marker, ...args: any[]): T;
    onMouseButton?(_ev: BeButtonEvent): boolean;
    onMouseEnter(ev: BeButtonEvent): void;
    onMouseLeave(): void;
    onMouseMove(ev: BeButtonEvent): void;
    pick(pt: XAndY): boolean;
    position: Point3d;
    readonly rect: ViewRect;
    // (undocumented)
    protected _scaleFactor?: Point2d;
    // (undocumented)
    protected _scaleFactorRange?: Range1d;
    setImage(image: MarkerImage | Promise<MarkerImage>): void;
    setImageUrl(url: string): void;
    setPosition(vp: Viewport): boolean;
    setScaleFactor(range: Range1dProps): void;
    size: Point2d;
    title?: HTMLElement | string;
    tooltipOptions?: ToolTipOptions;
    visible: boolean;
    readonly wantImage: boolean;
    worldLocation: Point3d;
}

// @public (undocumented)
export type MarkerFillStyle = string | CanvasGradient | CanvasPattern;

// @public
export type MarkerImage = HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap;

// @public
export abstract class MarkerSet<T extends Marker> {
    addDecoration(context: DecorateContext): void;
    // @internal (undocumented)
    protected _entries: Array<T | Cluster<T>>;
    protected abstract getClusterMarker(cluster: Cluster<T>): Marker;
    readonly markers: Set<T>;
    minimumClusterSize: number;
    // @internal (undocumented)
    protected readonly _worldToViewMap: Matrix4d;
}

// @public (undocumented)
export type MarkerTextAlign = "left" | "right" | "center" | "start" | "end";

// @public (undocumented)
export type MarkerTextBaseline = "top" | "hanging" | "middle" | "alphabetic" | "ideographic" | "bottom";

// @alpha (undocumented)
export class MeasureDistanceTool extends PrimitiveTool {
    // (undocumented)
    protected readonly _acceptedSegments: {
        distance: number;
        slope: number;
        start: Point3d;
        end: Point3d;
        delta: Vector3d;
        refAxes: Matrix3d;
        marker: MeasureMarker;
    }[];
    // (undocumented)
    protected acceptNewSegments(): Promise<void>;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    protected displayDelta(context: DecorateContext, seg: any): void;
    // (undocumented)
    protected displayDynamicDistance(context: DecorateContext, points: Point3d[]): void;
    // (undocumented)
    getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined;
    // (undocumented)
    protected getMarkerToolTip(distance: number, slope: number, start: Point3d, end: Point3d, delta?: Vector3d): Promise<HTMLElement>;
    // (undocumented)
    protected getReferenceAxes(vp?: Viewport): Matrix3d;
    // (undocumented)
    protected getSnapPoints(): Point3d[] | undefined;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    protected readonly _locationData: {
        point: Point3d;
        refAxes: Matrix3d;
    }[];
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onKeyTransition(wentDown: boolean, keyEvent: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected reportMeasurements(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    protected _snapGeomId?: string;
    // (undocumented)
    testDecorationHit(id: string): boolean;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected _totalDistance: number;
    // (undocumented)
    protected _totalDistanceMarker?: MeasureLabel;
    // (undocumented)
    protected updateSelectedMarkerToolTip(seg: any, ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    protected updateTotals(): Promise<void>;
}

// @alpha (undocumented)
export class MeasureLocationTool extends PrimitiveTool {
    // (undocumented)
    protected readonly _acceptedLocations: MeasureMarker[];
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    protected getMarkerToolTip(point: Point3d): Promise<HTMLElement>;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected reportMeasurements(): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export enum MessageBoxIconType {
    // (undocumented)
    Critical = 4,
    // (undocumented)
    Information = 1,
    // (undocumented)
    NoSymbol = 0,
    // (undocumented)
    Question = 2,
    // (undocumented)
    Warning = 3
}

// @public
export enum MessageBoxType {
    // (undocumented)
    LargeOk = 2,
    // (undocumented)
    MediumAlert = 3,
    // (undocumented)
    Ok = 1,
    // (undocumented)
    OkCancel = 0,
    // (undocumented)
    YesNo = 5,
    // (undocumented)
    YesNoCancel = 4
}

// @public
export enum MessageBoxValue {
    // (undocumented)
    Apply = 1,
    // (undocumented)
    Cancel = 4,
    // (undocumented)
    Default = 5,
    // (undocumented)
    Help = 10,
    // (undocumented)
    No = 7,
    // (undocumented)
    NoToAll = 12,
    // (undocumented)
    Ok = 3,
    // (undocumented)
    Reset = 2,
    // (undocumented)
    Retry = 8,
    // (undocumented)
    Stop = 9,
    // (undocumented)
    Yes = 6,
    // (undocumented)
    YesToAll = 11
}

// @internal
export namespace MockRender {
    export class App {
        // (undocumented)
        protected static createDefaultRenderSystem(): System;
        // (undocumented)
        static shutdown(): void;
        // (undocumented)
        static startup(opts?: IModelAppOptions): void;
        // (undocumented)
        static systemFactory: SystemFactory;
    }
    // (undocumented)
    export class Batch extends Graphic {
        constructor(graphic: RenderGraphic, featureTable: PackedFeatureTable, range: ElementAlignedBox3d);
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly featureTable: PackedFeatureTable;
        // (undocumented)
        readonly graphic: RenderGraphic;
        // (undocumented)
        readonly range: ElementAlignedBox3d;
    }
    // (undocumented)
    export class Branch extends Graphic {
        constructor(branch: GraphicBranch, transform: Transform, clips?: RenderClipVolume | undefined);
        // (undocumented)
        readonly branch: GraphicBranch;
        // (undocumented)
        readonly clips?: RenderClipVolume | undefined;
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly transform: Transform;
    }
    // (undocumented)
    export class Builder extends PrimitiveBuilder {
        constructor(system: System, placement: Transform | undefined, type: GraphicType, viewport: Viewport, pickId?: Id64String);
    }
    // (undocumented)
    export class Graphic extends RenderGraphic {
        constructor();
        // (undocumented)
        collectStatistics(_stats: RenderMemory.Statistics): void;
        // (undocumented)
        dispose(): void;
    }
    // (undocumented)
    export class List extends Graphic {
        constructor(graphics: RenderGraphic[]);
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly graphics: RenderGraphic[];
    }
    // (undocumented)
    export class OffScreenTarget extends Target {
        constructor(system: System, _viewRect: ViewRect);
        // (undocumented)
        setViewRect(rect: ViewRect, _temp: boolean): void;
        // (undocumented)
        readonly viewRect: ViewRect;
        }
    // (undocumented)
    export class OnScreenTarget extends Target {
        constructor(system: System, _canvas: HTMLCanvasElement);
        // (undocumented)
        setViewRect(_rect: ViewRect, _temp: boolean): void;
        // (undocumented)
        readonly viewRect: ViewRect;
    }
    // (undocumented)
    export class System extends RenderSystem {
        constructor();
        // (undocumented)
        createBatch(graphic: RenderGraphic, features: PackedFeatureTable, range: ElementAlignedBox3d): Batch;
        // (undocumented)
        createGraphicBranch(branch: GraphicBranch, transform: Transform, clips?: RenderClipVolume): Branch;
        // (undocumented)
        createGraphicBuilder(placement: Transform, type: GraphicType, viewport: Viewport, pickableId?: Id64String): Builder;
        // (undocumented)
        createGraphicList(primitives: RenderGraphic[]): List;
        // (undocumented)
        createMesh(_params: MeshParams): Graphic;
        // (undocumented)
        createOffscreenTarget(rect: ViewRect): RenderTarget;
        // (undocumented)
        createPointCloud(_args: PointCloudArgs, _imodel: IModelConnection): Graphic;
        // (undocumented)
        createPointString(_params: PointStringParams): Graphic;
        // (undocumented)
        createPolyline(_params: PolylineParams): Graphic;
        // (undocumented)
        createTarget(canvas: HTMLCanvasElement): OnScreenTarget;
        // (undocumented)
        dispose(): void;
        // (undocumented)
        readonly isValid: boolean;
        // (undocumented)
        readonly maxTextureSize: number;
    }
    // (undocumented)
    export type SystemFactory = () => RenderSystem;
    // (undocumented)
    export abstract class Target extends RenderTarget {
        protected constructor(_system: System);
        // (undocumented)
        animationFraction: number;
        // (undocumented)
        readonly cameraFrustumNearScaleLimit: number;
        // (undocumented)
        changeBackgroundMap(_backgroundMap: GraphicList): void;
        // (undocumented)
        changeDecorations(_decs: Decorations): void;
        // (undocumented)
        changeDynamics(_dynamics?: GraphicList): void;
        // (undocumented)
        changeRenderPlan(_plan: RenderPlan): void;
        // (undocumented)
        changeScene(_scene: GraphicList): void;
        // (undocumented)
        drawFrame(_sceneTime?: number): void;
        // (undocumented)
        readPixels(_rect: ViewRect, _selector: Pixel.Selector, receiver: Pixel.Receiver, _excludeNonLocatable: boolean): void;
        // (undocumented)
        readonly renderSystem: RenderSystem;
        // (undocumented)
        updateViewRect(): boolean;
        // (undocumented)
        readonly wantInvertBlackBackground: boolean;
    }
}

// @public
export class ModelSelectorState extends ElementState {
    constructor(props: ModelSelectorProps, iModel: IModelConnection);
    addModels(arg: Id64Arg): void;
    // @internal (undocumented)
    static readonly className: string;
    containsModel(modelId: Id64String): boolean;
    dropModels(arg: Id64Arg): void;
    equalState(other: ModelSelectorState): boolean;
    has(id: string): boolean;
    load(): Promise<void>;
    readonly models: Set<string>;
    readonly name: string;
    // (undocumented)
    toJSON(): ModelSelectorProps;
}

// @public
export class ModelState extends EntityState implements ModelProps {
    constructor(props: ModelProps, iModel: IModelConnection);
    readonly asGeometricModel: GeometricModelState | undefined;
    readonly asGeometricModel2d: GeometricModel2dState | undefined;
    readonly asGeometricModel3d: GeometricModel3dState | undefined;
    // @internal (undocumented)
    static readonly className: string;
    readonly isGeometricModel: boolean;
    // (undocumented)
    readonly isPrivate: boolean;
    // (undocumented)
    readonly isTemplate: boolean;
    // (undocumented)
    readonly modeledElement: RelatedElement;
    // (undocumented)
    readonly name: string;
    // @internal
    onIModelConnectionClose(): void;
    // (undocumented)
    parentModel: Id64String;
    toJSON(): ModelProps;
}

// @internal (undocumented)
export enum ModifyElementSource {
    DragSelect = 5,
    Fence = 3,
    Group = 4,
    Selected = 1,
    SelectionSet = 2,
    Unknown = 0
}

// @alpha
export interface MultilineTextEditorParams extends BasePropertyEditorParams {
    // (undocumented)
    heightInRows: number;
    // (undocumented)
    type: PropertyEditorParamTypes.MultilineText;
}

// @internal
export class NoRenderApp {
    // (undocumented)
    static startup(opts?: IModelAppOptions): void;
}

// @public
export class NotificationManager {
    clearToolTip(): void;
    closeInputFieldMessage(): void;
    closePointerMessage(): void;
    endActivityMessage(_reason: ActivityMessageEndReason): boolean;
    readonly isToolTipOpen: boolean;
    readonly isToolTipSupported: boolean;
    openMessageBox(_mbType: MessageBoxType, _message: string, _icon: MessageBoxIconType): Promise<MessageBoxValue>;
    // @beta
    openToolTip(_htmlElement: HTMLElement, message: HTMLElement | string, location?: XAndY, options?: ToolTipOptions): void;
    outputActivityMessage(_messageText: string, _percentComplete: number): boolean;
    // @beta
    outputMessage(_message: NotifyMessageDetails): void;
    outputPrompt(_prompt: string): void;
    outputPromptByKey(key: string): void;
    setupActivityMessage(_details: ActivityMessageDetails): boolean;
    // @beta
    protected _showToolTip(_htmlElement: HTMLElement, _message: HTMLElement | string, _location?: XAndY, _options?: ToolTipOptions): void;
    // (undocumented)
    readonly toolTipLocation: Point2d;
}

// @beta
export class NotifyMessageDetails {
    constructor(priority: OutputMessagePriority, briefMessage: string, detailedMessage?: string | undefined, msgType?: OutputMessageType, openAlert?: OutputMessageAlert);
    // (undocumented)
    briefMessage: string;
    // (undocumented)
    detailedMessage?: string | undefined;
    // (undocumented)
    displayPoint?: Point2d;
    // (undocumented)
    displayTime: BeDuration;
    // (undocumented)
    inputField?: HTMLElement;
    // (undocumented)
    msgType: OutputMessageType;
    // (undocumented)
    openAlert: OutputMessageAlert;
    // (undocumented)
    priority: OutputMessagePriority;
    // (undocumented)
    relativePosition: RelativePosition;
    setInputFieldTypeDetails(inputField: HTMLElement): void;
    setPointerTypeDetails(viewport: HTMLElement, displayPoint: XAndY, relativePosition?: RelativePosition): void;
    // (undocumented)
    viewport?: HTMLElement;
}

// @internal
export class NullRenderSystem extends RenderSystem {
    constructor();
    // (undocumented)
    createBatch(): any;
    // (undocumented)
    createGraphicBranch(): any;
    // (undocumented)
    createGraphicBuilder(): any;
    // (undocumented)
    createGraphicList(): any;
    // (undocumented)
    createOffscreenTarget(): NullTarget;
    // (undocumented)
    createTarget(): NullTarget;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    readonly isValid: boolean;
}

// @internal
export class NullTarget extends RenderTarget {
    // (undocumented)
    animationBranches: AnimationBranchStates | undefined;
    // (undocumented)
    animationFraction: number;
    // (undocumented)
    readonly cameraFrustumNearScaleLimit: number;
    // (undocumented)
    changeBackgroundMap(): void;
    // (undocumented)
    changeDecorations(): void;
    // (undocumented)
    changeDynamics(): void;
    // (undocumented)
    changeRenderPlan(): void;
    // (undocumented)
    changeScene(): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    drawFrame(_sceneMilSecElapsed?: number): void;
    // (undocumented)
    onDestroy(): void;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    overrideFeatureSymbology(): void;
    // (undocumented)
    readImage(): undefined;
    // (undocumented)
    readPixels(): void;
    // (undocumented)
    readonly renderSystem: any;
    // (undocumented)
    reset(): void;
    // (undocumented)
    setFlashed(): void;
    // (undocumented)
    setHiliteSet(): void;
    // (undocumented)
    setViewRect(): void;
    // (undocumented)
    updateViewRect(): boolean;
    // (undocumented)
    readonly viewRect: ViewRect;
    // (undocumented)
    readonly wantInvertBlackBackground: boolean;
}

// @internal (undocumented)
export class OffScreenTarget extends Target {
    constructor(rect: ViewRect);
    // (undocumented)
    animationFraction: number;
    // (undocumented)
    protected _assignDC(): boolean;
    // (undocumented)
    protected _beginPaint(): void;
    // (undocumented)
    protected _endPaint(): void;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    setViewRect(rect: ViewRect, temporary: boolean): void;
    // (undocumented)
    updateViewRect(): boolean;
    // (undocumented)
    readonly viewRect: ViewRect;
}

// @internal
export class OffScreenViewport extends Viewport {
    // (undocumented)
    static create(view: ViewState, viewRect?: ViewRect): OffScreenViewport;
    // (undocumented)
    setRect(rect: ViewRect, temporary?: boolean): void;
    // (undocumented)
    readonly viewRect: ViewRect;
}

// @beta
export class OidcBrowserClient extends OidcClient implements IOidcFrontendClient {
    constructor(_configuration: OidcFrontendClientConfiguration);
    dispose(): void;
    getAccessToken(requestContext?: ClientRequestContext): Promise<AccessToken>;
    readonly hasExpired: boolean;
    readonly hasSignedIn: boolean;
    initialize(requestContext: FrontendRequestContext): Promise<void>;
    readonly isAuthorized: boolean;
    readonly onUserStateChanged: BeEvent<(token: AccessToken | undefined) => void>;
    signIn(requestContext: ClientRequestContext, successRedirectUrl?: string): Promise<void>;
    signOut(requestContext: ClientRequestContext): Promise<void>;
    }

// @internal
export class OnScreenTarget extends Target {
    constructor(canvas: HTMLCanvasElement);
    // (undocumented)
    animationFraction: number;
    // (undocumented)
    protected _assignDC(): boolean;
    // (undocumented)
    protected _beginPaint(): void;
    // (undocumented)
    protected debugPaint(): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    protected drawOverlayDecorations(): void;
    // (undocumented)
    protected _endPaint(): void;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    pickOverlayDecoration(pt: XAndY): CanvasDecoration | undefined;
    // (undocumented)
    setViewRect(_rect: ViewRect, _temporary: boolean): void;
    // (undocumented)
    updateViewRect(): boolean;
    // (undocumented)
    readonly viewRect: ViewRect;
}

// @public
export class OrthographicViewState extends SpatialViewState {
    constructor(props: SpatialViewDefinitionProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle3dState, modelSelector: ModelSelectorState);
    // @internal (undocumented)
    static readonly className: string;
    // (undocumented)
    supportsCamera(): boolean;
}

// @public
export enum OutputMessageAlert {
    // (undocumented)
    Balloon = 2,
    // (undocumented)
    Dialog = 1,
    // (undocumented)
    None = 0
}

// @public
export enum OutputMessagePriority {
    // (undocumented)
    Debug = 13,
    // (undocumented)
    Error = 10,
    // (undocumented)
    Fatal = 17,
    // (undocumented)
    Info = 12,
    // (undocumented)
    None = 0,
    // (undocumented)
    Warning = 11
}

// @public
export enum OutputMessageType {
    Alert = 4,
    // (undocumented)
    InputField = 3,
    // (undocumented)
    Pointer = 1,
    // (undocumented)
    Sticky = 2,
    Toast = 0
}

// @internal (undocumented)
export class OverlayMapProvider extends BaseTiledMapProvider implements TiledGraphicsProvider.Provider {
    constructor(imageryProvider: ImageryProvider, groundBias: number, iModel: IModelConnection);
    // (undocumented)
    getTileTree(_viewport: Viewport): TiledGraphicsProvider.Tree | undefined;
}

// @internal (undocumented)
export interface PackedFeature {
    // (undocumented)
    animationNodeId: number;
    // (undocumented)
    elementId: Id64.Uint32Pair;
    // (undocumented)
    geometryClass: GeometryClass;
    // (undocumented)
    subCategoryId: Id64.Uint32Pair;
}

// @internal
export class PackedFeatureTable {
    constructor(data: Uint32Array, modelId: Id64String, numFeatures: number, maxFeatures: number, type: BatchType, animationNodeIds?: Uint8Array | Uint16Array | Uint32Array);
    // (undocumented)
    readonly anyDefined: boolean;
    // (undocumented)
    readonly byteLength: number;
    findElementId(featureIndex: number): Id64String | undefined;
    findFeature(featureIndex: number): Feature | undefined;
    // (undocumented)
    getAnimationNodeId(featureIndex: number): number;
    // (undocumented)
    getElementIdPair(featureIndex: number): Id64.Uint32Pair;
    getFeature(featureIndex: number): Feature;
    // (undocumented)
    getPackedFeature(featureIndex: number): PackedFeature;
    // (undocumented)
    getSubCategoryIdPair(featureIndex: number): Id64.Uint32Pair;
    // (undocumented)
    readonly isClassifier: boolean;
    // (undocumented)
    readonly isPlanarClassifier: boolean;
    readonly isUniform: boolean;
    // (undocumented)
    readonly isVolumeClassifier: boolean;
    // (undocumented)
    readonly maxFeatures: number;
    // (undocumented)
    readonly modelId: Id64String;
    // (undocumented)
    readonly numFeatures: number;
    static pack(featureTable: FeatureTable): PackedFeatureTable;
    // (undocumented)
    readonly type: BatchType;
    readonly uniform: Feature | undefined;
    unpack(): FeatureTable;
}

// @public
export class PanViewTool extends ViewManip {
    constructor(vp: ScreenViewport | undefined, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha
export interface ParseResults {
    // (undocumented)
    parseError?: string;
    // (undocumented)
    value?: string | number | boolean | {} | string[] | Date | [] | undefined;
}

// @internal (undocumented)
export class PerformanceMetrics {
    constructor(gatherGlFinish?: boolean, gatherCurPerformanceMetrics?: boolean);
    // (undocumented)
    curSpfTimeIndex: number;
    // (undocumented)
    endFrame(operationName?: string): void;
    // (undocumented)
    fpsTimer: StopWatch;
    // (undocumented)
    fpsTimerStart: number;
    // (undocumented)
    frameTimings: Map<string, number>;
    // (undocumented)
    gatherCurPerformanceMetrics: boolean;
    // (undocumented)
    gatherGlFinish: boolean;
    // (undocumented)
    loadTileSum: number;
    // (undocumented)
    loadTileTimes: number[];
    // (undocumented)
    recordTime(operationName: string): void;
    // (undocumented)
    renderSpfSum: number;
    // (undocumented)
    renderSpfTimes: number[];
    // (undocumented)
    spfSum: number;
    // (undocumented)
    spfTimes: number[];
    // (undocumented)
    startNewFrame(sceneTime?: number): void;
}

// @beta
export namespace PerModelCategoryVisibility {
    export enum Override {
        Hide = 2,
        None = 0,
        Show = 1
    }
    export interface Overrides {
        clearOverrides(modelIds?: Id64Arg): void;
        getOverride(modelId: Id64String, categoryId: Id64String): Override;
        setOverride(modelIds: Id64Arg, categoryIds: Id64Arg, override: Override): void;
    }
}

// @public
export class PhysicalModelState extends SpatialModelState {
    // @internal (undocumented)
    static readonly className: string;
}

// @internal
export interface PingTestResult {
    avg: number | undefined;
    max: number | undefined;
    min: number | undefined;
}

// @beta
export namespace Pixel {
    export interface Buffer {
        getPixel(x: number, y: number): Data;
    }
    export class Data {
        // @internal
        constructor(feature?: Feature, distanceFraction?: number, type?: GeometryType, planarity?: Planarity, featureTable?: PackedFeatureTable);
        // (undocumented)
        readonly distanceFraction: number;
        // (undocumented)
        readonly elementId: Id64String | undefined;
        // (undocumented)
        readonly feature?: Feature;
        // @internal (undocumented)
        readonly featureTable?: PackedFeatureTable;
        // (undocumented)
        readonly geometryClass: GeometryClass | undefined;
        // (undocumented)
        readonly planarity: Planarity;
        // (undocumented)
        readonly subCategoryId: Id64String | undefined;
        // (undocumented)
        readonly type: GeometryType;
    }
    export const enum GeometryType {
        Edge = 4,
        Linear = 3,
        None = 1,
        Silhouette = 5,
        Surface = 2,
        Unknown = 0
    }
    export const enum Planarity {
        None = 1,
        NonPlanar = 3,
        Planar = 2,
        Unknown = 0
    }
    export type Receiver = (pixels: Buffer | undefined) => void;
    export const enum Selector {
        All = 5,
        Feature = 1,
        GeometryAndDistance = 4,
        // (undocumented)
        None = 0
    }
}

// @beta (undocumented)
export type PlanarClassifierMap = Map<Id64String, RenderPlanarClassifier>;

// @internal
export class PlanarClassifiers {
    // (undocumented)
    readonly classifier: PlanarClassifier | undefined;
    // (undocumented)
    readonly isValid: boolean;
    // (undocumented)
    pop(): void;
    // (undocumented)
    push(texture: PlanarClassifier): void;
}

// @public
export abstract class Plugin {
    constructor(name: string, versionsRequired: string);
    // (undocumented)
    name: string;
    abstract onExecute(_args: string[]): void;
    onLoad(_args: string[]): void;
    // (undocumented)
    versionsRequired: string;
}

// @public
export class PluginAdmin {
    static getPlugin(pluginName: string): Promise<Plugin> | undefined;
    static loadPlugin(packageName: string, args?: string[]): Promise<Plugin>;
    static register(plugin: Plugin): string[] | undefined;
    }

// @beta
export namespace Primitives {
    // (undocumented)
    export type Boolean = boolean | string | {} | [];
    // (undocumented)
    export type Enum = number | string;
    // (undocumented)
    export type Float = number | string;
    // (undocumented)
    export type Hexadecimal = Id64String;
    // (undocumented)
    export type Int = number | string;
    // (undocumented)
    export type Numeric = Float | Int;
    // (undocumented)
    export type Point = Point2d | Point3d;
    // (undocumented)
    export type Point2d = string[];
    // (undocumented)
    export type Point3d = string[];
    // (undocumented)
    export type ShortDate = string | Date;
    // (undocumented)
    export type String = string;
    // (undocumented)
    export type Text = string;
    // (undocumented)
    export type Value = Text | String | ShortDate | Boolean | Numeric | Enum | Point;
}

// @public
export abstract class PrimitiveTool extends InteractiveTool {
    autoLockTarget(): void;
    // (undocumented)
    exitTool(): void;
    getPrompt(): string;
    readonly iModel: IModelConnection;
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    isValidLocation(ev: BeButtonEvent, isButtonEvent: boolean): boolean;
    onRedoPreviousStep(): Promise<boolean>;
    onReinitialize(): void;
    abstract onRestartTool(): void;
    onSelectedViewportChanged(_previous: Viewport | undefined, current: Viewport | undefined): void;
    onUndoPreviousStep(): Promise<boolean>;
    // @internal (undocumented)
    redoPreviousStep(): Promise<boolean>;
    requireWriteableTarget(): boolean;
    run(): boolean;
    saveChanges(): Promise<void>;
    // (undocumented)
    targetIsLocked: boolean;
    // (undocumented)
    targetModelId?: string;
    // (undocumented)
    targetView?: Viewport;
    // @internal (undocumented)
    undoPreviousStep(): Promise<boolean>;
}

// @beta
export interface PrimitiveValue extends BasePropertyValue {
    // (undocumented)
    displayValue?: string;
    // (undocumented)
    value?: Primitives.Value;
    // (undocumented)
    valueFormat: PropertyValueFormat.Primitive;
}

// @internal
export const enum PrimitiveVisibility {
    All = 0,
    Instanced = 1,
    Uninstanced = 2
}

// @beta
export interface PropertyDescription {
    dataController?: string;
    // (undocumented)
    displayLabel: string;
    // (undocumented)
    editor?: PropertyEditorInfo;
    // (undocumented)
    enum?: EnumerationChoicesInfo;
    // (undocumented)
    name: string;
    // @alpha
    quantityType?: QuantityType | string;
    // (undocumented)
    typename: string;
}

// @beta
export interface PropertyEditorInfo {
    // (undocumented)
    name?: string;
    // Warning: (ae-incompatible-release-tags) The symbol "params" is marked as @beta, but its signature references "PropertyEditorParams" which is marked as @alpha
    // 
    // (undocumented)
    params?: PropertyEditorParams[];
}

// @alpha
export type PropertyEditorParams = ButtonGroupEditorParams | ColorEditorParams | InputEditorSizeParams | SuppressLabelEditorParams | BasePropertyEditorParams | CustomFormattedNumberParams;

// @alpha
export enum PropertyEditorParamTypes {
    // (undocumented)
    ButtonGroupData = 0,
    // (undocumented)
    CheckBoxIcons = 1,
    // (undocumented)
    ColorData = 10,
    // (undocumented)
    CustomFormattedNumber = 11,
    // (undocumented)
    Icon = 2,
    // (undocumented)
    InputEditorSize = 3,
    // (undocumented)
    JSON = 4,
    // (undocumented)
    MultilineText = 5,
    // (undocumented)
    Range = 6,
    // (undocumented)
    Slider = 7,
    // (undocumented)
    SuppressEditorLabel = 9,
    // (undocumented)
    SuppressUnitLabel = 8
}

// @beta
export class PropertyRecord {
    constructor(value: PropertyValue, property: PropertyDescription);
    copyWithNewValue(newValue: PropertyValue): PropertyRecord;
    // (undocumented)
    description?: string;
    // (undocumented)
    extendedData?: {
        [key: string]: any;
    };
    // (undocumented)
    isDisabled?: boolean;
    // (undocumented)
    isMerged?: boolean;
    // (undocumented)
    isReadonly?: boolean;
    links?: LinkElementsInfo;
    // (undocumented)
    readonly property: PropertyDescription;
    // (undocumented)
    readonly value: PropertyValue;
}

// @beta
export type PropertyValue = PrimitiveValue | StructValue | ArrayValue;

// @beta
export enum PropertyValueFormat {
    // (undocumented)
    Array = 1,
    // (undocumented)
    Primitive = 0,
    // (undocumented)
    Struct = 2
}

// @alpha
export class QuantityFormatter implements UnitsProvider {
    // (undocumented)
    protected _activeSystemIsImperial: boolean;
    findFormatterSpecByQuantityType(type: QuantityType, imperial?: boolean): FormatterSpec | undefined;
    protected findKoqFormatterSpec(koq: string, useImperial: boolean): FormatterSpec | undefined;
    findParserSpecByQuantityType(type: QuantityType, imperial?: boolean): ParserSpec | undefined;
    findUnit(unitLabel: string, unitFamily?: string): Promise<UnitProps>;
    findUnitByName(unitName: string): Promise<UnitProps>;
    // (undocumented)
    protected findUnitDefinition(name: string): UnitDefinition | undefined;
    formatQuantity(magnitude: number, formatSpec: FormatterSpec): string;
    // (undocumented)
    protected _formatSpecsByKoq: Map<string, FormatterSpec[]>;
    getConversion(fromUnit: UnitProps, toUnit: UnitProps): Promise<UnitConversion>;
    // (undocumented)
    protected getFormatByQuantityType(type: QuantityType, imperial: boolean): Promise<Format>;
    getFormatterSpecByQuantityType(type: QuantityType, imperial?: boolean): Promise<FormatterSpec>;
    protected getKoqFormatterSpec(koq: string, useImperial: boolean): Promise<FormatterSpec | undefined>;
    protected getKoqFormatterSpecsAsync(koq: string, useImperial: boolean): Promise<FormatterSpec[] | undefined>;
    getParserSpecByQuantityType(type: QuantityType, imperial?: boolean): Promise<ParserSpec>;
    protected getUnitByQuantityType(type: QuantityType): Promise<UnitProps>;
    getUnitsByFamily(unitFamily: string): Promise<UnitProps[]>;
    // (undocumented)
    protected _imperialFormatsByType: Map<QuantityType, Format>;
    // (undocumented)
    protected _imperialFormatSpecsByType: Map<QuantityType, FormatterSpec>;
    // (undocumented)
    protected _imperialParserSpecsByType: Map<QuantityType, ParserSpec>;
    loadFormatAndParsingMaps(useImperial: boolean): Promise<void>;
    protected loadFormatSpecsForQuantityTypes(useImperial: boolean): Promise<void>;
    protected loadKoqFormatSpecs(koq: string): Promise<void>;
    protected loadParsingSpecsForQuantityTypes(useImperial: boolean): Promise<void>;
    // (undocumented)
    protected loadStdFormat(type: QuantityType, imperial: boolean): Promise<Format>;
    // (undocumented)
    protected _metricFormatsByType: Map<QuantityType, Format>;
    // (undocumented)
    protected _metricFormatSpecsByType: Map<QuantityType, FormatterSpec>;
    // (undocumented)
    protected _metricUnitParserSpecsByType: Map<QuantityType, ParserSpec>;
    parseIntoQuantityValue(inString: string, parserSpec: ParserSpec): ParseResult;
    useImperialFormats: boolean;
}

// @alpha
export enum QuantityType {
    // (undocumented)
    Angle = 2,
    // (undocumented)
    Area = 3,
    // (undocumented)
    Coordinate = 6,
    // (undocumented)
    LatLong = 5,
    // (undocumented)
    Length = 1,
    // (undocumented)
    Volume = 4
}

// @alpha
export interface RangeEditorParams extends BasePropertyEditorParams {
    maximum?: number;
    minimum?: number;
    // (undocumented)
    type: PropertyEditorParamTypes.Range;
}

// @public
export enum RelativePosition {
    // (undocumented)
    Bottom = 3,
    // (undocumented)
    BottomLeft = 6,
    // (undocumented)
    BottomRight = 7,
    // (undocumented)
    Left = 0,
    // (undocumented)
    Right = 2,
    // (undocumented)
    Top = 1,
    // (undocumented)
    TopLeft = 4,
    // (undocumented)
    TopRight = 5
}

// @public
export enum RemoveMe {
    // (undocumented)
    No = 0,
    // (undocumented)
    Yes = 1
}

// @beta
export class RenderClassifierModel {
    constructor(type: ClassifierType);
    // (undocumented)
    readonly type: ClassifierType;
}

// @beta
export abstract class RenderClipVolume implements IDisposable {
    protected constructor(clipVector: ClipVector);
    readonly clipVector: ClipVector;
    // @internal (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    abstract dispose(): void;
    abstract readonly type: ClippingType;
}

// @public
export class RenderContext {
    constructor(vp: Viewport, frustum?: Frustum);
    createBranch(branch: GraphicBranch, location: Transform): RenderGraphic;
    // @internal (undocumented)
    createGraphicBranch(branch: GraphicBranch, location: Transform, clip?: RenderClipVolume, planarClassifier?: RenderPlanarClassifier): RenderGraphic;
    // @internal (undocumented)
    protected _createGraphicBuilder(type: GraphicType, transform?: Transform, id?: Id64String): GraphicBuilder;
    createSceneGraphicBuilder(transform?: Transform): GraphicBuilder;
    readonly frustum: Frustum;
    readonly frustumPlanes: FrustumPlanes;
    getPixelSizeAtPoint(inPoint?: Point3d): number;
    // @internal (undocumented)
    readonly target: RenderTarget;
    readonly viewFlags: ViewFlags;
    readonly viewport: Viewport;
}

// @internal (undocumented)
export const enum RenderDiagnostics {
    All = 6,
    DebugOutput = 2,
    None = 0,
    WebGL = 4
}

// @public
export abstract class RenderGraphic implements IDisposable {
    // @internal (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    abstract dispose(): void;
}

// @internal
export namespace RenderMemory {
    export class Buffers extends Consumers {
        constructor();
        // (undocumented)
        addBuffer(type: BufferType, numBytes: number): void;
        // (undocumented)
        clear(): void;
        // (undocumented)
        readonly consumers: Consumers[];
        // (undocumented)
        readonly instances: Consumers;
        // (undocumented)
        readonly pointClouds: Consumers;
        // (undocumented)
        readonly pointStrings: Consumers;
        // (undocumented)
        readonly polylineEdges: Consumers;
        // (undocumented)
        readonly polylines: Consumers;
        // (undocumented)
        readonly silhouetteEdges: Consumers;
        // (undocumented)
        readonly surfaces: Consumers;
        // (undocumented)
        readonly visibleEdges: Consumers;
    }
    // (undocumented)
    export const enum BufferType {
        // (undocumented)
        COUNT = 8,
        // (undocumented)
        Instances = 7,
        // (undocumented)
        PointClouds = 6,
        // (undocumented)
        PointStrings = 5,
        // (undocumented)
        PolylineEdges = 3,
        // (undocumented)
        Polylines = 4,
        // (undocumented)
        SilhouetteEdges = 2,
        // (undocumented)
        Surfaces = 0,
        // (undocumented)
        VisibleEdges = 1
    }
    // (undocumented)
    export interface Consumer {
        // (undocumented)
        collectStatistics(stats: Statistics): void;
    }
    export class Consumers {
        // (undocumented)
        addConsumer(numBytes: number): void;
        // (undocumented)
        clear(): void;
        // (undocumented)
        count: number;
        // (undocumented)
        maxBytes: number;
        // (undocumented)
        totalBytes: number;
    }
    // (undocumented)
    export const enum ConsumerType {
        // (undocumented)
        ClipVolumes = 4,
        // (undocumented)
        COUNT = 7,
        // (undocumented)
        FeatureOverrides = 3,
        // (undocumented)
        FeatureTables = 2,
        // (undocumented)
        PlanarClassifiers = 5,
        // (undocumented)
        ShadowMaps = 6,
        // (undocumented)
        Textures = 0,
        // (undocumented)
        VertexTables = 1
    }
    // (undocumented)
    export class Statistics {
        constructor();
        // (undocumented)
        addBuffer(type: BufferType, numBytes: number): void;
        // (undocumented)
        addClipVolume(numBytes: number): void;
        // (undocumented)
        addConsumer(type: ConsumerType, numBytes: number): void;
        // (undocumented)
        addFeatureOverrides(numBytes: number): void;
        // (undocumented)
        addFeatureTable(numBytes: number): void;
        // (undocumented)
        addInstances(numBytes: number): void;
        // (undocumented)
        addPlanarClassifier(numBytes: number): void;
        // (undocumented)
        addPointCloud(numBytes: number): void;
        // (undocumented)
        addPointString(numBytes: number): void;
        // (undocumented)
        addPolyline(numBytes: number): void;
        // (undocumented)
        addPolylineEdges(numBytes: number): void;
        // (undocumented)
        addShadowMap(numBytes: number): void;
        // (undocumented)
        addSilhouetteEdges(numBytes: number): void;
        // (undocumented)
        addSurface(numBytes: number): void;
        // (undocumented)
        addTexture(numBytes: number): void;
        // (undocumented)
        addVertexTable(numBytes: number): void;
        // (undocumented)
        addVisibleEdges(numBytes: number): void;
        // (undocumented)
        readonly buffers: Buffers;
        // (undocumented)
        clear(): void;
        // (undocumented)
        readonly clipVolumes: Consumers;
        // (undocumented)
        readonly consumers: Consumers[];
        // (undocumented)
        readonly featureOverrides: Consumers;
        // (undocumented)
        readonly featureTables: Consumers;
        // (undocumented)
        readonly planarClassifiers: Consumers;
        // (undocumented)
        readonly shadowMaps: Consumers;
        // (undocumented)
        readonly textures: Consumers;
        // (undocumented)
        readonly totalBytes: number;
        // (undocumented)
        readonly vertexTables: Consumers;
    }
}

// @internal
export class RenderPlan {
    // (undocumented)
    readonly aaLines: AntiAliasPref;
    // (undocumented)
    readonly aaText: AntiAliasPref;
    // (undocumented)
    readonly activeVolume?: ClipVector;
    // (undocumented)
    readonly analysisStyle?: AnalysisStyle;
    // (undocumented)
    analysisTexture?: RenderTexture;
    // (undocumented)
    readonly ao?: AmbientOcclusion.Settings;
    // (undocumented)
    readonly bgColor: ColorDef;
    // (undocumented)
    classificationTextures?: Map<Id64String, RenderTexture>;
    // (undocumented)
    static createFromViewport(vp: Viewport): RenderPlan;
    // (undocumented)
    readonly expandedFrustum: ViewFrustum | undefined;
    // (undocumented)
    readonly fraction: number;
    // (undocumented)
    readonly frustum: Frustum;
    // (undocumented)
    readonly hiliteSettings: Hilite.Settings;
    // (undocumented)
    readonly hline?: HiddenLine.Settings;
    // (undocumented)
    readonly is3d: boolean;
    // (undocumented)
    readonly isFadeOutActive: boolean;
    // (undocumented)
    readonly lights?: SceneLights;
    // (undocumented)
    readonly monoColor: ColorDef;
    // (undocumented)
    selectExpandedFrustum(): void;
    // (undocumented)
    selectViewFrustum(): void;
    // (undocumented)
    readonly viewFlags: ViewFlags;
    // (undocumented)
    readonly viewFrustum: ViewFrustum;
}

// @beta
export abstract class RenderPlanarClassifier implements IDisposable {
    // (undocumented)
    abstract dispose(): void;
}

// @internal
export abstract class RenderSolarShadowMap implements IDisposable {
    // (undocumented)
    abstract collectGraphics(sceneContext: SceneContext): void;
    // (undocumented)
    abstract collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    abstract dispose(): void;
}

// @public
export abstract class RenderSystem implements IDisposable {
    // @internal
    protected constructor(options?: RenderSystem.Options);
    // @internal (undocumented)
    addSpatialClassificationModel(_modelId: Id64String, _classificationModel: RenderClassifierModel, _iModel: IModelConnection): void;
    // @internal
    abstract createBatch(graphic: RenderGraphic, features: PackedFeatureTable, range: ElementAlignedBox3d): RenderGraphic;
    createBranch(branch: GraphicBranch, transform: Transform): RenderGraphic;
    // @internal (undocumented)
    createClipVolume(_clipVector: ClipVector): RenderClipVolume | undefined;
    // @internal (undocumented)
    abstract createGraphicBranch(branch: GraphicBranch, transform: Transform, clips?: RenderClipVolume, planarClassifier?: RenderPlanarClassifier): RenderGraphic;
    abstract createGraphicBuilder(placement: Transform, type: GraphicType, viewport: Viewport, pickableId?: Id64String): GraphicBuilder;
    abstract createGraphicList(primitives: RenderGraphic[]): RenderGraphic;
    // @internal (undocumented)
    createIndexedPolylines(args: PolylineArgs, instances?: InstancedGraphicParams): RenderGraphic | undefined;
    createMaterial(_params: RenderMaterial.Params, _imodel: IModelConnection): RenderMaterial | undefined;
    // @internal (undocumented)
    createMesh(_params: MeshParams, _instances?: InstancedGraphicParams): RenderGraphic | undefined;
    // @internal (undocumented)
    abstract createOffscreenTarget(rect: ViewRect): RenderTarget;
    // @internal (undocumented)
    createPlanarClassifier(_properties: SpatialClassificationProps.Properties, _tileTree: TileTree, _classifiedModel: TileTreeModelState, _sceneContext: SceneContext): RenderPlanarClassifier | undefined;
    // @internal (undocumented)
    createPointCloud(_args: PointCloudArgs, _imodel: IModelConnection): RenderGraphic | undefined;
    // @internal (undocumented)
    createPointString(_params: PointStringParams, _instances?: InstancedGraphicParams): RenderGraphic | undefined;
    // @internal (undocumented)
    createPolyline(_params: PolylineParams, _instances?: InstancedGraphicParams): RenderGraphic | undefined;
    // @internal (undocumented)
    createSheetTile(_tile: RenderTexture, _polyfaces: IndexedPolyface[], _tileColor: ColorDef): GraphicList;
    // @internal (undocumented)
    createSheetTilePolyfaces(_corners: Point3d[], _clip?: ClipVector): IndexedPolyface[];
    createSkyBox(_params: SkyBox.CreateParams): RenderGraphic | undefined;
    // @internal (undocumented)
    abstract createTarget(canvas: HTMLCanvasElement): RenderTarget;
    // @internal
    createTextureFromCubeImages(_posX: HTMLImageElement, _negX: HTMLImageElement, _posY: HTMLImageElement, _negY: HTMLImageElement, _posZ: HTMLImageElement, _negZ: HTMLImageElement, _imodel: IModelConnection, _params: RenderTexture.Params): RenderTexture | undefined;
    createTextureFromImage(_image: HTMLImageElement, _hasAlpha: boolean, _imodel: IModelConnection | undefined, _params: RenderTexture.Params): RenderTexture | undefined;
    createTextureFromImageBuffer(_image: ImageBuffer, _imodel: IModelConnection, _params: RenderTexture.Params): RenderTexture | undefined;
    createTextureFromImageSource(source: ImageSource, imodel: IModelConnection | undefined, params: RenderTexture.Params): Promise<RenderTexture | undefined>;
    // @internal (undocumented)
    createTile(tileTexture: RenderTexture, corners: Point3d[]): RenderGraphic | undefined;
    // @internal (undocumented)
    createTriMesh(args: MeshArgs, instances?: InstancedGraphicParams): RenderGraphic | undefined;
    // @internal (undocumented)
    abstract dispose(): void;
    // @internal (undocumented)
    enableDiagnostics(_enable: RenderDiagnostics): void;
    findMaterial(_key: string, _imodel: IModelConnection): RenderMaterial | undefined;
    findTexture(_key: string, _imodel: IModelConnection): RenderTexture | undefined;
    // @beta
    getGradientTexture(_symb: Gradient.Symb, _imodel: IModelConnection): RenderTexture | undefined;
    // @internal (undocumented)
    getSolarShadowMap(_frustum: Frustum, _direction: Vector3d, _settings: SolarShadows.Settings, _models: ModelSelectorState, _categories: CategorySelectorState, _imodel: IModelConnection): RenderSolarShadowMap | undefined;
    // @internal (undocumented)
    getSpatialClassificationModel(_classifierModelId: Id64String, _iModel: IModelConnection): RenderClassifierModel | undefined;
    // @internal (undocumented)
    abstract readonly isValid: boolean;
    // @internal
    loadTexture(id: Id64String, iModel: IModelConnection): Promise<RenderTexture | undefined>;
    // @internal
    loadTextureImage(id: Id64String, iModel: IModelConnection): Promise<TextureImage | undefined>;
    // @internal (undocumented)
    readonly maxTextureSize: number;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal
    readonly options: RenderSystem.Options;
    // @internal (undocumented)
    readonly supportsInstancing: boolean;
}

// @public
export namespace RenderSystem {
    // @beta
    export interface Options {
        // @internal
        cullAgainstActiveVolume?: boolean;
        // @internal
        disabledExtensions?: WebGLExtensionName[];
        // @internal
        displaySolarShadows?: boolean;
        // @internal
        enableOptimizedSurfaceShaders?: boolean;
        // @internal
        preserveShaderSourceCode?: boolean;
    }
}

// @internal
export abstract class RenderTarget implements IDisposable {
    // (undocumented)
    animationBranches: AnimationBranchStates | undefined;
    // (undocumented)
    abstract animationFraction: number;
    // (undocumented)
    abstract readonly cameraFrustumNearScaleLimit: number;
    // (undocumented)
    abstract changeBackgroundMap(_scene: GraphicList): void;
    // (undocumented)
    abstract changeDecorations(decorations: Decorations): void;
    // (undocumented)
    abstract changeDynamics(dynamics?: GraphicList): void;
    // (undocumented)
    changePlanarClassifiers(_classifiers?: PlanarClassifierMap): void;
    // (undocumented)
    abstract changeRenderPlan(plan: RenderPlan): void;
    // (undocumented)
    abstract changeScene(scene: GraphicList): void;
    // (undocumented)
    changeSolarShadowMap(_solarShadowMap?: RenderSolarShadowMap): void;
    // (undocumented)
    createGraphicBuilder(type: GraphicType, viewport: Viewport, placement?: Transform, pickableId?: Id64String): GraphicBuilder;
    static depthFromDisplayPriority(priority: number): number;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    abstract drawFrame(sceneMilSecElapsed?: number): void;
    // (undocumented)
    static readonly frustumDepth2d: number;
    // (undocumented)
    static readonly maxDisplayPriority: number;
    // (undocumented)
    static readonly minDisplayPriority: number;
    // (undocumented)
    onResized(): void;
    // (undocumented)
    overrideFeatureSymbology(_ovr: FeatureSymbology.Overrides): void;
    // (undocumented)
    pickOverlayDecoration(_pt: XAndY): CanvasDecoration | undefined;
    // (undocumented)
    readImage(_rect: ViewRect, _targetSize: Point2d, _flipVertically: boolean): ImageBuffer | undefined;
    // (undocumented)
    abstract readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable: boolean): void;
    // (undocumented)
    abstract readonly renderSystem: RenderSystem;
    // (undocumented)
    reset(): void;
    // (undocumented)
    setFlashed(_elementId: Id64String, _intensity: number): void;
    // (undocumented)
    setHiliteSet(_hilited: HiliteSet): void;
    // (undocumented)
    abstract setViewRect(_rect: ViewRect, _temporary: boolean): void;
    // (undocumented)
    readonly solarShadowMap: RenderSolarShadowMap | undefined;
    // (undocumented)
    abstract updateViewRect(): boolean;
    // (undocumented)
    abstract readonly viewRect: ViewRect;
    // (undocumented)
    abstract readonly wantInvertBlackBackground: boolean;
}

// @public
export class RotateViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha (undocumented)
export enum RotationMode {
    // (undocumented)
    ACS = 5,
    // (undocumented)
    Context = 6,
    // (undocumented)
    Front = 2,
    // (undocumented)
    Side = 3,
    // (undocumented)
    Top = 1,
    // (undocumented)
    View = 4
}

// @internal (undocumented)
export class RoundOff {
    // (undocumented)
    active: boolean;
    // (undocumented)
    units: Set<number>;
}

// @internal (undocumented)
export interface SavedClipCache {
    // (undocumented)
    clip?: ClipVector;
    // (undocumented)
    modified: boolean;
    // (undocumented)
    name?: string;
    // (undocumented)
    shared: boolean;
}

// @alpha (undocumented)
export interface SavedClipEntry {
    // (undocumented)
    id: GuidString;
    // (undocumented)
    name?: string;
    // (undocumented)
    shared: boolean;
}

// @internal (undocumented)
export interface SavedClipProps {
    // (undocumented)
    clip: ClipVector;
    // (undocumented)
    name?: string;
}

// @internal (undocumented)
export class SavedState {
    // (undocumented)
    auxRotationPlane: number;
    // (undocumented)
    readonly axes: ThreeAxes;
    // (undocumented)
    contextRotMode: number;
    // (undocumented)
    fixedOrg: boolean;
    // (undocumented)
    ignoreDataButton: boolean;
    // (undocumented)
    ignoreFlags: AccuDrawFlags;
    // (undocumented)
    mode: CompassMode;
    // (undocumented)
    readonly origin: Point3d;
    // (undocumented)
    rotationMode: RotationMode;
    // (undocumented)
    state: CurrentState;
}

// @internal
export class SceneContext extends RenderContext {
    constructor(vp: Viewport, frustum?: Frustum);
    // (undocumented)
    readonly backgroundGraphics: RenderGraphic[];
    // (undocumented)
    extendedFrustumPlane?: Plane3dByOriginAndUnitNormal;
    // (undocumented)
    getPlanarClassifier(id: Id64String): RenderPlanarClassifier | undefined;
    // (undocumented)
    getPlanarClassifierForModel(modelId: Id64String): RenderPlanarClassifier | undefined;
    // (undocumented)
    readonly graphics: RenderGraphic[];
    // (undocumented)
    hasMissingTiles: boolean;
    // (undocumented)
    insertMissingTile(tile: Tile): void;
    // (undocumented)
    readonly missingTiles: Set<Tile>;
    // (undocumented)
    modelClassifiers: Map<string, string>;
    // (undocumented)
    outputGraphic(graphic: RenderGraphic): void;
    // (undocumented)
    planarClassifiers?: PlanarClassifierMap;
    // (undocumented)
    requestMissingTiles(): void;
    // (undocumented)
    setPlanarClassifier(id: Id64String, planarClassifier: RenderPlanarClassifier): void;
    // (undocumented)
    solarShadowMap?: RenderSolarShadowMap;
    // (undocumented)
    tiledGraphicsProviderType: TiledGraphicsProvider.Type | undefined;
    // (undocumented)
    readonly viewFrustum: ViewFrustum | undefined;
}

// @public
export class ScreenViewport extends Viewport {
    // @internal
    constructor(canvas: HTMLCanvasElement, parentDiv: HTMLDivElement, target: RenderTarget);
    // @internal (undocumented)
    addDecorations(decorations: Decorations): void;
    // @internal (undocumented)
    addNewDiv(className: string, overflowHidden: boolean, z: number): HTMLDivElement;
    readonly canvas: HTMLCanvasElement;
    changeView(view: ViewState): void;
    clearViewUndo(): void;
    static create(parentDiv: HTMLDivElement, view: ViewState): ScreenViewport;
    readonly decorationDiv: HTMLDivElement;
    doRedo(animationTime?: BeDuration): void;
    doUndo(animationTime?: BeDuration): void;
    // @internal (undocumented)
    drawLocateCursor(context: DecorateContext, pt: Point3d, aperture: number, isLocateCircleOn: boolean, hit?: HitDetail): void;
    getClientRect(): ClientRect;
    readonly isRedoPossible: boolean;
    readonly isUndoPossible: boolean;
    maxUndoSteps: number;
    openToolTip(message: HTMLElement | string, location?: XAndY, options?: ToolTipOptions): void;
    readonly parentDiv: HTMLDivElement;
    // @internal (undocumented)
    pickCanvasDecoration(pt: XAndY): import("./render/System").CanvasDecoration | undefined;
    pickNearestVisibleGeometry(pickPoint: Point3d, radius: number, allowNonLocatable?: boolean, out?: Point3d): Point3d | undefined;
    // @internal
    static removeAllChildren(el: HTMLDivElement): void;
    resetUndo(): void;
    saveViewUndo(): void;
    setCursor(cursor?: string): void;
    setEventController(controller: EventController | undefined): void;
    // @internal
    static setToParentSize(div: HTMLElement): void;
    // @internal (undocumented)
    synchWithView(saveInUndo: boolean): void;
    readonly toolTipDiv: HTMLDivElement;
    // @internal (undocumented)
    viewCmdTargetCenter: Point3d | undefined;
    readonly viewRect: ViewRect;
    readonly vpDiv: HTMLDivElement;
}

// @public
export class ScrollViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export class SectionDrawingModelState extends DrawingModelState {
    // @internal (undocumented)
    static readonly className: string;
}

// @public
export interface SelectAddEvent {
    added: Id64Arg;
    set: SelectionSet;
    // (undocumented)
    type: SelectionSetEventType.Add;
}

// @public
export interface SelectedViewportChangedArgs {
    // (undocumented)
    current?: ScreenViewport;
    // (undocumented)
    previous?: ScreenViewport;
}

// @public
export enum SelectionMethod {
    Box = 2,
    Line = 1,
    Pick = 0
}

// @public
export enum SelectionMode {
    Add = 1,
    Remove = 2,
    Replace = 0
}

// @public
export enum SelectionProcessing {
    AddElementToSelection = 0,
    InvertElementInSelection = 2,
    RemoveElementFromSelection = 1,
    ReplaceSelectionWithElement = 3
}

// @public
export class SelectionSet {
    constructor(iModel: IModelConnection);
    add(elem: Id64Arg): boolean;
    addAndRemove(adds: Id64Arg, removes: Id64Arg): boolean;
    readonly elements: Set<string>;
    emptyAll(): void;
    has(elemId?: string): boolean;
    // (undocumented)
    iModel: IModelConnection;
    invert(elem: Id64Arg): boolean;
    readonly isActive: boolean;
    isSelected(elemId?: Id64String): boolean;
    readonly onChanged: BeEvent<(ev: SelectionSetEvent) => void>;
    remove(elem: Id64Arg): boolean;
    replace(elem: Id64Arg): void;
    readonly size: number;
}

// @public
export type SelectionSetEvent = SelectAddEvent | SelectRemoveEvent | SelectReplaceEvent;

// @public
export enum SelectionSetEventType {
    Add = 0,
    Clear = 3,
    Remove = 1,
    Replace = 2
}

// @public
export class SelectionTool extends PrimitiveTool {
    // @beta
    applyToolSettingPropertyChange(updatedValue: ToolSettingsPropertySyncItem): boolean;
    // (undocumented)
    autoLockTarget(): void;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    filterHit(hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus>;
    // (undocumented)
    static hidden: boolean;
    // (undocumented)
    protected initSelectTool(): void;
    // (undocumented)
    protected _isSelectByPoints: boolean;
    // (undocumented)
    protected _isSuspended: boolean;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onDataButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onModifierKeyTransition(_wentDown: boolean, modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onSuspend(): void;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected readonly _points: Point3d[];
    // (undocumented)
    processSelection(elementId: Id64Arg, process: SelectionProcessing): Promise<boolean>;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected selectByPointsEnd(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected selectByPointsProcess(origin: Point3d, corner: Point3d, ev: BeButtonEvent, method: SelectionMethod, overlap: boolean): void;
    // (undocumented)
    protected selectByPointsStart(ev: BeButtonEvent): boolean;
    // (undocumented)
    selectDecoration(ev: BeButtonEvent, currHit?: HitDetail): Promise<EventHandled>;
    // (undocumented)
    selectionMethod: SelectionMethod;
    // (undocumented)
    selectionMode: SelectionMode;
    // (undocumented)
    protected showPrompt(mode: SelectionMode, method: SelectionMethod): void;
    // (undocumented)
    static startTool(): boolean;
    // @beta
    supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    updateSelection(elementId: Id64Arg, process: SelectionProcessing): boolean;
    // (undocumented)
    protected useOverlapSelection(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected wantEditManipulators(): boolean;
    // (undocumented)
    protected wantPickableDecorations(): boolean;
    // (undocumented)
    protected wantSelectionClearOnMiss(_ev: BeButtonEvent): boolean;
    // (undocumented)
    protected wantToolSettings(): boolean;
}

// @public
export interface SelectRemoveEvent {
    removed: Id64Arg;
    set: SelectionSet;
    type: SelectionSetEventType.Remove | SelectionSetEventType.Clear;
}

// @public
export interface SelectReplaceEvent {
    added: Id64Arg;
    removed: Id64Arg;
    set: SelectionSet;
    // (undocumented)
    type: SelectionSetEventType.Replace;
}

// @internal
export class SheetBorder {
    addToBuilder(builder: GraphicBuilder): void;
    static create(width: number, height: number, context?: DecorateContext): SheetBorder;
    // (undocumented)
    getRange(): Range2d;
    }

// @public
export class SheetModelState extends GeometricModel2dState {
    // @internal (undocumented)
    static readonly className: string;
}

// @public
export class SheetViewState extends ViewState2d {
    constructor(props: ViewDefinition2dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle2dState, sheetProps: SheetProps, attachments: Id64Array);
    // @internal (undocumented)
    static readonly className: string;
    // @internal (undocumented)
    computeFitRange(): Range3d;
    // (undocumented)
    static createFromProps(viewStateData: ViewStateProps, iModel: IModelConnection): ViewState | undefined;
    // @internal
    createScene(context: SceneContext): void;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    readonly defaultExtentLimits: {
        min: number;
        max: number;
    };
    // @internal
    load(): Promise<void>;
    // @internal
    markAttachment3dSceneIncomplete(): void;
    // @internal
    onRenderFrame(_viewport: Viewport): void;
    readonly sheetSize: Point2d;
}

// @public
export abstract class SkyBox implements SkyBoxProps {
    protected constructor(sky?: SkyBoxProps);
    static createFromJSON(json?: SkyBoxProps): SkyBox;
    display: boolean;
    // @internal (undocumented)
    abstract loadParams(_system: RenderSystem, _iModel: IModelConnection): SkyBoxParams;
    // (undocumented)
    toJSON(): SkyBoxProps;
}

// @public
export namespace SkyBox {
    export class CreateParams {
        // (undocumented)
        static createForCube(cube: RenderTexture): CreateParams;
        // (undocumented)
        static createForGradient(gradient: SkyGradient, zOffset: number): CreateParams;
        // (undocumented)
        static createForSphere(sphere: SphereParams, zOffset: number): CreateParams;
        // (undocumented)
        readonly cube?: RenderTexture;
        // (undocumented)
        readonly gradient?: SkyGradient;
        // (undocumented)
        readonly sphere?: SphereParams;
        // (undocumented)
        readonly zOffset: number;
    }
    export class SphereParams {
        constructor(texture: RenderTexture, rotation: number);
        // (undocumented)
        readonly rotation: number;
        // (undocumented)
        readonly texture: RenderTexture;
    }
}

// @internal
export type SkyBoxParams = Promise<SkyBox.CreateParams | undefined> | SkyBox.CreateParams | undefined;

// @public
export class SkyCube extends SkyBox implements SkyCubeProps {
    readonly back: Id64String;
    readonly bottom: Id64String;
    static create(front: Id64String, back: Id64String, top: Id64String, bottom: Id64String, right: Id64String, left: Id64String, display?: boolean): SkyCube | undefined;
    // @internal
    static fromJSON(skyboxJson: SkyBoxProps): SkyCube | undefined;
    readonly front: Id64String;
    readonly left: Id64String;
    // @internal (undocumented)
    loadParams(system: RenderSystem, iModel: IModelConnection): SkyBoxParams;
    readonly right: Id64String;
    // (undocumented)
    toJSON(): SkyBoxProps;
    readonly top: Id64String;
}

// @public
export class SkyGradient extends SkyBox {
    constructor(sky?: SkyBoxProps);
    readonly groundColor: ColorDef;
    readonly groundExponent: number;
    // @internal (undocumented)
    loadParams(_system: RenderSystem, iModel: IModelConnection): SkyBoxParams;
    readonly nadirColor: ColorDef;
    readonly skyColor: ColorDef;
    readonly skyExponent: number;
    // (undocumented)
    toJSON(): SkyBoxProps;
    readonly twoColor: boolean;
    readonly zenithColor: ColorDef;
}

// @public
export class SkySphere extends SkyBox {
    static fromJSON(json: SkyBoxProps): SkySphere | undefined;
    // @internal (undocumented)
    loadParams(system: RenderSystem, iModel: IModelConnection): SkyBoxParams;
    textureId: Id64String;
    // (undocumented)
    toJSON(): SkyBoxProps;
}

// @alpha
export interface SliderEditorParams extends BasePropertyEditorParams {
    intervals?: boolean;
    maximum: number;
    minimum: number;
    numButtons?: number;
    // (undocumented)
    type: PropertyEditorParamTypes.Slider;
    valueFactor?: number;
    vertical?: boolean;
}

// @public
export class SnapDetail extends HitDetail {
    constructor(from: HitDetail, snapMode?: SnapMode, heat?: SnapHeat, snapPoint?: XYZProps);
    readonly adjustedPoint: Point3d;
    clone(): SnapDetail;
    // (undocumented)
    draw(context: DecorateContext): void;
    geomType?: HitGeomType;
    // (undocumented)
    getCurvePrimitive(singleSegment?: boolean): CurvePrimitive | undefined;
    getHitType(): HitDetailType;
    getPoint(): Point3d;
    // (undocumented)
    heat: SnapHeat;
    readonly isHot: boolean;
    readonly isPointAdjusted: boolean;
    normal?: Vector3d;
    parentGeomType?: HitParentGeomType;
    primitive?: CurvePrimitive;
    setCurvePrimitive(primitive?: CurvePrimitive, localToWorld?: Transform, geomType?: HitGeomType): void;
    setSnapPoint(point: Point3d, heat: SnapHeat): void;
    // (undocumented)
    snapMode: SnapMode;
    readonly snapPoint: Point3d;
    sprite?: Sprite;
}

// @public (undocumented)
export enum SnapHeat {
    // (undocumented)
    InRange = 2,
    // (undocumented)
    None = 0,
    // (undocumented)
    NotInRange = 1
}

// @public (undocumented)
export enum SnapMode {
    // (undocumented)
    Bisector = 32,
    // (undocumented)
    Center = 8,
    // (undocumented)
    Intersection = 64,
    // (undocumented)
    MidPoint = 4,
    // (undocumented)
    Nearest = 1,
    // (undocumented)
    NearestKeypoint = 2,
    // (undocumented)
    Origin = 16
}

// @public (undocumented)
export enum SnapStatus {
    // (undocumented)
    Aborted = 1,
    // (undocumented)
    Disabled = 100,
    // (undocumented)
    FilteredByApp = 600,
    // (undocumented)
    FilteredByAppQuietly = 700,
    // (undocumented)
    NoElements = 2,
    // (undocumented)
    NoSnapPossible = 200,
    // (undocumented)
    NotSnappable = 300,
    // (undocumented)
    Success = 0
}

// @beta
export namespace SpatialClassification {
    // @internal (undocumented)
    export function addModelClassifierToScene(classifiedModel: TileTreeModelState, context: SceneContext): void;
    // @alpha
    export function addSpatialClassifier(model: TileTreeModelState, classifier: SpatialClassificationProps.PropertiesProps): void;
    // @internal (undocumented)
    export function createClassifier(id: Id64String, iModel: IModelConnection): Promise<RenderClassifierModel | undefined>;
    // @alpha
    export function getActiveSpatialClassifier(model: TileTreeModelState): number;
    // @internal (undocumented)
    export function getClassifierProps(model: TileTreeModelState): SpatialClassificationProps.Properties | undefined;
    // @alpha
    export function getSpatialClassifier(model: TileTreeModelState, index: number): SpatialClassificationProps.Properties | undefined;
    // @internal (undocumented)
    export function loadClassifiers(classifierIdArg: Id64Arg, iModel: IModelConnection): Promise<void>;
    // @internal (undocumented)
    export function loadModelClassifiers(modelIdArg: Id64Arg, iModel: IModelConnection): Promise<void>;
    // @alpha
    export function setActiveSpatialClassifier(model: TileTreeModelState, classifierIndex: number, active: boolean): Promise<void>;
    // @alpha
    export function setSpatialClassifier(model: TileTreeModelState, index: number, classifier: SpatialClassificationProps.Properties): void;
}

// @public
export class SpatialLocationModelState extends SpatialModelState {
    // @internal (undocumented)
    static readonly className: string;
}

// @public
export class SpatialModelState extends GeometricModel3dState {
    // @internal (undocumented)
    static readonly className: string;
}

// @public
export class SpatialViewState extends ViewState3d {
    constructor(props: SpatialViewDefinitionProps, iModel: IModelConnection, arg3: CategorySelectorState, displayStyle: DisplayStyle3dState, modelSelector: ModelSelectorState);
    // (undocumented)
    addViewedModel(id: Id64String): void;
    // @internal (undocumented)
    static readonly className: string;
    // (undocumented)
    clearViewedModels(): void;
    // (undocumented)
    computeFitRange(): AxisAlignedBox3d;
    // (undocumented)
    createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    // (undocumented)
    static createFromProps(props: ViewStateProps, iModel: IModelConnection): ViewState | undefined;
    // @internal (undocumented)
    createSolarShadowMap(context: SceneContext): void;
    // (undocumented)
    readonly defaultExtentLimits: {
        min: number;
        max: number;
    };
    // (undocumented)
    equals(other: this): boolean;
    // (undocumented)
    forEachModel(func: (model: GeometricModelState) => void): void;
    // @alpha (undocumented)
    forEachTileTreeModel(func: (model: TileTreeModelState) => void): void;
    // (undocumented)
    getViewedExtents(): AxisAlignedBox3d;
    // (undocumented)
    load(): Promise<void>;
    // (undocumented)
    modelSelector: ModelSelectorState;
    // (undocumented)
    removeViewedModel(id: Id64String): void;
    // (undocumented)
    toJSON(): SpatialViewDefinitionProps;
    // (undocumented)
    viewsModel(modelId: Id64String): boolean;
}

// @public
export class Sprite {
    constructor(src: ImageSource | string);
    image?: HTMLImageElement;
    readonly isLoaded: boolean;
    loadPromise: Promise<HTMLImageElement>;
    readonly offset: Point2d;
    readonly size: Point2d;
}

// @public
export class SpriteLocation implements CanvasDecoration {
    activate(sprite: Sprite, viewport: ScreenViewport, locationWorld: XYAndZ, alpha?: number): void;
    deactivate(): void;
    decorate(context: DecorateContext): void;
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    // (undocumented)
    readonly isActive: boolean;
    readonly position: Point3d;
    }

// @public
export class StandardView {
    static adjustToStandardRotation(matrix: Matrix3d): void;
    // (undocumented)
    static readonly back: Matrix3d;
    // (undocumented)
    static readonly bottom: Matrix3d;
    // (undocumented)
    static readonly front: Matrix3d;
    static getStandardRotation(id: StandardViewId): Matrix3d;
    // (undocumented)
    static readonly iso: Matrix3d;
    // (undocumented)
    static readonly left: Matrix3d;
    // (undocumented)
    static readonly right: Matrix3d;
    // (undocumented)
    static readonly rightIso: Matrix3d;
    // (undocumented)
    static readonly top: Matrix3d;
}

// @public
export enum StandardViewId {
    // (undocumented)
    Back = 5,
    // (undocumented)
    Bottom = 1,
    // (undocumented)
    Front = 4,
    // (undocumented)
    Iso = 6,
    // (undocumented)
    Left = 2,
    NotStandard = -1,
    // (undocumented)
    Right = 3,
    // (undocumented)
    RightIso = 7,
    // (undocumented)
    Top = 0
}

// @public
export class StandardViewTool extends ViewTool {
    constructor(viewport: ScreenViewport, _standardViewId: StandardViewId);
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @public (undocumented)
export enum StartOrResume {
    // (undocumented)
    Resume = 2,
    // (undocumented)
    Start = 1
}

// @beta
export interface StructValue extends BasePropertyValue {
    // (undocumented)
    members: {
        [name: string]: PropertyRecord;
    };
    // (undocumented)
    valueFormat: PropertyValueFormat.Struct;
}

// @internal
export class SubCategoriesCache {
    constructor(imodel: IModelConnection);
    // (undocumented)
    clear(): void;
    getSubCategories(categoryId: string): Id64Set | undefined;
    getSubCategoryAppearance(subCategoryId: Id64String): SubCategoryAppearance | undefined;
    load(categoryIds: Id64Arg): SubCategoriesRequest | undefined;
    // (undocumented)
    onIModelConnectionClose(): void;
    }

// @internal
export namespace SubCategoriesCache {
    export class Queue {
        // (undocumented)
        protected _current?: QueueEntry;
        dispose(): void;
        // (undocumented)
        protected _disposed: boolean;
        // (undocumented)
        readonly isEmpty: boolean;
        // (undocumented)
        protected _next?: QueueEntry;
        push(cache: SubCategoriesCache, categoryIds: Id64Arg, func: QueueFunc): void;
        // (undocumented)
        protected _request?: SubCategoriesRequest;
    }
    // (undocumented)
    export class QueueEntry {
        constructor(categoryIds: Id64Set, func: QueueFunc);
        // (undocumented)
        readonly categoryIds: Id64Set;
        // (undocumented)
        readonly funcs: QueueFunc[];
    }
    // (undocumented)
    export type QueueFunc = () => void;
    // (undocumented)
    export class Request {
        constructor(categoryIds: Set<string>, imodel: IModelConnection, maxCategoriesPerQuery?: number);
        // (undocumented)
        cancel(): void;
        // (undocumented)
        dispatch(): Promise<Result | undefined>;
        // (undocumented)
        readonly wasCanceled: boolean;
    }
    // (undocumented)
    export type Result = ResultRow[];
    // (undocumented)
    export interface ResultRow {
        // (undocumented)
        appearance: SubCategoryAppearance.Props;
        // (undocumented)
        id: Id64String;
        // (undocumented)
        parentId: Id64String;
    }
}

// @internal
export interface SubCategoriesRequest {
    cancel(): void;
    readonly missingCategoryIds: Id64Set;
    readonly promise: Promise<boolean>;
}

// @alpha
export interface SuppressLabelEditorParams extends BasePropertyEditorParams {
    suppressLabelPlaceholder?: boolean;
    // (undocumented)
    type: PropertyEditorParamTypes.SuppressEditorLabel;
}

// @alpha
export interface SuppressUnitLabelEditorParams extends BasePropertyEditorParams {
    // (undocumented)
    type: PropertyEditorParamTypes.SuppressUnitLabel;
}

// @internal (undocumented)
export class SuspendedToolState {
    constructor();
    // (undocumented)
    stop(): void;
    }

// @internal
export class SyncFlags {
    // (undocumented)
    initFrom(other: SyncFlags): void;
    // (undocumented)
    invalidateAnimationFraction(): void;
    // (undocumented)
    invalidateController(): void;
    // (undocumented)
    invalidateDecorations(): void;
    // (undocumented)
    invalidateRedrawPending(): void;
    // (undocumented)
    invalidateRenderPlan(): void;
    // (undocumented)
    invalidateRotatePoint(): void;
    // (undocumented)
    invalidateScene(): void;
    // (undocumented)
    readonly isRedrawPending: boolean;
    // (undocumented)
    readonly isValidAnimationFraction: boolean;
    // (undocumented)
    readonly isValidController: boolean;
    // (undocumented)
    readonly isValidDecorations: boolean;
    // (undocumented)
    readonly isValidRenderPlan: boolean;
    // (undocumented)
    readonly isValidRotatePoint: boolean;
    // (undocumented)
    readonly isValidScene: boolean;
    // (undocumented)
    setRedrawPending(): void;
    // (undocumented)
    setValidAnimationFraction(): void;
    // (undocumented)
    setValidController(): void;
    // (undocumented)
    setValidDecorations(): void;
    // (undocumented)
    setValidRenderPlan(): void;
    // (undocumented)
    setValidRotatePoint(): void;
    // (undocumented)
    setValidScene(): void;
}

// @internal (undocumented)
export abstract class Target extends RenderTarget {
    protected constructor(rect?: ViewRect);
    // (undocumented)
    addBatch(batch: Batch): void;
    // (undocumented)
    readonly ambientLight: Float32Array;
    // (undocumented)
    ambientOcclusionSettings: AmbientOcclusion.Settings;
    // (undocumented)
    analysisStyle?: AnalysisStyle;
    // (undocumented)
    analysisTexture?: RenderTexture;
    // (undocumented)
    animationBranches: AnimationBranchStates | undefined;
    // (undocumented)
    protected abstract _assignDC(): boolean;
    // (undocumented)
    readonly batchState: BatchState;
    // (undocumented)
    protected abstract _beginPaint(): void;
    // (undocumented)
    readonly bgColor: FloatRgba;
    // (undocumented)
    readonly branchStack: BranchStack;
    // (undocumented)
    readonly cameraFrustumNearScaleLimit: number;
    // (undocumented)
    changeBackgroundMap(backgroundMap: GraphicList): void;
    // (undocumented)
    changeDecorations(decs: Decorations): void;
    // (undocumented)
    changeDynamics(dynamics?: GraphicList): void;
    // (undocumented)
    changeFrustum(newFrustum: Frustum, newFraction: number, is3d: boolean): void;
    // (undocumented)
    changePlanarClassifiers(planarClassifiers?: PlanarClassifierMap): void;
    // (undocumented)
    changeRenderPlan(plan: RenderPlan): void;
    // (undocumented)
    changeScene(scene: GraphicList): void;
    // (undocumented)
    changeSolarShadowMap(solarShadowMap?: RenderSolarShadowMap): void;
    // (undocumented)
    readonly clipDef: ClipDef;
    // (undocumented)
    clipMask: TextureHandle | undefined;
    // (undocumented)
    readonly clips: Clips;
    // (undocumented)
    readonly compositor: SceneCompositor;
    // (undocumented)
    protected _compositor: SceneCompositor;
    // (undocumented)
    readonly currentBatchId: number;
    // (undocumented)
    readonly currentFeatureSymbologyOverrides: FeatureSymbology.Overrides;
    // (undocumented)
    currentOverrides: FeatureOverrides | undefined;
    // (undocumented)
    readonly currentShaderFlags: ShaderFlags;
    // (undocumented)
    readonly currentTransform: Transform;
    // (undocumented)
    readonly currentViewFlags: ViewFlags;
    // (undocumented)
    protected _dcAssigned: boolean;
    // (undocumented)
    protected debugPaint(): void;
    // (undocumented)
    protected _decorations?: Decorations;
    // (undocumented)
    readonly decorationState: BranchState;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    drawFrame(sceneMilSecElapsed?: number): void;
    // (undocumented)
    readonly drawNonLocatable: boolean;
    // (undocumented)
    protected drawOverlayDecorations(): void;
    // (undocumented)
    drawPlanarClassifiers(): void;
    // (undocumented)
    drawSolarShadowMap(): void;
    // (undocumented)
    readonly dynamics: GraphicList | undefined;
    // (undocumented)
    readonly edgeColor: ColorInfo;
    // (undocumented)
    protected abstract _endPaint(): void;
    // (undocumented)
    protected _fbo?: FrameBuffer;
    // (undocumented)
    readonly flashed: Id64.Uint32Pair | undefined;
    // (undocumented)
    readonly flashedId: Id64String;
    // (undocumented)
    readonly flashedUpdateTime: BeTimePoint;
    // (undocumented)
    readonly flashIntensity: number;
    // (undocumented)
    readonly frustumUniforms: FrustumUniforms;
    // (undocumented)
    readonly fStop: number;
    // (undocumented)
    getEdgeLineCode(params: ShaderProgramParams, baseCode: number): number;
    // (undocumented)
    getEdgeOverrides(pass: RenderPass): EdgeOverrides | undefined;
    // (undocumented)
    getEdgeWeight(params: ShaderProgramParams, baseWeight: number): number;
    // (undocumented)
    getWorldDecorations(decs: GraphicList): Branch;
    // (undocumented)
    readonly hasClipMask: boolean;
    // (undocumented)
    readonly hasClipVolume: boolean;
    // (undocumented)
    readonly hiddenEdgeOverrides: EdgeOverrides | undefined;
    // (undocumented)
    hiliteColor: FloatRgba;
    // (undocumented)
    readonly hilites: Hilites;
    // (undocumented)
    hiliteSettings: Hilite.Settings;
    // (undocumented)
    readonly hiliteUpdateTime: BeTimePoint;
    // (undocumented)
    readonly is2d: boolean;
    // (undocumented)
    readonly is3d: boolean;
    // (undocumented)
    readonly isEdgeColorOverridden: boolean;
    // (undocumented)
    readonly isEdgeWeightOverridden: boolean;
    // (undocumented)
    isFadeOutActive: boolean;
    // (undocumented)
    isGeometryOutsideActiveVolume(geom: CachedGeometry): boolean;
    // (undocumented)
    isRangeOutsideActiveVolume(range: Range3d): boolean;
    // (undocumented)
    readonly isReadPixelsInProgress: boolean;
    // (undocumented)
    readonly monoColor: FloatRgba;
    // (undocumented)
    readonly nearPlaneCenter: Point3d;
    // (undocumented)
    onBatchDisposed(batch: Batch): void;
    // (undocumented)
    overrideFeatureSymbology(ovr: FeatureSymbology.Overrides): void;
    // (undocumented)
    readonly overridesUpdateTime: BeTimePoint;
    // (undocumented)
    performanceMetrics?: PerformanceMetrics;
    // (undocumented)
    plan?: RenderPlan;
    // (undocumented)
    readonly planarClassifiers: PlanarClassifiers;
    // (undocumented)
    readonly planFraction: number;
    // (undocumented)
    readonly planFrustum: Frustum;
    // (undocumented)
    popActiveVolume(): void;
    // (undocumented)
    popBatch(): void;
    // (undocumented)
    popBranch(): void;
    // (undocumented)
    primitiveVisibility: PrimitiveVisibility;
    // (undocumented)
    readonly projectionMatrix: Matrix4d;
    // (undocumented)
    pushActiveVolume(): void;
    // (undocumented)
    pushBatch(batch: Batch): void;
    // (undocumented)
    pushBranch(exec: ShaderProgramExecutor, branch: Branch): void;
    // (undocumented)
    pushState(state: BranchState): void;
    // (undocumented)
    readImage(wantRectIn: ViewRect, targetSizeIn: Point2d, flipVertically: boolean): ImageBuffer | undefined;
    // (undocumented)
    protected readImagePixels(out: Uint8Array, x: number, y: number, w: number, h: number): boolean;
    // (undocumented)
    readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable: boolean): void;
    // (undocumented)
    readonly readPixelsSelector: Pixel.Selector;
    // (undocumented)
    recordPerformanceMetric(operation: string): void;
    // (undocumented)
    readonly renderRect: ViewRect;
    // (undocumented)
    readonly renderSystem: RenderSystem;
    // (undocumented)
    reset(): void;
    // (undocumented)
    readonly scene: GraphicList;
    // (undocumented)
    setFlashed(id: Id64String, intensity: number): void;
    // (undocumented)
    setHiliteSet(hilite: HiliteSet): void;
    // (undocumented)
    readonly shaderLights: ShaderLights | undefined;
    // (undocumented)
    readonly solarShadowMap: SolarShadowMap | undefined;
    // (undocumented)
    readonly techniques: Techniques;
    // (undocumented)
    readonly transparencyThreshold: number;
    // (undocumented)
    readonly viewMatrix: Transform;
    // (undocumented)
    readonly visibleEdgeOverrides: EdgeOverrides | undefined;
    // (undocumented)
    readonly wantAmbientOcclusion: boolean;
    // (undocumented)
    readonly wantInvertBlackBackground: boolean;
    }

// @internal (undocumented)
export class TentativeOrAccuSnap {
    // (undocumented)
    static getCurrentPoint(): Point3d;
    // (undocumented)
    static getCurrentSnap(checkIsHot?: boolean): SnapDetail | undefined;
    // (undocumented)
    static getCurrentView(): ScreenViewport | undefined;
    // (undocumented)
    static readonly isHot: boolean;
}

// @public (undocumented)
export class TentativePoint {
    // (undocumented)
    clear(doErase: boolean): void;
    // (undocumented)
    currSnap?: SnapDetail;
    // (undocumented)
    decorate(context: DecorateContext): void;
    getCurrSnap(): SnapDetail | undefined;
    // (undocumented)
    getHitAndList(holder: HitListHolder): SnapDetail | undefined;
    // (undocumented)
    getPoint(): Point3d;
    // (undocumented)
    isActive: boolean;
    readonly isSnapped: boolean;
    // (undocumented)
    onButtonEvent(ev: BeButtonEvent): void;
    // (undocumented)
    onInitialized(): void;
    // (undocumented)
    process(ev: BeButtonEvent): void;
    // (undocumented)
    removeTentative(): void;
    // (undocumented)
    setCurrSnap(newSnap?: SnapDetail): void;
    // (undocumented)
    setHitList(list?: HitList<HitDetail>): void;
    // (undocumented)
    setPoint(point: Point3d): void;
    // (undocumented)
    showTentative(): void;
    // (undocumented)
    tpHits?: HitList<HitDetail>;
    // (undocumented)
    viewport?: ScreenViewport;
}

// @internal
export abstract class TerrainProvider implements TiledGraphicsProvider.Provider {
    // (undocumented)
    abstract getTileTree(viewport: Viewport): TiledGraphicsProvider.Tree | undefined;
    // (undocumented)
    onInitialized(): void;
}

// @internal
export interface TextureImage {
    format: ImageSourceFormat | undefined;
    image: HTMLImageElement | undefined;
}

// @internal (undocumented)
export class ThreeAxes {
    // (undocumented)
    clone(): ThreeAxes;
    // (undocumented)
    static createFromMatrix3d(rMatrix: Matrix3d, result?: ThreeAxes): ThreeAxes;
    // (undocumented)
    equals(other: ThreeAxes): boolean;
    // (undocumented)
    fromMatrix3d(rMatrix: Matrix3d): void;
    // (undocumented)
    setFrom(other: ThreeAxes): void;
    // (undocumented)
    toMatrix3d(out?: Matrix3d): Matrix3d;
    // (undocumented)
    readonly x: Vector3d;
    // (undocumented)
    readonly y: Vector3d;
    // (undocumented)
    readonly z: Vector3d;
}

// @internal
export class Tile implements IDisposable, RenderMemory.Consumer {
    constructor(props: Tile.Params);
    // (undocumented)
    readonly center: Point3d;
    // (undocumented)
    readonly children: Tile[] | undefined;
    // (undocumented)
    protected _children?: Tile[];
    // (undocumented)
    protected _childrenLastUsed: BeTimePoint;
    // (undocumented)
    protected _childrenLoadStatus: TileTree.LoadStatus;
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    computeVisibility(args: Tile.DrawArgs): Tile.Visibility;
    computeWorldContentRange(): ElementAlignedBox3d;
    // (undocumented)
    contentId: string;
    // (undocumented)
    readonly contentRange: ElementAlignedBox3d;
    // (undocumented)
    protected _contentRange?: ElementAlignedBox3d;
    // (undocumented)
    debugDump(): string;
    // (undocumented)
    readonly depth: number;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    drawGraphics(args: Tile.DrawArgs): void;
    // (undocumented)
    readonly emptySubRangeMask: number;
    // (undocumented)
    protected _emptySubRangeMask?: number;
    // (undocumented)
    protected _graphic?: RenderGraphic;
    // (undocumented)
    readonly graphics: RenderGraphic | undefined;
    // (undocumented)
    readonly hasChildren: boolean;
    // (undocumented)
    readonly hasContentRange: boolean;
    // (undocumented)
    readonly hasGraphics: boolean;
    // (undocumented)
    readonly hasSizeMultiplier: boolean;
    // (undocumented)
    readonly iModel: IModelConnection;
    // (undocumented)
    isContentCulled(args: Tile.DrawArgs): boolean;
    // (undocumented)
    readonly isDisplayable: boolean;
    // (undocumented)
    readonly isEmpty: boolean;
    // (undocumented)
    readonly isLeaf: boolean;
    // (undocumented)
    protected _isLeaf: boolean;
    // (undocumented)
    readonly isLoading: boolean;
    // (undocumented)
    readonly isNotFound: boolean;
    // (undocumented)
    readonly isParentDisplayable: boolean;
    // (undocumented)
    readonly isReady: boolean;
    // (undocumented)
    isRegionCulled(args: Tile.DrawArgs): boolean;
    // (undocumented)
    readonly isUndisplayableRootTile: boolean;
    // (undocumented)
    readonly loader: TileLoader;
    // (undocumented)
    readonly loadStatus: Tile.LoadStatus;
    // (undocumented)
    protected _localContentRange?: ElementAlignedBox3d;
    // (undocumented)
    protected _localRange?: ElementAlignedBox3d;
    // (undocumented)
    readonly maximumSize: number;
    // (undocumented)
    protected _maximumSize: number;
    // (undocumented)
    readonly parent: Tile | undefined;
    // (undocumented)
    readonly radius: number;
    // (undocumented)
    readonly range: ElementAlignedBox3d;
    // (undocumented)
    protected _rangeGraphic?: RenderGraphic;
    // (undocumented)
    protected _rangeGraphicType: Tile.DebugBoundingBoxes;
    // (undocumented)
    request: TileRequest | undefined;
    // (undocumented)
    protected _request?: TileRequest;
    // (undocumented)
    readonly root: TileTree;
    // (undocumented)
    selectTiles(selected: Tile[], args: Tile.DrawArgs, numSkipped?: number): Tile.SelectParent;
    // (undocumented)
    setAbandoned(): void;
    // (undocumented)
    setContent(content: Tile.Content): void;
    // (undocumented)
    setIsReady(): void;
    // (undocumented)
    setNotFound(): void;
    // (undocumented)
    readonly sizeMultiplier: number;
    // (undocumented)
    protected _sizeMultiplier?: number;
    // (undocumented)
    readonly transformToRoot?: Transform;
    // (undocumented)
    protected _transformToRoot?: Transform;
    // (undocumented)
    protected unloadChildren(olderThan?: BeTimePoint): void;
    // (undocumented)
    readonly yAxisUp: boolean;
}

// @internal (undocumented)
export namespace Tile {
    export interface Content {
        contentRange?: ElementAlignedBox3d;
        emptySubRangeMask?: number;
        graphic?: RenderGraphic;
        isLeaf?: boolean;
        sizeMultiplier?: number;
    }
    export const enum DebugBoundingBoxes {
        Both = 3,
        ChildVolumes = 4,
        Content = 2,
        None = 0,
        Sphere = 5,
        Volume = 1
    }
    export class DrawArgs {
        constructor(context: SceneContext, location: Transform, root: TileTree, now: BeTimePoint, purgeOlderThan: BeTimePoint, clip?: RenderClipVolume);
        // (undocumented)
        readonly clip: ClipVector | undefined;
        // (undocumented)
        clipVolume?: RenderClipVolume;
        // (undocumented)
        readonly context: SceneContext;
        // (undocumented)
        drawGraphics(): void;
        // (undocumented)
        readonly frustumPlanes: FrustumPlanes;
        // (undocumented)
        getPixelSizeAtPoint(inPoint?: Point3d): number;
        // (undocumented)
        getTileCenter(tile: Tile): Point3d;
        // (undocumented)
        getTileRadius(tile: Tile): number;
        // (undocumented)
        readonly graphics: GraphicBranch;
        // (undocumented)
        insertMissing(tile: Tile): void;
        // (undocumented)
        readonly location: Transform;
        // (undocumented)
        markChildrenLoading(): void;
        // (undocumented)
        readonly now: BeTimePoint;
        // (undocumented)
        planarClassifier?: RenderPlanarClassifier;
        // (undocumented)
        readonly purgeOlderThan: BeTimePoint;
        // (undocumented)
        readonly root: TileTree;
        // (undocumented)
        readonly tileSizeModifier: number;
        // (undocumented)
        readonly viewClip?: ClipVector;
        // (undocumented)
        viewFrustum?: ViewFrustum;
    }
    export const enum LoadPriority {
        Background = 3,
        Classifier = 2,
        Context = 1,
        Primary = 0
    }
    export const enum LoadStatus {
        // (undocumented)
        Abandoned = 5,
        // (undocumented)
        Loading = 2,
        // (undocumented)
        NotFound = 4,
        // (undocumented)
        NotLoaded = 0,
        // (undocumented)
        Queued = 1,
        // (undocumented)
        Ready = 3
    }
    export interface Params {
        // (undocumented)
        readonly contentId: string;
        // (undocumented)
        readonly contentRange?: ElementAlignedBox3d;
        // (undocumented)
        readonly isLeaf?: boolean;
        // (undocumented)
        readonly maximumSize: number;
        // (undocumented)
        readonly parent?: Tile;
        // (undocumented)
        readonly range: ElementAlignedBox3d;
        // (undocumented)
        readonly root: TileTree;
        // (undocumented)
        readonly sizeMultiplier?: number;
        // (undocumented)
        readonly transformToRoot?: Transform;
    }
    // (undocumented)
    export function paramsFromJSON(props: TileProps, root: TileTree, parent?: Tile): Params;
    export const enum SelectParent {
        // (undocumented)
        No = 0,
        // (undocumented)
        Yes = 1
    }
    export const enum Visibility {
        // (undocumented)
        OutsideFrustum = 0,
        // (undocumented)
        TooCoarse = 1,
        // (undocumented)
        Visible = 2
    }
}

// @alpha
export abstract class TileAdmin {
    // @beta
    static create(props?: TileAdmin.Props): TileAdmin;
    // @internal (undocumented)
    abstract readonly emptyViewportSet: TileAdmin.ViewportSet;
    // @internal (undocumented)
    abstract readonly enableInstancing: boolean;
    // @internal
    abstract forgetViewport(vp: Viewport): void;
    // @internal
    abstract getMaximumMajorTileFormatVersion(formatVersion?: number): number;
    abstract getNumRequestsForViewport(vp: Viewport): number;
    // @internal
    abstract getViewportSet(vp: Viewport, vps?: TileAdmin.ViewportSet): TileAdmin.ViewportSet;
    abstract maxActiveRequests: number;
    // @internal (undocumented)
    abstract onShutDown(): void;
    // @internal (undocumented)
    abstract onTileCompleted(tile: Tile): void;
    // @internal (undocumented)
    abstract onTileElided(): void;
    // @internal (undocumented)
    abstract onTileFailed(tile: Tile): void;
    // @internal (undocumented)
    abstract onTileTimedOut(tile: Tile): void;
    // @internal
    abstract process(): void;
    // @internal (undocumented)
    abstract requestTileContent(iModel: IModelConnection, treeId: string, contentId: string): Promise<Uint8Array>;
    // @internal
    abstract requestTiles(vp: Viewport, tiles: Set<Tile>): void;
    // @internal (undocumented)
    abstract requestTileTreeProps(iModel: IModelConnection, treeId: string): Promise<TileTreeProps>;
    abstract resetStatistics(): void;
    abstract readonly statistics: TileAdmin.Statistics;
    // @internal (undocumented)
    abstract readonly tileExpirationTime: BeDuration;
    // @internal (undocumented)
    abstract readonly useProjectExtents: boolean;
}

// @alpha (undocumented)
export namespace TileAdmin {
    export interface Props {
        disableThrottling?: boolean;
        enableInstancing?: boolean;
        maxActiveRequests?: number;
        // @internal
        maximumMajorTileFormatVersion?: number;
        retryInterval?: number;
        tileExpirationTime?: number;
        // @internal
        useProjectExtents?: boolean;
    }
    export interface Statistics {
        numActiveRequests: number;
        numCanceled: number;
        numPendingRequests: number;
        totalCompletedRequests: number;
        totalElidedTiles: number;
        totalEmptyTiles: number;
        totalFailedRequests: number;
        totalTimedOutRequests: number;
        totalUndisplayableTiles: number;
    }
    // @internal
    export class ViewportSet extends SortedArray<Viewport> {
        constructor(vp?: Viewport);
        // (undocumented)
        clone(out?: ViewportSet): ViewportSet;
    }
}

// @internal (undocumented)
export namespace TiledGraphicsProvider {
    export interface Provider {
        // (undocumented)
        getTileTree(viewport: Viewport): TiledGraphicsProvider.Tree | undefined;
    }
    export type ProviderSet = Set<TiledGraphicsProvider.Provider>;
    export interface Tree {
        // (undocumented)
        plane?: Plane3dByOriginAndUnitNormal;
        // (undocumented)
        tileTree: TileTree;
    }
    export enum Type {
        // (undocumented)
        BackgroundMap = 0,
        // (undocumented)
        Geometry = 1,
        // (undocumented)
        Overlay = 2
    }
}

// @internal
export abstract class TileLoader {
    // (undocumented)
    adjustContentIdSizeMultiplier(contentId: string, _sizeMultiplier: number): string;
    // (undocumented)
    protected readonly _batchType: BatchType;
    compareTilePriorities(lhs: Tile, rhs: Tile): number;
    // (undocumented)
    abstract getChildrenProps(parent: Tile): Promise<TileProps[]>;
    // (undocumented)
    protected readonly _loadEdges: boolean;
    // (undocumented)
    loadTileContent(tile: Tile, data: TileRequest.ResponseData, isCanceled?: () => boolean): Promise<Tile.Content>;
    // (undocumented)
    loadTileContentFromStream(tile: Tile, streamBuffer: TileIO.StreamBuffer, isCanceled?: () => boolean): Promise<Tile.Content>;
    // (undocumented)
    abstract readonly maxDepth: number;
    // (undocumented)
    readonly parentsAndChildrenExclusive: boolean;
    // (undocumented)
    abstract readonly priority: Tile.LoadPriority;
    // (undocumented)
    processSelectedTiles(selected: Tile[], _args: Tile.DrawArgs): Tile[];
    // (undocumented)
    abstract requestTileContent(tile: Tile): Promise<TileRequest.Response>;
    // (undocumented)
    abstract tileRequiresLoading(params: Tile.Params): boolean;
    // (undocumented)
    readonly viewFlagOverrides: ViewFlag.Overrides;
}

// @internal
export class TileTree implements IDisposable, RenderMemory.Consumer {
    constructor(props: TileTree.Params);
    // (undocumented)
    accumlateTransformedRange(range: Range3d, matrix: Matrix4d, frustumPlanes?: FrustumPlanes): void;
    // (undocumented)
    readonly clipVector: ClipVector | undefined;
    // (undocumented)
    clipVolume?: RenderClipVolume;
    // (undocumented)
    collectStatistics(stats: RenderMemory.Statistics): void;
    // (undocumented)
    readonly contentRange?: ElementAlignedBox3d;
    // (undocumented)
    createDrawArgs(context: SceneContext): Tile.DrawArgs;
    // (undocumented)
    debugForcedDepth?: number;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    draw(args: Tile.DrawArgs): void;
    // (undocumented)
    drawScene(context: SceneContext): void;
    // (undocumented)
    expirationTime: BeDuration;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly iModel: IModelConnection;
    // (undocumented)
    readonly is2d: boolean;
    // (undocumented)
    readonly is3d: boolean;
    // (undocumented)
    readonly loader: TileLoader;
    // (undocumented)
    readonly location: Transform;
    // (undocumented)
    readonly maxTilesToSkip: number;
    // (undocumented)
    readonly modelId: Id64String;
    // (undocumented)
    readonly range: ElementAlignedBox3d;
    // (undocumented)
    readonly rootTile: Tile;
    // (undocumented)
    protected _rootTile: Tile;
    // (undocumented)
    selectTiles(args: Tile.DrawArgs): Tile[];
    // (undocumented)
    selectTilesForScene(context: SceneContext): Tile[];
    // (undocumented)
    readonly viewFlagOverrides: ViewFlag.Overrides;
    // (undocumented)
    readonly yAxisUp: boolean;
}

// @internal
export namespace TileTree {
    // (undocumented)
    export enum LoadStatus {
        // (undocumented)
        Loaded = 2,
        // (undocumented)
        Loading = 1,
        // (undocumented)
        NotFound = 3,
        // (undocumented)
        NotLoaded = 0
    }
    export interface Params {
        // (undocumented)
        readonly clipVector?: ClipVector;
        // (undocumented)
        readonly contentRange?: ElementAlignedBox3d;
        // (undocumented)
        readonly id: string;
        // (undocumented)
        readonly iModel: IModelConnection;
        // (undocumented)
        readonly is3d: boolean;
        // (undocumented)
        readonly isBackgroundMap?: boolean;
        // (undocumented)
        readonly loader: TileLoader;
        // (undocumented)
        readonly location: Transform;
        // (undocumented)
        readonly maxTilesToSkip?: number;
        // (undocumented)
        readonly modelId: Id64String;
        // (undocumented)
        readonly rootTile: TileProps;
        // (undocumented)
        readonly yAxisUp?: boolean;
    }
    export function paramsFromJSON(props: TileTreeProps, iModel: IModelConnection, is3d: boolean, loader: TileLoader, modelId: Id64String): Params;
}

// @alpha
export interface TileTreeModelState {
    // @internal (undocumented)
    readonly iModel: IModelConnection;
    // @internal (undocumented)
    readonly jsonProperties: {
        [key: string]: any;
    };
    // @internal (undocumented)
    readonly loadStatus: TileTree.LoadStatus;
    // @internal
    loadTree(edgesRequired: boolean, animationId?: Id64String): TileTree.LoadStatus;
    // @internal
    readonly tileTree: TileTree | undefined;
    // @internal (undocumented)
    readonly treeModelId: Id64String;
}

// @internal (undocumented)
export class TileTreeState {
    constructor(_iModel: IModelConnection, _is3d: boolean, _modelId: Id64String);
    // (undocumented)
    animationId?: Id64String;
    // (undocumented)
    classifierExpansion: number;
    // (undocumented)
    clearTileTree(): void;
    // (undocumented)
    edgesOmitted: boolean;
    // (undocumented)
    readonly iModel: IModelConnection;
    // (undocumented)
    loadStatus: TileTree.LoadStatus;
    // (undocumented)
    readonly modelId: string;
    // (undocumented)
    setTileTree(props: TileTreeProps, loader: TileLoader): void;
    // (undocumented)
    tileTree?: TileTree;
}

// @public
export class Tool {
    constructor(..._args: any[]);
    readonly description: string;
    static readonly description: string;
    readonly flyover: string;
    static readonly flyover: string;
    static hidden: boolean;
    static readonly keyin: string;
    readonly keyin: string;
    static namespace: I18NNamespace;
    static register(namespace?: I18NNamespace): void;
    run(..._arg: any[]): boolean;
    static toolId: string;
    readonly toolId: string;
}

// @public
export class ToolAdmin {
    acsContextLock: boolean;
    acsPlaneSnapLock: boolean;
    readonly activeTool: InteractiveTool | undefined;
    readonly activeToolChanged: BeEvent<(tool: Tool, start: StartOrResume) => void>;
    // @internal
    addEvent(ev: Event, vp?: ScreenViewport): void;
    // (undocumented)
    adjustPoint(pointActive: Point3d, vp: ScreenViewport, projectToACS?: boolean, applyLocks?: boolean): void;
    // (undocumented)
    adjustPointToACS(pointActive: Point3d, vp: Viewport, perpendicular: boolean): void;
    // (undocumented)
    adjustPointToGrid(pointActive: Point3d, vp: Viewport): void;
    // (undocumented)
    adjustSnapPoint(perpendicular?: boolean): void;
    assemblyLock: boolean;
    // @internal (undocumented)
    beginDynamics(): void;
    // @internal (undocumented)
    callOnCleanup(): void;
    convertTouchEndToButtonUp(ev: BeTouchEvent, button?: BeButton): Promise<void>;
    convertTouchMoveStartToButtonDownAndMotion(startEv: BeTouchEvent, ev: BeTouchEvent, button?: BeButton): Promise<void>;
    convertTouchMoveToMotion(ev: BeTouchEvent): Promise<void>;
    convertTouchStartToButtonDown(ev: BeTouchEvent, button?: BeButton): Promise<void>;
    convertTouchTapToButtonDownAndUp(ev: BeTouchEvent, button?: BeButton): Promise<void>;
    // @internal (undocumented)
    readonly currentInputState: CurrentInputState;
    readonly currentTool: InteractiveTool;
    readonly cursorView: ScreenViewport | undefined;
    // @internal (undocumented)
    decorate(context: DecorateContext): void;
    // @internal
    defaultToolArgs: any[] | undefined;
    // @internal
    defaultToolId: string;
    doRedoOperation(): Promise<boolean>;
    doUndoOperation(): Promise<boolean>;
    // @internal (undocumented)
    endDynamics(): void;
    // @internal (undocumented)
    exitInputCollector(): void;
    // @internal (undocumented)
    exitViewTool(): void;
    // @internal (undocumented)
    fillEventFromCursorLocation(ev: BeButtonEvent): void;
    // @internal (undocumented)
    fillEventFromLastDataButton(ev: BeButtonEvent): void;
    protected filterViewport(vp: Viewport): boolean;
    // @internal (undocumented)
    getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    getToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    gridLock: boolean;
    readonly idleTool: IdleTool;
    // (undocumented)
    readonly isLocateCircleOn: boolean;
    // @alpha
    readonly manipulatorToolEvent: BeEvent<(tool: Tool, event: ManipulatorToolEvent) => void>;
    // (undocumented)
    markupView?: ScreenViewport;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal (undocumented)
    onInstallTool(tool: InteractiveTool): boolean;
    // @internal (undocumented)
    onMouseLeave(vp: ScreenViewport): Promise<void>;
    // @internal (undocumented)
    onPostInstallTool(tool: InteractiveTool): void;
    // @internal (undocumented)
    onSelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void;
    // @internal (undocumented)
    onShutDown(): void;
    // (undocumented)
    readonly primitiveTool: PrimitiveTool | undefined;
    processWheelEvent(ev: BeWheelEvent, doUpdate: boolean): Promise<EventHandled>;
    // @internal (undocumented)
    sendButtonEvent(ev: BeButtonEvent): Promise<any>;
    // (undocumented)
    sendEndDragEvent(ev: BeButtonEvent): Promise<any>;
    // @internal (undocumented)
    setAdjustedDataPoint(ev: BeButtonEvent): void;
    // (undocumented)
    setCursor(cursor: string | undefined): void;
    // @internal (undocumented)
    setIncompatibleViewportCursor(restore: boolean): void;
    // @internal (undocumented)
    setInputCollector(newTool?: InputCollector): void;
    // (undocumented)
    setLocateCircleOn(locateOn: boolean): void;
    // (undocumented)
    setLocateCursor(enableLocate: boolean): void;
    // @internal (undocumented)
    setPrimitiveTool(newTool?: PrimitiveTool): void;
    // @internal (undocumented)
    setViewTool(newTool?: ViewTool): void;
    // @internal
    startDefaultTool(): void;
    // @internal (undocumented)
    startEventLoop(): void;
    // @internal (undocumented)
    startInputCollector(newTool: InputCollector): void;
    // @internal (undocumented)
    startPrimitiveTool(newTool?: PrimitiveTool): void;
    // @internal (undocumented)
    startViewTool(newTool: ViewTool): void;
    // @beta
    syncToolSettingsProperties(toolId: string, syncProperties: ToolSettingsPropertySyncItem[]): void;
    // @internal (undocumented)
    testDecorationHit(id: string): boolean;
    // @internal (undocumented)
    toolSettingsChangeHandler: ((toolId: string, syncProperties: ToolSettingsPropertySyncItem[]) => void) | undefined;
    // @internal (undocumented)
    readonly toolSettingsState: ToolSettingsState;
    // @internal (undocumented)
    readonly toolState: ToolState;
    // @internal (undocumented)
    updateDynamics(ev?: BeButtonEvent, useLastData?: boolean, adjustPoint?: boolean): void;
    // (undocumented)
    readonly viewTool: ViewTool | undefined;
    }

// @public (undocumented)
export type ToolList = ToolType[];

// @public
export class ToolRegistry {
    create(toolId: string, ...args: any[]): Tool | undefined;
    // @internal
    executeExactMatch(keyin: string, ...args: any[]): boolean;
    find(toolId: string): ToolType | undefined;
    // @internal
    findExactMatch(keyin: string): ToolType | undefined;
    // @internal
    findPartialMatches(keyin: string): FuzzySearchResults<ToolType>;
    getToolList(): ToolList;
    register(toolClass: ToolType, namespace?: I18NNamespace): void;
    registerModule(moduleObj: any, namespace?: I18NNamespace): void;
    run(toolId: string, ...args: any[]): boolean;
    // (undocumented)
    readonly tools: Map<string, typeof Tool>;
    unRegister(toolId: string): void;
}

// @public
export class ToolSettings {
    static animationTime: BeDuration;
    static doubleClickTimeout: BeDuration;
    static doubleClickToleranceInches: number;
    static doubleTapTimeout: BeDuration;
    static noMotionTimeout: BeDuration;
    static preserveWorldUp: boolean;
    static startDragDelay: BeDuration;
    static startDragDistanceInches: number;
    static touchMoveDelay: BeDuration;
    static touchMoveDistanceInches: number;
    static viewToolPickRadiusInches: number;
    static walkCameraAngle: Angle;
    static walkEnforceZUp: boolean;
    static walkVelocity: number;
    static wheelLineFactor: number;
    static wheelPageFactor: number;
    static wheelZoomBumpDistance: number;
    static wheelZoomRatio: number;
}

// @beta
export class ToolSettingsPropertyItem {
    constructor(value: ToolSettingsValue, propertyName: string);
    // (undocumented)
    propertyName: string;
    // (undocumented)
    value: ToolSettingsValue;
}

// @beta
export class ToolSettingsPropertyRecord extends PropertyRecord {
    constructor(value: PropertyValue, property: PropertyDescription, editorPosition: EditorPosition, isReadonly?: boolean);
    // (undocumented)
    static clone(record: ToolSettingsPropertyRecord, newValue?: ToolSettingsValue): ToolSettingsPropertyRecord;
    // (undocumented)
    editorPosition: EditorPosition;
}

// @beta
export class ToolSettingsPropertySyncItem extends ToolSettingsPropertyItem {
    constructor(value: ToolSettingsValue, propertyName: string, isDisabled?: boolean);
    isDisabled?: boolean;
}

// @internal
export class ToolSettingsState {
    initializeToolSettingProperties(toolId: string, tsProps: ToolSettingsPropertyItem[]): void;
    initializeToolSettingProperty(toolId: string, item: ToolSettingsPropertyItem): void;
    saveToolSettingProperties(toolId: string, tsProps: ToolSettingsPropertyItem[]): void;
    saveToolSettingProperty(toolId: string, item: ToolSettingsPropertyItem): void;
}

// @beta
export class ToolSettingsValue implements PrimitiveValue {
    constructor(value?: number | string | boolean | Date, displayValue?: string);
    // (undocumented)
    clone(): ToolSettingsValue;
    // (undocumented)
    displayValue?: string;
    // (undocumented)
    readonly hasDisplayValue: boolean;
    // (undocumented)
    readonly isNullValue: boolean;
    // (undocumented)
    update(newValue: ToolSettingsValue): boolean;
    // (undocumented)
    value?: number | string | boolean | Date;
    // (undocumented)
    readonly valueFormat = PropertyValueFormat.Primitive;
}

// @internal (undocumented)
export class ToolState {
    // (undocumented)
    clone(): ToolState;
    // (undocumented)
    coordLockOvr: CoordinateLockOverrides;
    // (undocumented)
    locateCircleOn: boolean;
    // (undocumented)
    setFrom(other: ToolState): void;
}

// @public
export interface ToolTipOptions {
    // (undocumented)
    duration?: BeDuration;
    // (undocumented)
    placement?: string;
}

// @public (undocumented)
export type ToolType = typeof Tool;

// @internal
export class TouchCursor implements CanvasDecoration {
    protected constructor(vp: ScreenViewport);
    // (undocumented)
    static createFromTouchTap(ev: BeTouchEvent): TouchCursor | undefined;
    // (undocumented)
    doTouchEnd(ev: BeTouchEvent): void;
    // (undocumented)
    doTouchMove(ev: BeTouchEvent): boolean;
    // (undocumented)
    doTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): boolean;
    // (undocumented)
    doTouchStart(ev: BeTouchEvent): void;
    // (undocumented)
    doTouchTap(ev: BeTouchEvent): Promise<boolean>;
    // (undocumented)
    drawDecoration(ctx: CanvasRenderingContext2D): void;
    // (undocumented)
    protected drawHandle(ctx: CanvasRenderingContext2D, filled: boolean): void;
    // (undocumented)
    protected _inTouchTap: boolean;
    // (undocumented)
    isButtonHandled(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected _isDragging: boolean;
    // (undocumented)
    protected isSelected(pt: XAndY): boolean;
    // (undocumented)
    protected _isSelected: boolean;
    // (undocumented)
    protected _offsetPosition: Point3d;
    // (undocumented)
    position: Point3d;
    // (undocumented)
    protected setPosition(vp: Viewport, worldLocation: Point3d): boolean;
    // (undocumented)
    protected _size: number;
    // (undocumented)
    protected _yOffset: number;
}

// @alpha
export class TwoWayViewportSync {
    connect(view1: Viewport, view2: Viewport): void;
    disconnect(): void;
    }

// @internal
export enum UsesDragSelect {
    Box = 0,
    Line = 1,
    None = 2
}

// @internal
export enum UsesFence {
    Check = 0,
    None = 2,
    Required = 1
}

// @internal
export enum UsesSelection {
    Check = 0,
    None = 2,
    Required = 1
}

// @public
export interface ViewChangeOptions {
    animateFrustumChange?: boolean;
    animationTime?: BeDuration;
    marginPercent?: MarginPercent;
    saveInUndo?: boolean;
}

// @alpha
export class ViewClipByElementTool extends ViewClipTool {
    constructor(clipEventHandler?: ViewClipEventHandler, _alwaysUseRange?: boolean);
    // (undocumented)
    protected _alwaysUseRange: boolean;
    // (undocumented)
    protected doClipToElements(viewport: Viewport, ids: Id64Arg, alwaysUseRange?: boolean): Promise<boolean>;
    // (undocumented)
    doClipToSelectedElements(viewport: Viewport): Promise<boolean>;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class ViewClipByPlaneTool extends ViewClipTool {
    constructor(clipEventHandler?: ViewClipEventHandler, _clearExistingPlanes?: boolean);
    // (undocumented)
    applyToolSettingPropertyChange(updatedValue: ToolSettingsPropertySyncItem): boolean;
    // (undocumented)
    protected _clearExistingPlanes: boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    orientation: ClipOrientation;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class ViewClipByRangeTool extends ViewClipTool {
    // (undocumented)
    protected _corner?: Point3d;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    protected getClipRange(range: Range3d, transform: Transform, ev: BeButtonEvent): boolean;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class ViewClipByShapeTool extends ViewClipTool {
    // (undocumented)
    applyToolSettingPropertyChange(updatedValue: ToolSettingsPropertySyncItem): boolean;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    decorateSuspended(context: DecorateContext): void;
    // (undocumented)
    protected getClipPoints(ev: BeButtonEvent): Point3d[];
    // (undocumented)
    isValidLocation(ev: BeButtonEvent, isButtonEvent: boolean): boolean;
    // (undocumented)
    protected _matrix?: Matrix3d;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onKeyTransition(wentDown: boolean, keyEvent: KeyboardEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onUndoPreviousStep(): Promise<boolean>;
    // (undocumented)
    orientation: ClipOrientation;
    // (undocumented)
    protected readonly _points: Point3d[];
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined;
    // (undocumented)
    static toolId: string;
    // (undocumented)
    protected _zHigh?: number;
    // (undocumented)
    protected _zLow?: number;
}

// @alpha
export class ViewClipClearTool extends ViewClipTool {
    // (undocumented)
    protected doClipClear(viewport: Viewport): boolean;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    protected showPrompt(): void;
    // (undocumented)
    static toolId: string;
}

// @alpha
export class ViewClipControlArrow {
    constructor(origin: Point3d, direction: Vector3d, sizeInches: number, fill?: ColorDef, outline?: ColorDef, name?: string);
    // (undocumented)
    direction: Vector3d;
    // (undocumented)
    fill?: ColorDef;
    // (undocumented)
    name?: string;
    // (undocumented)
    origin: Point3d;
    // (undocumented)
    outline?: ColorDef;
    // (undocumented)
    sizeInches: number;
}

// @alpha
export class ViewClipDecoration extends EditManipulator.HandleProvider {
    constructor(_clipView: Viewport, _clipEventHandler?: ViewClipEventHandler | undefined);
    // (undocumented)
    static clear(): void;
    // (undocumented)
    protected clearControls(): void;
    // (undocumented)
    protected _clip?: ClipVector;
    // (undocumented)
    protected _clipEventHandler?: ViewClipEventHandler | undefined;
    // (undocumented)
    readonly clipId: string | undefined;
    // (undocumented)
    protected _clipId?: string;
    // (undocumented)
    protected _clipPlanes?: ConvexClipPlaneSet;
    // (undocumented)
    readonly clipPlaneSet: ConvexClipPlaneSet | undefined;
    // (undocumented)
    protected _clipPlanesLoops?: GeometryQuery[];
    // (undocumented)
    protected _clipPlanesLoopsNoncontributing?: GeometryQuery[];
    // (undocumented)
    readonly clipShape: ClipShape | undefined;
    // (undocumented)
    protected _clipShape?: ClipShape;
    // (undocumented)
    protected _clipShapeExtents?: Range1d;
    // (undocumented)
    protected _clipView: Viewport;
    // (undocumented)
    protected _controlIds: string[];
    // (undocumented)
    protected _controls: ViewClipControlArrow[];
    // (undocumented)
    static create(vp: Viewport, clipEventHandler?: ViewClipEventHandler): string | undefined;
    // (undocumented)
    protected createControls(): Promise<boolean>;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    doClipPlaneClear(index: number): boolean;
    // (undocumented)
    doClipPlaneNegate(index: number): boolean;
    // (undocumented)
    doClipPlaneOrientView(index: number): boolean;
    // (undocumented)
    doClipShapeSetZExtents(extents: Range1d): boolean;
    // (undocumented)
    static get(vp: Viewport): ViewClipDecoration | undefined;
    // (undocumented)
    getControlIndex(id: string): number;
    // (undocumented)
    getDecorationToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    // (undocumented)
    isClipShapeAlignedWithWorldUp(extents?: Range1d): boolean;
    // (undocumented)
    protected modifyControls(hit: HitDetail, _ev: BeButtonEvent): boolean;
    // (undocumented)
    onManipulatorEvent(eventType: EditManipulator.EventType): void;
    // (undocumented)
    protected onRightClick(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    protected onTouchTap(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onViewClose(vp: ScreenViewport): void;
    // (undocumented)
    protected _removeViewCloseListener?: () => void;
    // (undocumented)
    protected stop(): void;
    // (undocumented)
    protected _suspendDecorator: boolean;
    // (undocumented)
    testDecorationHit(id: string): boolean;
    // (undocumented)
    static toggle(vp: Viewport, clipEventHandler?: ViewClipEventHandler): string | undefined;
    // (undocumented)
    protected updateDecorationListener(_add: boolean): void;
}

// @alpha
export class ViewClipDecorationProvider implements ViewClipEventHandler {
    // (undocumented)
    static clear(): void;
    // (undocumented)
    clearDecorationOnDeselect: boolean;
    // (undocumented)
    clearOnDeselect(): boolean;
    // (undocumented)
    static create(): ViewClipDecorationProvider;
    readonly hasSettings: boolean;
    // (undocumented)
    hideDecoration(): void;
    // (undocumented)
    onActivateClip(viewport: Viewport, interactive: boolean): void;
    readonly onActiveClipChanged: BeEvent<(viewport: Viewport, eventType: ClipEventType, provider: ViewClipDecorationProvider) => void>;
    readonly onActiveClipRightClick: BeEvent<(hit: HitDetail, ev: BeButtonEvent, provider: ViewClipDecorationProvider) => void>;
    // (undocumented)
    onClearClip(viewport: Viewport): void;
    // (undocumented)
    onModifyClip(viewport: Viewport): void;
    // (undocumented)
    onNewClip(viewport: Viewport): void;
    // (undocumented)
    onNewClipPlane(viewport: Viewport): void;
    // (undocumented)
    onRightClick(hit: HitDetail, ev: BeButtonEvent): boolean;
    // (undocumented)
    selectDecorationOnCreate: boolean;
    // (undocumented)
    selectOnCreate(): boolean;
    readonly settings: ViewClipSettingsProvider;
    // (undocumented)
    protected _settings?: ViewClipSettingsProvider;
    // (undocumented)
    showDecoration(vp: Viewport): void;
    // (undocumented)
    toggleDecoration(vp: Viewport): void;
}

// @alpha
export interface ViewClipEventHandler {
    // (undocumented)
    clearOnDeselect(): boolean;
    // (undocumented)
    onActivateClip(viewport: Viewport, interactive: boolean): void;
    // (undocumented)
    onClearClip(viewport: Viewport): void;
    // (undocumented)
    onModifyClip(viewport: Viewport): void;
    // (undocumented)
    onNewClip(viewport: Viewport): void;
    // (undocumented)
    onNewClipPlane(viewport: Viewport): void;
    // (undocumented)
    onRightClick(hit: HitDetail, ev: BeButtonEvent): boolean;
    // (undocumented)
    selectOnCreate(): boolean;
}

// @alpha
export abstract class ViewClipModifyTool extends EditManipulator.HandleTool {
    constructor(manipulator: EditManipulator.HandleProvider, clip: ClipVector, vp: Viewport, hitId: string, ids: string[], controls: ViewClipControlArrow[]);
    // (undocumented)
    protected accept(ev: BeButtonEvent): boolean;
    // (undocumented)
    protected _anchorIndex: number;
    // (undocumented)
    protected _clip: ClipVector;
    // (undocumented)
    protected _clipView: Viewport;
    // (undocumented)
    protected _controls: ViewClipControlArrow[];
    // (undocumented)
    protected _currentDistance: number;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    protected drawAnchorOffset(context: DecorateContext, color: ColorDef, weight: number, transformFromClip?: Transform): void;
    // (undocumented)
    protected abstract drawViewClip(context: DecorateContext): void;
    // (undocumented)
    protected getOffsetValue(ev: BeButtonEvent, transformFromClip?: Transform): number | undefined;
    // (undocumented)
    protected _ids: string[];
    // (undocumented)
    protected init(): void;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    protected _restoreClip: boolean;
    // (undocumented)
    protected abstract updateViewClip(ev: BeButtonEvent, isAccept: boolean): boolean;
    // (undocumented)
    protected _viewRange: Range3d;
}

// @alpha
export class ViewClipPlanesModifyTool extends ViewClipModifyTool {
    // (undocumented)
    protected drawViewClip(context: DecorateContext): void;
    // (undocumented)
    protected updateViewClip(ev: BeButtonEvent, _isAccept: boolean): boolean;
}

// @alpha
export class ViewClipSettingsProvider {
    constructor(_clipEventHandler?: ViewClipEventHandler | undefined);
    // (undocumented)
    activateSavedClip(viewport: Viewport, id: GuidString, shared: boolean, interactive?: boolean): Promise<SettingsStatus>;
    // (undocumented)
    activateSavedClipPlanes(viewport: Viewport, ids: GuidString[], shared: boolean[]): Promise<SettingsStatus>;
    // (undocumented)
    appSpecific: boolean;
    // (undocumented)
    areSavedClipPlanes(iModel: IModelConnection, ids: GuidString[], shared: boolean[]): Promise<boolean>;
    // @internal (undocumented)
    clearActiveClipId(viewport: Viewport): void;
    // @internal (undocumented)
    clearActiveClipIdAllViews(): void;
    // (undocumented)
    protected _clipEventHandler?: ViewClipEventHandler | undefined;
    // (undocumented)
    copyClip(iModel: IModelConnection, shared: boolean, existingId: GuidString, copyShared: boolean, name?: string): Promise<GuidString | undefined>;
    // @internal (undocumented)
    protected deleteCachedSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SettingsStatus>;
    // (undocumented)
    deleteClip(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SettingsStatus>;
    // @internal (undocumented)
    protected deleteSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SettingsResult>;
    // (undocumented)
    getActiveClipId(viewport: Viewport): GuidString | undefined;
    // (undocumented)
    getActiveClipStatus(viewport: Viewport): ActiveClipStatus;
    // @internal (undocumented)
    protected getAllSettings(iModel: IModelConnection, shared: boolean): Promise<SettingsMapResult>;
    // @internal (undocumented)
    protected getCachedSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SavedClipCache>;
    // (undocumented)
    getClip(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<ClipVector | undefined>;
    // (undocumented)
    protected getiModelId(iModel: IModelConnection): string | undefined;
    // (undocumented)
    protected getProjectId(iModel: IModelConnection): string | undefined;
    // (undocumented)
    protected getRequestContext(): Promise<AuthorizedFrontendRequestContext>;
    // @internal (undocumented)
    protected getSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SettingsResult>;
    // (undocumented)
    getSettings(settings: SavedClipEntry[], iModel: IModelConnection, shared?: boolean): Promise<SettingsStatus>;
    // @internal (undocumented)
    modifiedActiveClip(viewport: Viewport): boolean;
    // (undocumented)
    namespace: string;
    // @internal (undocumented)
    protected newCachedSetting(iModel: IModelConnection, shared: boolean, newId: GuidString, settings: SavedClipProps): Promise<SettingsStatus>;
    // (undocumented)
    newClip(iModel: IModelConnection, shared: boolean, clip: ClipVector, name?: string): Promise<GuidString | undefined>;
    // @internal (undocumented)
    protected purgeActiveClipIdCache(): void;
    // @internal (undocumented)
    protected renameCachedSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString, name: string): Promise<SettingsStatus>;
    // (undocumented)
    renameClip(iModel: IModelConnection, shared: boolean, existingId: GuidString, name: string): Promise<SettingsStatus>;
    // (undocumented)
    replaceClip(iModel: IModelConnection, shared: boolean, existingId: GuidString, clip: ClipVector): Promise<SettingsStatus>;
    // (undocumented)
    saveActiveClip(viewport: Viewport, shared: boolean, name?: string): Promise<GuidString | undefined>;
    // @internal (undocumented)
    protected saveSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString, settings: SavedClipProps): Promise<SettingsResult>;
    // @internal (undocumented)
    setActiveClipId(viewport: Viewport, existingId: GuidString): void;
    // @internal (undocumented)
    protected shareCachedSetting(iModel: IModelConnection, existingId: GuidString, newShared: boolean): Promise<SettingsStatus>;
    // (undocumented)
    shareClip(iModel: IModelConnection, existingId: GuidString, newShare: boolean): Promise<SettingsStatus>;
    // @internal (undocumented)
    protected updateCachedSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString, settings: SavedClipProps): Promise<SettingsStatus>;
    // @internal (undocumented)
    protected validateActiveClipId(viewport: Viewport): void;
}

// @alpha
export class ViewClipShapeModifyTool extends ViewClipModifyTool {
    // (undocumented)
    protected drawViewClip(context: DecorateContext): void;
    // (undocumented)
    protected updateViewClip(ev: BeButtonEvent, _isAccept: boolean): boolean;
}

// @alpha
export class ViewClipTool extends PrimitiveTool {
    constructor(_clipEventHandler?: ViewClipEventHandler | undefined);
    // (undocumented)
    static areClipsEqual(clipA: ClipVector, clipB: ClipVector): boolean;
    // (undocumented)
    protected _clipEventHandler?: ViewClipEventHandler | undefined;
    // (undocumented)
    static doClipClear(viewport: Viewport): boolean;
    // (undocumented)
    static doClipToConvexClipPlaneSet(viewport: Viewport, planes: ConvexClipPlaneSet): boolean;
    // (undocumented)
    static doClipToPlane(viewport: Viewport, origin: Point3d, normal: Vector3d, clearExistingPlanes: boolean): boolean;
    // (undocumented)
    static doClipToRange(viewport: Viewport, range: Range3d, transform?: Transform): boolean;
    // (undocumented)
    static doClipToShape(viewport: Viewport, xyPoints: Point3d[], transform?: Transform, zLow?: number, zHigh?: number): boolean;
    // (undocumented)
    static drawClipPlanesLoops(context: DecorateContext, loops: GeometryQuery[], color: ColorDef, weight: number, dashed?: boolean, fill?: ColorDef, id?: string): void;
    // (undocumented)
    static drawClipShape(context: DecorateContext, shape: ClipShape, extents: Range1d, color: ColorDef, weight: number, id?: string): void;
    // (undocumented)
    static enableClipVolume(viewport: Viewport): boolean;
    // (undocumented)
    protected static enumAsOrientationMessage(str: string): any;
    // (undocumented)
    static getClipOrientation(orientation: ClipOrientation, viewport: Viewport): Matrix3d | undefined;
    // (undocumented)
    static getClipRayTransformed(origin: Point3d, direction: Vector3d, transform?: Transform): Ray3d;
    // (undocumented)
    static getClipShapeExtents(shape: ClipShape, viewRange: Range3d): Range1d;
    // (undocumented)
    static getClipShapePoints(shape: ClipShape, z: number): Point3d[];
    // (undocumented)
    protected static _getEnumAsOrientationDescription: () => PropertyDescription;
    // (undocumented)
    static getOffsetValueTransformed(offset: number, transform?: Transform): number;
    // (undocumented)
    static getPlaneInwardNormal(orientation: ClipOrientation, viewport: Viewport): Vector3d | undefined;
    // (undocumented)
    static hasClip(viewport: Viewport): boolean;
    // (undocumented)
    isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean;
    // (undocumented)
    static isSingleClipPlane(clip: ClipVector): ClipPlane | undefined;
    // (undocumented)
    static isSingleClipShape(clip: ClipVector): ClipShape | undefined;
    // (undocumented)
    static isSingleConvexClipPlaneSet(clip: ClipVector): ConvexClipPlaneSet | undefined;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onRestartTool(): void;
    // (undocumented)
    onUnsuspend(): void;
    // (undocumented)
    protected static _orientationName: string;
    // (undocumented)
    protected outputPrompt(prompt: string): void;
    // (undocumented)
    requireWriteableTarget(): boolean;
    // (undocumented)
    protected setupAndPromptForNextAction(): void;
    // (undocumented)
    static setViewClip(viewport: Viewport, clip?: ClipVector): boolean;
    // (undocumented)
    protected showPrompt(): void;
}

// @internal
export class ViewFrustum {
    protected adjustAspectRatio(origin: Point3d, delta: Vector3d): void;
    // (undocumented)
    static createFromViewport(vp: Viewport, view?: ViewState): ViewFrustum | undefined;
    // (undocumented)
    static createFromViewportAndPlane(vp: Viewport, plane: Plane3dByOriginAndUnitNormal): ViewFrustum | undefined;
    // (undocumented)
    fromView(from: XYZ, to?: XYZ): void;
    // (undocumented)
    frustFraction: number;
    getFrustum(sys?: CoordSystem, adjustedBox?: boolean, box?: Frustum): Frustum;
    // (undocumented)
    getPixelSizeAtPoint(inPoint?: Point3d): number;
    // (undocumented)
    getViewCorners(): Range3d;
    // (undocumented)
    readonly invalidFrustum: boolean;
    static nearScale24: number;
    npcToView(pt: Point3d, out?: Point3d): Point3d;
    npcToViewArray(pts: Point3d[]): void;
    npcToWorld(pt: XYAndZ, out?: Point3d): Point3d;
    npcToWorldArray(pts: Point3d[]): void;
    readonly rotation: Matrix3d;
    // (undocumented)
    toView(from: XYZ, to?: XYZ): void;
    view: ViewState;
    view4dToWorld(input: Point4d, out?: Point3d): Point3d;
    view4dToWorldArray(viewPts: Point4d[], worldPts: Point3d[]): void;
    readonly viewDelta: Vector3d;
    readonly viewDeltaUnexpanded: Vector3d;
    readonly viewOrigin: Point3d;
    readonly viewOriginUnexpanded: Point3d;
    viewToNpc(pt: Point3d, out?: Point3d): Point3d;
    viewToNpcArray(pts: Point3d[]): void;
    viewToWorld(input: XYAndZ, out?: Point3d): Point3d;
    viewToWorldArray(pts: Point3d[]): void;
    worldToNpc(pt: XYAndZ, out?: Point3d): Point3d;
    worldToNpcArray(pts: Point3d[]): void;
    // (undocumented)
    readonly worldToNpcMap: Map4d;
    worldToView(input: XYAndZ, out?: Point3d): Point3d;
    worldToView4d(input: XYAndZ, out?: Point4d): Point4d;
    worldToView4dArray(worldPts: Point3d[], viewPts: Point4d[]): void;
    worldToViewArray(pts: Point3d[]): void;
    // (undocumented)
    readonly worldToViewMap: Map4d;
    // (undocumented)
    readonly zClipAdjusted: boolean;
}

// @internal (undocumented)
export class ViewHandleArray {
    constructor(viewTool: ViewManip);
    // (undocumented)
    add(handle: ViewingToolHandle): void;
    // (undocumented)
    readonly count: number;
    // (undocumented)
    drawHandles(context: DecorateContext): void;
    // (undocumented)
    empty(): void;
    // (undocumented)
    focus: number;
    // (undocumented)
    focusDrag: boolean;
    // (undocumented)
    readonly focusHandle: ViewingToolHandle | undefined;
    // (undocumented)
    focusHitHandle(): void;
    // (undocumented)
    getByIndex(index: number): ViewingToolHandle | undefined;
    // (undocumented)
    handles: ViewingToolHandle[];
    hasHandle(handleType: ViewHandleType): boolean;
    // (undocumented)
    readonly hitHandle: ViewingToolHandle | undefined;
    // (undocumented)
    hitHandleIndex: number;
    // (undocumented)
    motion(ev: BeButtonEvent): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    setFocus(index: number): void;
    // (undocumented)
    testHit(ptScreen: Point3d, forced?: ViewHandleType): boolean;
    // (undocumented)
    viewport?: Viewport;
    // (undocumented)
    viewTool: ViewManip;
}

// @internal (undocumented)
export const enum ViewHandleType {
    // (undocumented)
    EXTERIOR = 1,
    // (undocumented)
    Fly = 64,
    // (undocumented)
    Look = 128,
    // (undocumented)
    None = 0,
    // (undocumented)
    Pan = 4,
    // (undocumented)
    Rotate = 1,
    // (undocumented)
    Scroll = 8,
    // (undocumented)
    TargetCenter = 2,
    // (undocumented)
    Walk = 32,
    // (undocumented)
    Zoom = 16
}

// @internal (undocumented)
export abstract class ViewingToolHandle {
    constructor(viewTool: ViewManip);
    // (undocumented)
    checkOneShot(): boolean;
    // (undocumented)
    abstract doManipulation(ev: BeButtonEvent, inDynamics: boolean): boolean;
    // (undocumented)
    drawHandle(_context: DecorateContext, _hasFocus: boolean): void;
    // (undocumented)
    abstract firstPoint(ev: BeButtonEvent): boolean;
    // (undocumented)
    focusIn(): void;
    // (undocumented)
    focusOut(): void;
    // (undocumented)
    getHandleCursor(): string;
    // (undocumented)
    abstract readonly handleType: ViewHandleType;
    // (undocumented)
    motion(_ev: BeButtonEvent): boolean;
    // (undocumented)
    noMotion(_ev: BeButtonEvent): boolean;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    abstract testHandleForHit(ptScreen: Point3d, out: {
        distance: number;
        priority: ViewManipPriority;
    }): boolean;
    // (undocumented)
    viewTool: ViewManip;
}

// @public
export class ViewManager {
    addDecorator(decorator: Decorator): () => void;
    addViewport(newVp: ScreenViewport): BentleyStatus;
    // @internal (undocumented)
    beginDynamicsMode(): void;
    clearSelectedView(): void;
    // (undocumented)
    readonly crossHairCursor: string;
    // (undocumented)
    cursor: string;
    // (undocumented)
    readonly decorators: Decorator[];
    // @internal (undocumented)
    readonly doesHostHaveFocus: boolean;
    dropDecorator(decorator: Decorator): void;
    dropViewport(vp: ScreenViewport, disposeOfViewport?: boolean): BentleyStatus;
    // (undocumented)
    readonly dynamicsCursor: string;
    // @internal (undocumented)
    endDynamicsMode(): void;
    forEachViewport(func: (vp: ScreenViewport) => void): void;
    // @internal
    getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined;
    // @internal
    getDecorationToolTip(hit: HitDetail): Promise<HTMLElement | string>;
    getFirstOpenView(): ScreenViewport | undefined;
    // (undocumented)
    readonly grabbingCursor: string;
    // (undocumented)
    readonly grabCursor: string;
    // (undocumented)
    inDynamicsMode: boolean;
    invalidateDecorationsAllViews(): void;
    // @internal (undocumented)
    invalidateScenes(): void;
    // @internal (undocumented)
    invalidateViewportScenes(): void;
    // @internal (undocumented)
    notifySelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void;
    readonly onBeginRender: BeEvent<() => void>;
    // @internal
    onDecorationButtonEvent(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;
    readonly onFinishRender: BeEvent<() => void>;
    // @internal (undocumented)
    onInitialized(): void;
    // @internal (undocumented)
    onNewTilesReady(): void;
    readonly onSelectedViewportChanged: BeUiEvent<SelectedViewportChangedArgs>;
    // @internal (undocumented)
    onSelectionSetChanged(_iModel: IModelConnection): void;
    // @internal (undocumented)
    onShutDown(): void;
    readonly onViewClose: BeUiEvent<ScreenViewport>;
    readonly onViewOpen: BeUiEvent<ScreenViewport>;
    readonly onViewResume: BeUiEvent<ScreenViewport>;
    readonly onViewSuspend: BeUiEvent<ScreenViewport>;
    // @internal
    renderLoop(): void;
    // @internal (undocumented)
    readonly sceneInvalidated: boolean;
    readonly selectedView: ScreenViewport | undefined;
    setSelectedView(vp: ScreenViewport | undefined): BentleyStatus;
    setViewCursor(cursor?: string): void;
    // @internal (undocumented)
    validateViewportScenes(): void;
    }

// @public
export abstract class ViewManip extends ViewTool {
    constructor(viewport: ScreenViewport | undefined, handleMask: number, oneShot: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    changeViewport(vp?: ScreenViewport): void;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    enforceZUp(pivotPoint: Point3d): boolean;
    // (undocumented)
    static fitView(viewport: ScreenViewport, doAnimate: boolean, marginPercent?: MarginPercent): void;
    // @internal (undocumented)
    protected _forcedHandle: ViewHandleType;
    // (undocumented)
    frustumValid: boolean;
    // (undocumented)
    static getFocusPlaneNpc(vp: Viewport): number;
    // (undocumented)
    handleMask: number;
    // (undocumented)
    inHandleModify: boolean;
    // (undocumented)
    isDragging: boolean;
    // (undocumented)
    isDraggingRequired: boolean;
    isPointVisible(testPt: Point3d): boolean;
    // (undocumented)
    readonly isZUp: boolean;
    // (undocumented)
    lensAngleMatches(angle: Angle, tolerance: number): boolean;
    // (undocumented)
    nPts: number;
    // (undocumented)
    onCleanup(): void;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    oneShot: boolean;
    // (undocumented)
    onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onMouseMotionStopped(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onMouseNoMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseWheel(inputEv: BeWheelEvent): Promise<EventHandled>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    processFirstPoint(ev: BeButtonEvent): boolean;
    // (undocumented)
    processPoint(ev: BeButtonEvent, inDynamics: boolean): boolean;
    // (undocumented)
    setCameraLensAngle(lensAngle: Angle, retainEyePoint: boolean): ViewStatus;
    setTargetCenterWorld(pt: Point3d, lockTarget: boolean, saveTarget: boolean): void;
    // @internal (undocumented)
    startHandleDrag(ev: BeButtonEvent, forcedHandle?: ViewHandleType): Promise<EventHandled>;
    // (undocumented)
    stoppedOverHandle: boolean;
    // (undocumented)
    targetCenterLocked: boolean;
    // (undocumented)
    targetCenterValid: boolean;
    // (undocumented)
    readonly targetCenterWorld: Point3d;
    // (undocumented)
    updateTargetCenter(): void;
    // (undocumented)
    protected static _useViewAlignedVolume: boolean;
    // @internal (undocumented)
    viewHandles: ViewHandleArray;
    // (undocumented)
    static zoomToAlwaysDrawnExclusive(viewport: ScreenViewport, doAnimate: boolean, marginPercent?: MarginPercent): Promise<boolean>;
}

// @public
export abstract class Viewport implements IDisposable {
    // @internal
    protected constructor(target: RenderTarget);
    // @internal (undocumented)
    addDecorations(_decorations: Decorations): void;
    // @internal
    addModelSubCategoryVisibilityOverrides(fs: FeatureSymbology.Overrides, ovrs: Id64.Uint32Map<Id64.Uint32Set>): void;
    // @internal
    addTiledGraphicsProvider(type: TiledGraphicsProvider.Type, provider: TiledGraphicsProvider.Provider): void;
    readonly alwaysDrawn: Id64Set | undefined;
    // @internal (undocumented)
    readonly analysisStyle: AnalysisStyle | undefined;
    // @internal (undocumented)
    animate(): void;
    // @internal (undocumented)
    animateFrustumChange(start: Frustum, end: Frustum, animationTime?: BeDuration): void;
    // @internal (undocumented)
    animationFraction: number;
    // @internal (undocumented)
    applyViewState(val: ViewState, animationTime?: BeDuration): void;
    // (undocumented)
    readonly auxCoordSystem: AuxCoordSystemState;
    // @internal (undocumented)
    readonly backgroundMapPlane: Plane3dByOriginAndUnitNormal | undefined;
    changeCategoryDisplay(categories: Id64Arg, display: boolean, enableAllSubCategories?: boolean): void;
    // @internal (undocumented)
    changeDynamics(dynamics: GraphicList | undefined): void;
    // @internal (undocumented)
    protected _changeFlags: ChangeFlags;
    changeModelDisplay(models: Id64Arg, display: boolean): boolean;
    // @alpha
    changeSubCategoryDisplay(subCategoryId: Id64String, display: boolean): void;
    changeView(view: ViewState): void;
    changeViewedModel2d(baseModelId: Id64String, options?: ChangeViewedModel2dOptions & ViewChangeOptions): Promise<void>;
    changeViewedModels(modelIds: Id64Arg): boolean;
    clearAlwaysDrawn(): void;
    clearNeverDrawn(): void;
    // @internal (undocumented)
    computeViewRange(): Range3d;
    continuousRendering: boolean;
    // @internal (undocumented)
    createSceneContext(): SceneContext;
    // @internal
    debugBoundingBoxes: Tile.DebugBoundingBoxes;
    determineVisibleDepthRange(rect?: ViewRect, result?: DepthRangeNpc): DepthRangeNpc | undefined;
    displayStyle: DisplayStyleState;
    // (undocumented)
    dispose(): void;
    dropSubCategoryOverride(id: Id64String): void;
    featureOverrideProvider: FeatureOverrideProvider | undefined;
    // @internal
    flashDuration: number;
    // @internal
    flashIntensity: number;
    // @internal
    flashUpdateTime?: BeTimePoint;
    // @internal
    freezeScene: boolean;
    // @internal (undocumented)
    fromView(from: XYZ, to?: XYZ): void;
    // @internal (undocumented)
    readonly frustFraction: number;
    // (undocumented)
    getAuxCoordOrigin(result?: Point3d): Point3d;
    // (undocumented)
    getAuxCoordRotation(result?: Matrix3d): Matrix3d;
    getContrastToBackgroundColor(): ColorDef;
    getFrustum(sys?: CoordSystem, adjustedBox?: boolean, box?: Frustum): Frustum;
    // @beta
    getPixelDataNpcPoint(pixels: Pixel.Buffer, x: number, y: number, out?: Point3d): Point3d | undefined;
    // @beta
    getPixelDataWorldPoint(pixels: Pixel.Buffer, x: number, y: number, out?: Point3d): Point3d | undefined;
    getPixelSizeAtPoint(point?: Point3d): number;
    // @internal (undocumented)
    getSubCategories(categoryId: Id64String): Id64Set | undefined;
    getSubCategoryAppearance(id: Id64String): SubCategoryAppearance;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    // @internal
    getTiledGraphicsProviders(type: TiledGraphicsProvider.Type): TiledGraphicsProvider.ProviderSet | undefined;
    getWorldFrustum(box?: Frustum): Frustum;
    hilite: Hilite.Settings;
    readonly iModel: IModelConnection;
    // @internal (undocumented)
    invalidateDecorations(): void;
    // @internal (undocumented)
    invalidateRenderPlan(): void;
    // @internal (undocumented)
    invalidateScene(): void;
    readonly isAlwaysDrawnExclusive: boolean;
    // @internal (undocumented)
    readonly isAspectRatioLocked: boolean;
    readonly isCameraOn: boolean;
    // @internal (undocumented)
    readonly isContextRotationRequired: boolean;
    isFadeOutActive: boolean;
    readonly isGridOn: boolean;
    // @internal (undocumented)
    readonly isPointAdjustmentRequired: boolean;
    // @internal (undocumented)
    readonly isSnapAdjustmentRequired: boolean;
    isSubCategoryVisible(id: Id64String): boolean;
    // @internal
    lastFlashedElem?: string;
    // @internal (undocumented)
    markSelectionSetDirty(): void;
    // @internal
    static nearScale24: number;
    readonly neverDrawn: Id64Set | undefined;
    npcToView(pt: Point3d, out?: Point3d): Point3d;
    npcToViewArray(pts: Point3d[]): void;
    npcToWorld(pt: XYAndZ, out?: Point3d): Point3d;
    npcToWorldArray(pts: Point3d[]): void;
    numReadyTiles: number;
    readonly numRequestedTiles: number;
    numSelectedTiles: number;
    // @beta
    readonly onAlwaysDrawnChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onDisplayStyleChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onFeatureOverrideProviderChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onFeatureOverridesChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onNeverDrawnChanged: BeEvent<(vp: Viewport) => void>;
    readonly onRender: BeEvent<(vp: Viewport) => void>;
    readonly onViewChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onViewedCategoriesChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onViewedCategoriesPerModelChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onViewedModelsChanged: BeEvent<(vp: Viewport) => void>;
    // @beta
    readonly onViewportChanged: BeEvent<(vp: Viewport, changed: ChangeFlags) => void>;
    // @beta
    readonly onViewUndoRedo: BeEvent<(vp: Viewport, event: ViewUndoEvent) => void>;
    overrideSubCategory(id: Id64String, ovr: SubCategoryOverride): void;
    // @alpha
    readonly perModelCategoryVisibility: PerModelCategoryVisibility.Overrides;
    pixelsFromInches(inches: number): number;
    // @internal (undocumented)
    readonly pixelsPerInch: number;
    // @internal (undocumented)
    pointToGrid(point: Point3d): void;
    readImage(rect?: ViewRect, targetSize?: Point2d, flipVertically?: boolean): ImageBuffer | undefined;
    // @beta
    readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable?: boolean): void;
    // @internal (undocumented)
    removeAnimator(): void;
    // @internal
    removeTiledGraphicsProvider(type: TiledGraphicsProvider.Type, provider: TiledGraphicsProvider.Provider): void;
    // @internal (undocumented)
    renderFrame(): boolean;
    readonly rotation: Matrix3d;
    // @internal (undocumented)
    readonly scheduleTime: number;
    scroll(screenDist: Point2d, options?: ViewChangeOptions): void;
    setAlwaysDrawn(ids: Id64Set, exclusive?: boolean): void;
    setFeatureOverrideProviderChanged(): void;
    // @internal
    setFlashed(id: string | undefined, duration: number): void;
    setNeverDrawn(ids: Id64Set): void;
    setStandardRotation(id: StandardViewId): void;
    setupFromView(): ViewStatus;
    setupViewFromFrustum(inFrustum: Frustum): boolean;
    // @internal (undocumented)
    setViewedCategoriesPerModelChanged(): void;
    // @internal (undocumented)
    readonly subcategories: SubCategoriesCache.Queue;
    // @internal (undocumented)
    readonly sync: SyncFlags;
    synchWithView(_saveInUndo: boolean): void;
    // @internal (undocumented)
    readonly target: RenderTarget;
    // @internal (undocumented)
    toView(from: XYZ, to?: XYZ): void;
    turnCameraOn(lensAngle?: Angle): ViewStatus;
    static undoDelay: BeDuration;
    readonly view: ViewState;
    view4dToWorld(input: Point4d, out?: Point3d): Point3d;
    view4dToWorldArray(viewPts: Point4d[], worldPts: Point3d[]): void;
    readonly viewDelta: Vector3d;
    viewFlags: ViewFlags;
    // @internal (undocumented)
    readonly viewFrustum: ViewFrustum;
    // @internal
    readonly viewportId: number;
    // @internal (undocumented)
    protected readonly _viewRange: ViewRect;
    abstract readonly viewRect: ViewRect;
    viewsModel(modelId: Id64String): boolean;
    viewToNpc(pt: Point3d, out?: Point3d): Point3d;
    viewToNpcArray(pts: Point3d[]): void;
    viewToWorld(input: XYAndZ, out?: Point3d): Point3d;
    viewToWorldArray(pts: Point3d[]): void;
    // @internal (undocumented)
    readonly wantAntiAliasLines: AntiAliasPref;
    // @internal (undocumented)
    readonly wantAntiAliasText: AntiAliasPref;
    worldToNpc(pt: XYAndZ, out?: Point3d): Point3d;
    worldToNpcArray(pts: Point3d[]): void;
    worldToView(input: XYAndZ, out?: Point3d): Point3d;
    worldToView4d(input: XYAndZ, out?: Point4d): Point4d;
    worldToView4dArray(worldPts: Point3d[], viewPts: Point4d[]): void;
    worldToViewArray(pts: Point3d[]): void;
    readonly worldToViewMap: Map4d;
    zoom(newCenter: Point3d | undefined, factor: number, options?: ViewChangeOptions): void;
    zoomToElementProps(elementProps: ElementProps[], options?: ViewChangeOptions & ZoomToOptions): void;
    zoomToElements(ids: Id64Arg, options?: ViewChangeOptions & ZoomToOptions): Promise<void>;
    zoomToPlacementProps(placementProps: PlacementProps[], options?: ViewChangeOptions & ZoomToOptions): void;
    zoomToVolume(volume: LowAndHighXYZ | LowAndHighXY, options?: ViewChangeOptions): void;
}

// @public
export interface ViewportAnimator {
    animate(viewport: Viewport): RemoveMe;
    onInterrupted(viewport: Viewport): void;
}

// @public
export class ViewRect {
    constructor(left?: number, top?: number, right?: number, bottom?: number);
    readonly area: number;
    readonly aspect: number;
    bottom: number;
    clone(result?: ViewRect): ViewRect;
    computeOverlap(other: ViewRect, out?: ViewRect): ViewRect | undefined;
    containsPoint(point: XAndY): boolean;
    equals(other: ViewRect): boolean;
    // (undocumented)
    extend(other: ViewRect): void;
    height: number;
    init(left: number, top: number, right: number, bottom: number): void;
    initFromPoints(topLeft: XAndY, bottomRight: XAndY): void;
    initFromRange(input: LowAndHighXY): void;
    inset(deltaX: number, deltaY: number): void;
    insetByPercent(percent: number): void;
    insetUniform(offset: number): void;
    isContained(other: ViewRect): boolean;
    readonly isNull: boolean;
    readonly isValid: boolean;
    left: number;
    overlaps(other: ViewRect): boolean;
    right: number;
    scaleAboutCenter(xScale: number, yScale: number): void;
    setFrom(other: ViewRect): void;
    top: number;
    width: number;
}

// @public
export class ViewRedoTool extends ViewTool {
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export abstract class ViewState extends ElementState {
    // @internal
    protected constructor(props: ViewDefinitionProps, iModel: IModelConnection, categoryOrClone: CategorySelectorState, displayStyle: DisplayStyleState);
    // @internal (undocumented)
    protected adjustAspectRatio(windowAspect: number): void;
    abstract allow3dManipulations(): boolean;
    readonly analysisStyle: AnalysisStyle | undefined;
    // @internal (undocumented)
    readonly areAllTileTreesLoaded: boolean;
    readonly auxiliaryCoordinateSystem: AuxCoordSystemState;
    readonly backgroundColor: ColorDef;
    calculateFrustum(result?: Frustum): Frustum | undefined;
    categorySelector: CategorySelectorState;
    // @internal (undocumented)
    static readonly className: string;
    abstract computeFitRange(): Range3d;
    // @internal (undocumented)
    computeWorldToNpc(viewRot?: Matrix3d, inOrigin?: Point3d, delta?: Vector3d, enforceFrontToBackRatio?: boolean): {
        map: Map4d | undefined;
        frustFraction: number;
    };
    // @internal (undocumented)
    abstract createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    // @internal (undocumented)
    createBackgroundMap(context: SceneContext): void;
    // @internal (undocumented)
    createClassification(context: SceneContext): void;
    static createFromProps(_props: ViewStateProps, _iModel: IModelConnection): ViewState | undefined;
    // @internal (undocumented)
    createProviderGraphics(context: SceneContext): void;
    // @internal (undocumented)
    createScene(context: SceneContext): void;
    // @internal (undocumented)
    createSolarShadowMap(_context: SceneContext): void;
    // @internal
    decorate(context: DecorateContext): void;
    abstract readonly defaultExtentLimits: ExtentLimits;
    // (undocumented)
    description?: string;
    displayStyle: DisplayStyleState;
    // @internal (undocumented)
    drawGrid(context: DecorateContext): void;
    equals(other: this): boolean;
    extentLimits: ExtentLimits;
    abstract forEachModel(func: (model: GeometricModelState) => void): void;
    // @alpha
    forEachTileTreeModel(func: (model: TileTreeModelState) => void): void;
    getAspectRatio(): number;
    getAspectRatioSkew(): number;
    getAuxiliaryCoordinateSystemId(): Id64String;
    getCenter(result?: Point3d): Point3d;
    // @internal
    getDetail(name: string): any;
    // (undocumented)
    getDetails(): any;
    abstract getExtents(): Vector3d;
    getGridOrientation(): GridOrientationType;
    getGridSettings(vp: Viewport, origin: Point3d, rMatrix: Matrix3d, orientation: GridOrientationType): void;
    // (undocumented)
    getGridSpacing(): XAndY;
    // (undocumented)
    getGridsPerRef(): number;
    abstract getOrigin(): Point3d;
    abstract getRotation(): Matrix3d;
    // @internal (undocumented)
    static getStandardViewMatrix(id: StandardViewId): Matrix3d;
    getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined;
    getTargetPoint(result?: Point3d): Point3d;
    getViewClip(): ClipVector | undefined;
    abstract getViewedExtents(): AxisAlignedBox3d;
    getXVector(result?: Vector3d): Vector3d;
    getYVector(result?: Vector3d): Vector3d;
    getZVector(result?: Vector3d): Vector3d;
    is2d(): this is ViewState2d;
    is3d(): this is ViewState3d;
    // (undocumented)
    isPrivate?: boolean;
    isSpatialView(): this is SpatialViewState;
    // @internal (undocumented)
    isSubCategoryVisible(id: Id64String): boolean;
    load(): Promise<void>;
    lookAtViewAlignedVolume(volume: Range3d, aspect?: number, margin?: MarginPercent): void;
    lookAtVolume(volume: LowAndHighXYZ | LowAndHighXY, aspect?: number, margin?: MarginPercent): void;
    readonly name: string;
    // @internal
    abstract onRenderFrame(_viewport: Viewport): void;
    // @internal
    peekDetail(name: string): any;
    // @internal
    removeDetail(name: string): void;
    resetExtentLimits(): void;
    // @internal (undocumented)
    abstract saveForUndo(): ViewStateUndo;
    readonly scheduleScript: RenderScheduleState.Script | undefined;
    setAspectRatioSkew(val: number): void;
    setAuxiliaryCoordinateSystem(acs?: AuxCoordSystemState): void;
    setCategorySelector(categories: CategorySelectorState): void;
    // @internal
    setDetail(name: string, value: any): void;
    // (undocumented)
    setDisplayStyle(style: DisplayStyleState): void;
    abstract setExtents(viewDelta: Vector3d): void;
    // @internal (undocumented)
    abstract setFromUndo(props: ViewStateUndo): void;
    setGridSettings(orientation: GridOrientationType, spacing: Point2d, gridsPerRef: number): void;
    abstract setOrigin(viewOrg: Point3d): void;
    abstract setRotation(viewRot: Matrix3d): void;
    setRotationAboutPoint(rotation: Matrix3d, point?: Point3d): void;
    setStandardRotation(id: StandardViewId): void;
    setupFromFrustum(inFrustum: Frustum): ViewStatus;
    setViewClip(clip?: ClipVector): void;
    // @internal (undocumented)
    showFrustumErrorMessage(status: ViewStatus): void;
    // (undocumented)
    toJSON(): ViewDefinitionProps;
    // @internal (undocumented)
    validateViewDelta(delta: Vector3d, messageNeeded?: boolean): ViewStatus;
    readonly viewFlags: ViewFlags;
    viewsCategory(id: Id64String): boolean;
    abstract viewsModel(modelId: Id64String): boolean;
}

// @public
export abstract class ViewState2d extends ViewState {
    constructor(props: ViewDefinition2dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle2dState);
    // (undocumented)
    allow3dManipulations(): boolean;
    // (undocumented)
    readonly angle: Angle;
    // (undocumented)
    readonly baseModelId: Id64String;
    // @internal (undocumented)
    static readonly className: string;
    // (undocumented)
    computeFitRange(): Range3d;
    // (undocumented)
    createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    // (undocumented)
    readonly delta: Point2d;
    // (undocumented)
    forEachModel(func: (model: GeometricModelState) => void): void;
    // (undocumented)
    getExtents(): Vector3d;
    // (undocumented)
    getOrigin(): Point3d;
    // (undocumented)
    getRotation(): Matrix3d;
    // (undocumented)
    getViewedExtents(): AxisAlignedBox3d;
    getViewedModel(): GeometricModel2dState | undefined;
    // (undocumented)
    load(): Promise<void>;
    // (undocumented)
    onRenderFrame(_viewport: Viewport): void;
    // (undocumented)
    readonly origin: Point2d;
    // @internal (undocumented)
    saveForUndo(): ViewStateUndo;
    // (undocumented)
    setExtents(delta: Vector3d): void;
    // @internal (undocumented)
    setFromUndo(val: ViewState2dUndo): void;
    // (undocumented)
    setOrigin(origin: Point3d): void;
    // (undocumented)
    setRotation(rot: Matrix3d): void;
    // (undocumented)
    toJSON(): ViewDefinition2dProps;
    // (undocumented)
    viewsModel(modelId: Id64String): boolean;
}

// @public
export abstract class ViewState3d extends ViewState {
    constructor(props: ViewDefinition3dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle3dState);
    // (undocumented)
    allow3dManipulations(): boolean;
    calcLensAngle(): Angle;
    // (undocumented)
    protected static calculateMaxDepth(delta: Vector3d, zVec: Vector3d): number;
    readonly camera: Camera;
    protected _cameraOn: boolean;
    centerEyePoint(backDistance?: number): void;
    centerFocusDistance(): void;
    // @internal (undocumented)
    static readonly className: string;
    // (undocumented)
    createAuxCoordSystem(acsName: string): AuxCoordSystemState;
    // (undocumented)
    decorate(context: DecorateContext): void;
    // @internal (undocumented)
    protected drawGroundPlane(context: DecorateContext): void;
    // @internal (undocumented)
    protected drawSkyBox(context: DecorateContext): void;
    // @internal (undocumented)
    protected enableCamera(): void;
    readonly extents: Vector3d;
    forceMinFrontDist: number;
    getBackDistance(): number;
    // (undocumented)
    getDisplayStyle3d(): DisplayStyle3dState;
    // (undocumented)
    getExtents(): Vector3d;
    getEyePoint(): Point3d;
    getFocusDistance(): number;
    getFrontDistance(): number;
    getGroundElevation(): number;
    getGroundExtents(vp?: Viewport): AxisAlignedBox3d;
    getLensAngle(): Angle;
    // (undocumented)
    getOrigin(): Point3d;
    // (undocumented)
    getRotation(): Matrix3d;
    getTargetPoint(result?: Point3d): Point3d;
    // (undocumented)
    readonly isCameraOn: boolean;
    readonly isCameraValid: boolean;
    // (undocumented)
    isEyePointAbove(elevation: number): boolean;
    lookAt(eyePoint: XYAndZ, targetPoint: XYAndZ, upVector: Vector3d, newExtents?: XAndY, frontDistance?: number, backDistance?: number): ViewStatus;
    lookAtUsingLensAngle(eyePoint: Point3d, targetPoint: Point3d, upVector: Vector3d, fov: Angle, frontDistance?: number, backDistance?: number): ViewStatus;
    // (undocumented)
    minimumFrontDistance(): number;
    moveCameraLocal(distance: Vector3d): ViewStatus;
    moveCameraWorld(distance: Vector3d): ViewStatus;
    // (undocumented)
    onRenderFrame(_viewport: Viewport): void;
    readonly origin: Point3d;
    rotateCameraLocal(angle: Angle, axis: Vector3d, aboutPt?: Point3d): ViewStatus;
    rotateCameraWorld(angle: Angle, axis: Vector3d, aboutPt?: Point3d): ViewStatus;
    readonly rotation: Matrix3d;
    // @internal (undocumented)
    saveForUndo(): ViewStateUndo;
    // (undocumented)
    setExtents(extents: XYAndZ): void;
    setEyePoint(pt: XYAndZ): void;
    setFocusDistance(dist: number): void;
    // @internal (undocumented)
    setFromUndo(val: ViewState3dUndo): void;
    setLensAngle(angle: Angle): void;
    // (undocumented)
    setOrigin(origin: XYAndZ): void;
    // (undocumented)
    setRotation(rot: Matrix3d): void;
    // (undocumented)
    setupFromFrustum(frustum: Frustum): ViewStatus;
    // (undocumented)
    supportsCamera(): boolean;
    // (undocumented)
    toJSON(): ViewDefinition3dProps;
    turnCameraOff(): void;
    verifyFocusPlane(): void;
}

// @internal (undocumented)
export abstract class ViewStateUndo {
    // (undocumented)
    abstract equalState(view: ViewState): boolean;
    // (undocumented)
    undoTime?: BeTimePoint;
}

// @public
export enum ViewStatus {
    // (undocumented)
    AlreadyAttached = 2,
    // (undocumented)
    DrawFailure = 4,
    // (undocumented)
    InvalidLens = 14,
    // (undocumented)
    InvalidTargetPoint = 13,
    // (undocumented)
    InvalidUpVector = 12,
    // (undocumented)
    InvalidViewport = 15,
    // (undocumented)
    InvalidWindow = 7,
    // (undocumented)
    MaxDisplayDepth = 11,
    // (undocumented)
    MaxWindow = 9,
    // (undocumented)
    MaxZoom = 10,
    // (undocumented)
    MinWindow = 8,
    // (undocumented)
    ModelNotFound = 6,
    // (undocumented)
    NotAttached = 3,
    // (undocumented)
    NotResized = 5,
    // (undocumented)
    Success = 0,
    // (undocumented)
    ViewNotInitialized = 1
}

// @public
export class ViewToggleCameraTool extends ViewTool {
    // (undocumented)
    onInstall(): boolean;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export abstract class ViewTool extends InteractiveTool {
    constructor(viewport?: ScreenViewport | undefined);
    // (undocumented)
    beginDynamicUpdate(): void;
    // (undocumented)
    endDynamicUpdate(): void;
    exitTool(): void;
    // (undocumented)
    inDynamicUpdate: boolean;
    // (undocumented)
    onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    run(): boolean;
    // (undocumented)
    static showPrompt(prompt: string): void;
    // (undocumented)
    viewport?: ScreenViewport | undefined;
}

// @beta
export enum ViewUndoEvent {
    // (undocumented)
    Redo = 1,
    // (undocumented)
    Undo = 0
}

// @public
export class ViewUndoTool extends ViewTool {
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    static toolId: string;
}

// @public
export class WalkViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}

// @internal (undocumented)
export type WebGLExtensionName = "WEBGL_draw_buffers" | "OES_element_index_uint" | "OES_texture_float" | "OES_texture_half_float" | "WEBGL_depth_texture" | "EXT_color_buffer_float" | "EXT_shader_texture_lod" | "ANGLE_instanced_arrays";

// @internal
export class WheelEventProcessor {
    // (undocumented)
    static process(ev: BeWheelEvent, doUpdate: boolean): Promise<void>;
}

// @public
export class WindowAreaTool extends ViewTool {
    // (undocumented)
    decorate(context: DecorateContext): void;
    // (undocumented)
    onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onMouseMotion(ev: BeButtonEvent): Promise<void>;
    // (undocumented)
    onPostInstall(): void;
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchCancel(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchComplete(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMove(ev: BeTouchEvent): Promise<void>;
    // (undocumented)
    onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    onTouchTap(ev: BeTouchEvent): Promise<EventHandled>;
    // (undocumented)
    static toolId: string;
}

// @public
export interface ZoomToOptions {
    placementRelativeId?: StandardViewId;
    standardViewId?: StandardViewId;
    viewRotation?: Matrix3d;
}

// @public
export class ZoomViewTool extends ViewManip {
    constructor(vp: ScreenViewport, oneShot?: boolean, isDraggingRequired?: boolean);
    // (undocumented)
    onReinitialize(): void;
    // (undocumented)
    static toolId: string;
}


// (No @packageDocumentation comment for this package)

```
