## API Review File for "@bentley/presentation-common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { BeEvent } from '@bentley/bentleyjs-core';
import { BentleyError } from '@bentley/bentleyjs-core';
import { EntityProps } from '@bentley/imodeljs-common';
import { GetMetaDataFunction } from '@bentley/bentleyjs-core';
import { GuidString } from '@bentley/bentleyjs-core';
import { Id64String } from '@bentley/bentleyjs-core';
import { IDisposable } from '@bentley/bentleyjs-core';
import { IModelToken } from '@bentley/imodeljs-common';
import { LogFunction } from '@bentley/bentleyjs-core';
import { RpcInterface } from '@bentley/imodeljs-common';

// Warning: (ae-forgotten-export) The symbol "ChildNodeSpecificationBase" needs to be exported by the entry point presentation-common.d.ts
// Warning: (ae-forgotten-export) The symbol "DefaultGroupingPropertiesContainer" needs to be exported by the entry point presentation-common.d.ts
// 
// @public
export interface AllInstanceNodesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    specType: RuleSpecificationTypes.AllInstanceNodes;
    supportedSchemas?: SchemasSpecification;
}

// @public
export interface AllRelatedInstanceNodesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    requiredDirection?: RelationshipDirection;
    skipRelatedLevel?: number;
    specType: RuleSpecificationTypes.AllRelatedInstanceNodes;
    supportedSchemas?: SchemasSpecification;
}

// Warning: (ae-forgotten-export) The symbol "BaseTypeDescription" needs to be exported by the entry point presentation-common.d.ts
// 
// @public
export interface ArrayTypeDescription extends BaseTypeDescription {
    // (undocumented)
    memberType: TypeDescription;
    // (undocumented)
    valueFormat: PropertyValueFormat.Array;
}

// @public
export interface BaseFieldJSON {
    // (undocumented)
    category: CategoryDescription;
    // (undocumented)
    editor?: EditorDescription;
    // (undocumented)
    isReadonly: boolean;
    // (undocumented)
    label: string;
    // (undocumented)
    name: string;
    // (undocumented)
    priority: number;
    // (undocumented)
    type: TypeDescription;
}

// @public
export interface BaseNodeKey {
    pathFromRoot: string[];
    type: string;
}

// @public
export interface CalculatedPropertiesSpecification {
    label: string;
    priority?: number;
    value: string;
}

// @public
export interface CategoryDescription {
    description: string;
    expand: boolean;
    label: string;
    name: string;
    priority: number;
}

// Warning: (ae-forgotten-export) The symbol "RuleBase" needs to be exported by the entry point presentation-common.d.ts
// Warning: (ae-forgotten-export) The symbol "ConditionContainer" needs to be exported by the entry point presentation-common.d.ts
// 
// @public
export interface CheckBoxRule extends RuleBase, ConditionContainer {
    condition?: string;
    defaultValue?: boolean;
    isEnabled?: string | boolean;
    propertyName?: string;
    ruleType: RuleTypes.CheckBox;
    useInversedPropertyValue?: boolean;
}

// Warning: (ae-forgotten-export) The symbol "NavigationRuleBase" needs to be exported by the entry point presentation-common.d.ts
// 
// @public
export interface ChildNodeRule extends NavigationRuleBase, ConditionContainer {
    condition?: string;
    ruleType: RuleTypes.ChildNodes;
}

// Warning: (ae-forgotten-export) The symbol "GroupingSpecificationBase" needs to be exported by the entry point presentation-common.d.ts
// 
// @public
export interface ClassGroup extends GroupingSpecificationBase {
    baseClass?: SingleSchemaClassSpecification;
    createGroupForSingleItem?: boolean;
    specType: GroupingSpecificationTypes.Class;
}

// @public (undocumented)
export type ClassId = Id64String;

// @public
export interface ClassInfo {
    // (undocumented)
    id: ClassId;
    // (undocumented)
    label: string;
    // (undocumented)
    name: string;
}

// @public
export const classInfoFromJSON: (json: ClassInfoJSON) => ClassInfo;

// @public
export interface ClassInfoJSON {
    // (undocumented)
    id: string;
    // (undocumented)
    label: string;
    // (undocumented)
    name: string;
}

// @public (undocumented)
export type ClientStateSyncRequestOptions = RpcRequestOptions & {
    state: {
        [id: string]: unknown;
    };
};

// @public
export const compareInstanceKeys: (lhs: InstanceKey, rhs: InstanceKey) => number;

// @public
export class Content {
    contentSet: Array<Readonly<Item>>;
    descriptor: Readonly<Descriptor>;
    static fromJSON(json: ContentJSON | string | undefined): Content | undefined;
    static reviver(key: string, value: any): any;
}

// @public
export enum ContentFlags {
    DistinctValues = 16,
    KeysOnly = 1,
    MergeResults = 8,
    NoFields = 32,
    ShowImages = 2,
    ShowLabels = 4
}

// Warning: (ae-forgotten-export) The symbol "ContentSpecificationBase" needs to be exported by the entry point presentation-common.d.ts
// 
// @public
export interface ContentInstancesOfSpecificClassesSpecification extends ContentSpecificationBase {
    arePolymorphic?: boolean;
    classes: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    instanceFilter?: string;
    specType: RuleSpecificationTypes.ContentInstancesOfSpecificClasses;
}

// @public
export interface ContentJSON {
    // (undocumented)
    contentSet: ItemJSON[];
    // (undocumented)
    descriptor: DescriptorJSON;
}

// @public
export interface ContentModifier extends RuleBase {
    calculatedProperties?: CalculatedPropertiesSpecification[];
    class?: SingleSchemaClassSpecification;
    propertiesDisplay?: PropertiesDisplaySpecification[];
    propertyEditors?: PropertyEditorsSpecification[];
    relatedProperties?: RelatedPropertiesSpecification[];
    ruleType: RuleTypes.ContentModifier;
}

// @public
export interface ContentRelatedInstancesSpecification extends ContentSpecificationBase {
    instanceFilter?: string;
    isRecursive?: boolean;
    relatedClasses?: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    relationships?: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    requiredDirection?: RelationshipDirection;
    skipRelatedLevel?: number;
    specType: RuleSpecificationTypes.ContentRelatedInstances;
}

// @public
export interface ContentRequestOptions<TIModel> extends RequestOptionsWithRuleset<TIModel> {
}

// @public
export interface ContentResponse {
    // (undocumented)
    content: Readonly<Content> | undefined;
    // (undocumented)
    size: number;
}

// @public (undocumented)
export type ContentRpcRequestOptions = RpcRequestOptions & Omit<ContentRequestOptions<IModelToken>, "imodel">;

// @public
export interface ContentRule extends RuleBase, ConditionContainer {
    condition?: string;
    ruleType: RuleTypes.Content;
    // Warning: (ae-forgotten-export) The symbol "ContentSpecification" needs to be exported by the entry point presentation-common.d.ts
    specifications: ContentSpecification[];
}

// @public
export interface CustomNodeSpecification extends ChildNodeSpecificationBase {
    description?: string;
    imageId?: string;
    label: string;
    specType: RuleSpecificationTypes.CustomNode;
    type: string;
}

// @public
export interface CustomQueryInstanceNodesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    // Warning: (ae-forgotten-export) The symbol "QuerySpecification" needs to be exported by the entry point presentation-common.d.ts
    queries?: QuerySpecification[];
    specType: RuleSpecificationTypes.CustomQueryInstanceNodes;
}

// @public
export class DefaultContentDisplayTypes {
    static readonly GRID = "Grid";
    static readonly LIST = "List";
    static readonly PROPERTY_PANE = "PropertyPane";
    static readonly UNDEFINED = "Undefined";
    static readonly VIEWPORT = "Graphics";
}

// @public
export class Descriptor {
    connectionId: string;
    contentFlags: number;
    contentOptions: any;
    // (undocumented)
    createDescriptorOverrides(): DescriptorOverrides;
    // (undocumented)
    createStrippedDescriptor(): Descriptor;
    displayType: string;
    fields: Field[];
    filterExpression?: string;
    static fromJSON(json: DescriptorJSON | string | undefined): Descriptor | undefined;
    getFieldByName(name: string, recurse?: boolean): Field | undefined;
    inputKeysHash: string;
    // (undocumented)
    rebuildParentship(): void;
    // (undocumented)
    resetParentship(): void;
    static reviver(key: string, value: any): any;
    selectClasses: SelectClassInfo[];
    selectionInfo?: SelectionInfo;
    sortDirection?: SortDirection;
    sortingField?: Field;
}

// @public
export interface DescriptorJSON {
    // (undocumented)
    connectionId: string;
    // (undocumented)
    contentFlags: number;
    // (undocumented)
    contentOptions: any;
    // (undocumented)
    displayType: string;
    // (undocumented)
    fields: FieldJSON[];
    // (undocumented)
    filterExpression?: string;
    // (undocumented)
    inputKeysHash: string;
    // (undocumented)
    selectClasses: SelectClassInfoJSON[];
    // (undocumented)
    selectionInfo?: SelectionInfo;
    // (undocumented)
    sortDirection?: SortDirection;
    // (undocumented)
    sortingFieldName?: string;
}

// @public
export interface DescriptorOverrides {
    // (undocumented)
    contentFlags: number;
    // (undocumented)
    displayType: string;
    // (undocumented)
    filterExpression?: string;
    // (undocumented)
    hiddenFieldNames: string[];
    // (undocumented)
    sortDirection?: SortDirection;
    // (undocumented)
    sortingFieldName?: string;
}

// @public (undocumented)
export type DisplayValue = string | undefined | DisplayValuesMap | DisplayValuesArray;

// @public (undocumented)
export function displayValueFromJSON(json: DisplayValueJSON): DisplayValue;

// @public (undocumented)
export type DisplayValueJSON = string | null | DisplayValuesMapJSON | DisplayValuesArrayJSON;

// @public (undocumented)
export interface DisplayValuesArray extends Array<DisplayValue> {
}

// @public (undocumented)
export function displayValuesArrayFromJSON(json: DisplayValuesArrayJSON): DisplayValuesArray;

// @public (undocumented)
export interface DisplayValuesArrayJSON extends Array<DisplayValueJSON> {
}

// @public (undocumented)
export interface DisplayValuesMap extends ValuesDictionary<DisplayValue> {
}

// @public (undocumented)
export function displayValuesMapFromJSON(json: DisplayValuesMapJSON): DisplayValuesMap;

// @public (undocumented)
export interface DisplayValuesMapJSON extends ValuesDictionary<DisplayValueJSON> {
}

// Warning: (ae-forgotten-export) The symbol "GroupingNodeKey" needs to be exported by the entry point presentation-common.d.ts
// 
// @public
export interface ECClassGroupingNodeKey extends GroupingNodeKey {
    className: string;
    // (undocumented)
    type: StandardNodeTypes.ECClassGroupingNode;
}

// @public
export interface ECInstanceNodeKey extends BaseNodeKey {
    instanceKey: InstanceKey;
    // (undocumented)
    type: StandardNodeTypes.ECInstanceNode;
}

// @public
export interface ECInstanceNodeKeyJSON extends BaseNodeKey {
    // (undocumented)
    instanceKey: InstanceKeyJSON;
    // (undocumented)
    type: StandardNodeTypes.ECInstanceNode;
}

// @public
export interface ECPropertyGroupingNodeKey extends GroupingNodeKey {
    className: string;
    groupingValue: any;
    propertyName: string;
    // (undocumented)
    type: StandardNodeTypes.ECPropertyGroupingNode;
}

// Warning: (ae-forgotten-export) The symbol "QuerySpecificationBase" needs to be exported by the entry point presentation-common.d.ts
// 
// @public
export interface ECPropertyValueQuerySpecification extends QuerySpecificationBase {
    parentPropertyName: string;
    specType: QuerySpecificationTypes.ECPropertyValue;
}

// @public
export interface EditorDescription {
    name: string;
    params: any;
}

// @public
export interface EnumerationChoice {
    // (undocumented)
    label: string;
    // (undocumented)
    value: string | number;
}

// @public
export interface EnumerationInfo {
    // (undocumented)
    choices: EnumerationChoice[];
    // (undocumented)
    isStrict: boolean;
}

// @public
export class Field {
    constructor(category: CategoryDescription, name: string, label: string, type: TypeDescription, isReadonly: boolean, priority: number, editor?: EditorDescription);
    category: Readonly<CategoryDescription>;
    editor?: Readonly<EditorDescription>;
    static fromJSON(json: FieldJSON | string | undefined): Field | undefined;
    isNestedContentField(): this is NestedContentField;
    isPropertiesField(): this is PropertiesField;
    isReadonly: boolean;
    label: string;
    name: string;
    readonly parent: Readonly<NestedContentField> | undefined;
    priority: number;
    // (undocumented)
    rebuildParentship(parentField?: NestedContentField): void;
    // (undocumented)
    resetParentship(): void;
    static reviver(key: string, value: any): any;
    type: Readonly<TypeDescription>;
}

// @public (undocumented)
export type FieldJSON = BaseFieldJSON | PropertiesFieldJSON | NestedContentFieldJSON;

// @public
export const getInstancesCount: (keys: Readonly<KeySet>) => number;

// @public
export interface GroupingRule extends RuleBase, ConditionContainer {
    class: SingleSchemaClassSpecification;
    condition?: string;
    groups: GroupingSpecification[];
    ruleType: RuleTypes.Grouping;
}

// @public
export type GroupingSpecification = ClassGroup | PropertyGroup | SameLabelInstanceGroup;

// @public
export const enum GroupingSpecificationTypes {
    // (undocumented)
    Class = "Class",
    // (undocumented)
    Property = "Property",
    // (undocumented)
    SameLabelInstance = "SameLabelInstance"
}

// @public
export interface HierarchyRequestOptions<TIModel> extends RequestOptionsWithRuleset<TIModel> {
}

// @public (undocumented)
export type HierarchyRpcRequestOptions = RpcRequestOptions & Omit<HierarchyRequestOptions<IModelToken>, "imodel">;

// @public
export interface IClientStateHolder<TState> {
    // (undocumented)
    key: string;
    // (undocumented)
    onStateChanged: BeEvent<() => void>;
    // (undocumented)
    state: TState | undefined;
}

// @public
export interface ImageIdOverride extends RuleBase, ConditionContainer {
    condition?: string;
    imageIdExpression: string;
    ruleType: RuleTypes.ImageIdOverride;
}

// @public (undocumented)
export type InstanceId = Id64String;

// @public
export interface InstanceKey {
    // (undocumented)
    className: string;
    // (undocumented)
    id: InstanceId;
}

// @public
export const instanceKeyFromJSON: (json: InstanceKeyJSON) => InstanceKey;

// @public
export interface InstanceKeyJSON {
    // (undocumented)
    className: string;
    // (undocumented)
    id: string;
}

// @public
export type InstanceKeysList = InstanceKey[];

// @public
export interface InstanceLabelOverride extends RuleBase {
    class: SingleSchemaClassSpecification;
    propertyNames: string[];
    ruleType: RuleTypes.InstanceLabelOverride;
}

// @public
export interface InstanceNodesOfSpecificClassesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    arePolymorphic?: boolean;
    classes: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    instanceFilter?: string;
    specType: RuleSpecificationTypes.InstanceNodesOfSpecificClasses;
}

// @public (undocumented)
export function isArray(v: Value | ValueJSON | DisplayValue | DisplayValueJSON): v is ValuesArray | ValuesArrayJSON | DisplayValuesArray | DisplayValuesArrayJSON;

// @public
export const isClassGroupingNodeKey: (key: NodeKey) => key is ECClassGroupingNodeKey;

// @public
export const isGroupingNodeKey: (key: NodeKey) => key is GroupingNodeKey;

// @public
export const isInstanceNodeKey: (key: NodeKey) => key is ECInstanceNodeKey;

// @public
export const isLabelGroupingNodeKey: (key: NodeKey) => key is LabelGroupingNodeKey;

// @public (undocumented)
export function isMap(v: Value | ValueJSON | DisplayValue | DisplayValueJSON): v is ValuesMap | ValuesMapJSON | DisplayValuesMap | DisplayValuesMapJSON;

// @public (undocumented)
export function isNestedContentValue(v: Value | ValueJSON): v is NestedContentValue[] | NestedContentValueJSON[];

// @public (undocumented)
export function isPrimitive(v: Value | DisplayValue): v is string | number | boolean | undefined;

// @public
export const isPropertyGroupingNodeKey: (key: NodeKey) => key is ECPropertyGroupingNodeKey;

// @public
export class Item {
    constructor(primaryKeys: InstanceKey[], label: string, imageId: string, classInfo: ClassInfo | undefined, values: ValuesDictionary<Value>, displayValues: ValuesDictionary<DisplayValue>, mergedFieldNames: string[]);
    classInfo?: Readonly<ClassInfo>;
    displayValues: Readonly<ValuesDictionary<DisplayValue>>;
    static fromJSON(json: ItemJSON | string | undefined): Item | undefined;
    imageId: string;
    isFieldMerged(fieldName: string): boolean;
    label: string;
    mergedFieldNames: string[];
    primaryKeys: Array<Readonly<InstanceKey>>;
    static reviver(key: string, value: any): any;
    values: Readonly<ValuesDictionary<Value>>;
}

// @public
export interface ItemJSON {
    // (undocumented)
    classInfo?: ClassInfoJSON;
    // (undocumented)
    displayValues: ValuesDictionary<DisplayValueJSON>;
    // (undocumented)
    imageId: string;
    // (undocumented)
    label: string;
    // (undocumented)
    mergedFieldNames: string[];
    // (undocumented)
    primaryKeys: InstanceKeyJSON[];
    // (undocumented)
    values: ValuesDictionary<ValueJSON>;
}

// @public
export type Key = Readonly<NodeKey> | Readonly<InstanceKey> | Readonly<EntityProps>;

// Warning: (ae-forgotten-export) The symbol "KeySetJSON" needs to be exported by the entry point presentation-common.d.ts
// 
// @public
export type Keys = ReadonlyArray<Key> | Readonly<KeySetJSON> | Readonly<KeySet>;

// @public
export class KeySet {
    constructor(source?: Keys);
    add(value: Keys | Key): KeySet;
    clear(): KeySet;
    delete(value: Keys | Key): KeySet;
    readonly guid: GuidString;
    has(value: Key): boolean;
    hasAll(keys: Keys): boolean;
    hasAny(keys: Keys): boolean;
    readonly instanceKeys: Map<string, Set<InstanceId>>;
    readonly instanceKeysCount: number;
    readonly isEmpty: boolean;
    readonly nodeKeys: Set<NodeKey>;
    readonly nodeKeysCount: number;
    readonly size: number;
}

// @public
export interface KindOfQuantityInfo {
    // (undocumented)
    currentFormatId: string;
    // (undocumented)
    label: string;
    // (undocumented)
    name: string;
    // (undocumented)
    persistenceUnit: string;
}

// @public
export interface LabelGroupingNodeKey extends GroupingNodeKey {
    label: string;
    // (undocumented)
    type: StandardNodeTypes.DisplayLabelGroupingNode;
}

// @public
export interface LabelOverride extends RuleBase, ConditionContainer {
    condition?: string;
    description?: string;
    label?: string;
    ruleType: RuleTypes.LabelOverride;
}

// @public
export interface LabelRequestOptions<TIModel> extends RequestOptions<TIModel> {
}

// @public (undocumented)
export type LabelRpcRequestOptions = RpcRequestOptions & Omit<LabelRequestOptions<IModelToken>, "imodel">;

// @public
export const enum LoggingNamespaces {
    // (undocumented)
    ECObjects = "ECObjects",
    // (undocumented)
    ECObjects_ECExpressions = "ECObjects.ECExpressions",
    // (undocumented)
    ECObjects_ECExpressions_Evaluate = "ECObjects.ECExpressions.Evaluate",
    // (undocumented)
    ECObjects_ECExpressions_Parse = "ECObjects.ECExpressions.Parse",
    // (undocumented)
    ECPresentation = "ECPresentation",
    // (undocumented)
    ECPresentation_Connections = "ECPresentation.Connections",
    // (undocumented)
    ECPresentation_RulesEngine = "ECPresentation.RulesEngine",
    // (undocumented)
    ECPresentation_RulesEngine_Content = "ECPresentation.RulesEngine.Content",
    // (undocumented)
    ECPresentation_RulesEngine_Localization = "ECPresentation.RulesEngine.Localization",
    // (undocumented)
    ECPresentation_RulesEngine_Navigation = "ECPresentation.RulesEngine.Navigation",
    // (undocumented)
    ECPresentation_RulesEngine_Navigation_Cache = "ECPresentation.RulesEngine.Navigation.Cache",
    // (undocumented)
    ECPresentation_RulesEngine_RulesetVariables = "ECPresentation.RulesEngine.RulesetVariables",
    // (undocumented)
    ECPresentation_RulesEngine_Threads = "ECPresentation.RulesEngine.Threads",
    // (undocumented)
    ECPresentation_RulesEngine_Update = "ECPresentation.RulesEngine.Update"
}

// @public
export interface MultiSchemaClassesSpecification {
    classNames: string[];
    schemaName: string;
}

// @public
export class NestedContentField extends Field {
    constructor(category: CategoryDescription, name: string, label: string, description: TypeDescription, isReadonly: boolean, priority: number, contentClassInfo: ClassInfo, pathToPrimaryClass: RelationshipPathInfo, nestedFields: Field[], editor?: EditorDescription);
    contentClassInfo: ClassInfo;
    static fromJSON(json: NestedContentFieldJSON | string | undefined): NestedContentField | undefined;
    nestedFields: Array<Readonly<Field>>;
    pathToPrimaryClass: RelationshipPathInfo;
    // (undocumented)
    rebuildParentship(parentField?: NestedContentField): void;
    // (undocumented)
    resetParentship(): void;
}

// @public
export interface NestedContentFieldJSON extends BaseFieldJSON {
    // (undocumented)
    contentClassInfo: ClassInfoJSON;
    // (undocumented)
    nestedFields: FieldJSON[];
    // (undocumented)
    pathToPrimaryClass: RelationshipPathInfoJSON;
}

// @public
export interface NestedContentValue {
    // (undocumented)
    displayValues: ValuesDictionary<DisplayValue>;
    // (undocumented)
    mergedFieldNames: string[];
    // (undocumented)
    primaryKeys: InstanceKey[];
    // (undocumented)
    values: ValuesDictionary<Value>;
}

// @public (undocumented)
export function nestedContentValueFromJSON(json: NestedContentValueJSON): NestedContentValue;

// @public
export interface NestedContentValueJSON {
    // (undocumented)
    displayValues: ValuesDictionary<DisplayValueJSON>;
    // (undocumented)
    mergedFieldNames: string[];
    // (undocumented)
    primaryKeys: InstanceKeyJSON[];
    // (undocumented)
    values: ValuesDictionary<ValueJSON>;
}

// @public
export interface Node {
    backColor?: string;
    description?: string;
    fontStyle?: string;
    foreColor?: string;
    hasChildren?: boolean;
    imageId?: string;
    isCheckboxEnabled?: boolean;
    isCheckboxVisible?: boolean;
    isChecked?: boolean;
    isEditable?: boolean;
    isExpanded?: boolean;
    isSelectionDisabled?: boolean;
    key: NodeKey;
    label: string;
}

// @public
export interface NodeJSON {
    // (undocumented)
    backColor?: string;
    // (undocumented)
    description?: string;
    // (undocumented)
    fontStyle?: string;
    // (undocumented)
    foreColor?: string;
    // (undocumented)
    hasChildren?: boolean;
    // (undocumented)
    imageId?: string;
    // (undocumented)
    isCheckboxEnabled?: boolean;
    // (undocumented)
    isCheckboxVisible?: boolean;
    // (undocumented)
    isChecked?: boolean;
    // (undocumented)
    isEditable?: boolean;
    // (undocumented)
    isExpanded?: boolean;
    // (undocumented)
    isSelectionDisabled?: boolean;
    // (undocumented)
    key: NodeKeyJSON;
    // (undocumented)
    label: string;
}

// @public
export type NodeKey = BaseNodeKey | ECInstanceNodeKey | ECClassGroupingNodeKey | ECPropertyGroupingNodeKey | LabelGroupingNodeKey;

// @public
export const nodeKeyFromJSON: (json: NodeKeyJSON) => NodeKey;

// @public
export type NodeKeyJSON = BaseNodeKey | ECInstanceNodeKeyJSON | ECClassGroupingNodeKey | ECPropertyGroupingNodeKey | LabelGroupingNodeKey;

// @public
export type NodeKeyPath = NodeKey[];

// @public
export interface NodePathElement {
    // (undocumented)
    children: NodePathElement[];
    // Warning: (ae-forgotten-export) The symbol "NodePathFilteringData" needs to be exported by the entry point presentation-common.d.ts
    // 
    // (undocumented)
    filteringData?: NodePathFilteringData;
    // (undocumented)
    index: number;
    // (undocumented)
    isMarked: boolean;
    // (undocumented)
    node: Node;
}

// @public
export interface NodesResponse {
    // (undocumented)
    count: number;
    // (undocumented)
    nodes: ReadonlyArray<Node>;
}

// @public (undocumented)
export type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;

// @public
export type Paged<TOptions extends {}> = TOptions & {
    paging?: PageOptions;
};

// @public
export interface PageOptions {
    size?: number;
    start?: number;
}

// @public
export interface PersistentKeysContainer {
    // (undocumented)
    elements: Id64String[];
    // (undocumented)
    models: Id64String[];
    // (undocumented)
    nodes: NodeKey[];
}

// @public
export class PresentationError extends BentleyError {
    constructor(errorNumber: PresentationStatus, message?: string, log?: LogFunction, getMetaData?: GetMetaDataFunction);
    protected _initName(): string;
}

// @public
export class PresentationRpcInterface extends RpcInterface {
    // (undocumented)
    computeSelection(_token: IModelToken, _options: SelectionScopeRpcRequestOptions, _ids: Id64String[], _scopeId: string): PresentationRpcResponse<KeySet>;
    // (undocumented)
    getContent(_token: IModelToken, _options: ContentRpcRequestOptions, _descriptorOrOverrides: Descriptor | DescriptorOverrides, _keys: KeySet): PresentationRpcResponse<Content | undefined>;
    // (undocumented)
    getContentAndSize(_token: IModelToken, _options: ContentRpcRequestOptions, _descriptorOrOverrides: Descriptor | DescriptorOverrides, _keys: KeySet): PresentationRpcResponse<ContentResponse>;
    // (undocumented)
    getContentDescriptor(_token: IModelToken, _options: ContentRpcRequestOptions, _displayType: string, _keys: KeySet, _selection: SelectionInfo | undefined): PresentationRpcResponse<Descriptor | undefined>;
    // (undocumented)
    getContentSetSize(_token: IModelToken, _options: ContentRpcRequestOptions, _descriptorOrOverrides: Descriptor | DescriptorOverrides, _keys: KeySet): PresentationRpcResponse<number>;
    // (undocumented)
    getDisplayLabel(_token: IModelToken, _options: LabelRpcRequestOptions, _key: InstanceKey): PresentationRpcResponse<string>;
    // (undocumented)
    getDisplayLabels(_token: IModelToken, _options: LabelRpcRequestOptions, _keys: InstanceKey[]): PresentationRpcResponse<string[]>;
    // (undocumented)
    getDistinctValues(_token: IModelToken, _options: ContentRpcRequestOptions, _descriptor: Descriptor, _keys: KeySet, _fieldName: string, _maximumValueCount: number): PresentationRpcResponse<string[]>;
    // (undocumented)
    getFilteredNodePaths(_token: IModelToken, _options: HierarchyRpcRequestOptions, _filterText: string): PresentationRpcResponse<NodePathElement[]>;
    // (undocumented)
    getNodePaths(_token: IModelToken, _options: HierarchyRpcRequestOptions, _paths: InstanceKey[][], _markedIndex: number): PresentationRpcResponse<NodePathElement[]>;
    // (undocumented)
    getNodes(_token: IModelToken, _options: Paged<HierarchyRpcRequestOptions>, _parentKey?: NodeKey): PresentationRpcResponse<Node[]>;
    // (undocumented)
    getNodesAndCount(_token: IModelToken, _options: Paged<HierarchyRpcRequestOptions>, _parentKey?: NodeKey): PresentationRpcResponse<NodesResponse>;
    // (undocumented)
    getNodesCount(_token: IModelToken, _options: HierarchyRpcRequestOptions, _parentKey?: NodeKey): PresentationRpcResponse<number>;
    // (undocumented)
    getSelectionScopes(_token: IModelToken, _options: SelectionScopeRpcRequestOptions): PresentationRpcResponse<SelectionScope[]>;
    // (undocumented)
    syncClientState(_token: IModelToken, _options: ClientStateSyncRequestOptions): PresentationRpcResponse;
    static types: () => (typeof KeySet | typeof Field | typeof PropertiesField | typeof NestedContentField | typeof Descriptor | typeof Item | typeof Content)[];
    static version: string;
}

// @public (undocumented)
export type PresentationRpcResponse<P = undefined> = Promise<RpcResponse<P> | RpcResponse<undefined>>;

// @public
export enum PresentationStatus {
    // (undocumented)
    BackendOutOfSync = 65542,
    // (undocumented)
    Error = 65536,
    // (undocumented)
    InvalidArgument = 65539,
    // (undocumented)
    InvalidResponse = 65540,
    // (undocumented)
    NoContent = 65541,
    // (undocumented)
    NotInitialized = 65537,
    // (undocumented)
    Success = 0,
    // (undocumented)
    UseAfterDisposal = 65538
}

// @public
export interface PrimitiveTypeDescription extends BaseTypeDescription {
    // (undocumented)
    valueFormat: PropertyValueFormat.Primitive;
}

// @public
export interface PropertiesDisplaySpecification {
    isDisplayed?: boolean;
    priority?: number;
    propertyNames: string[];
}

// @public
export class PropertiesField extends Field {
    constructor(category: CategoryDescription, name: string, label: string, description: TypeDescription, isReadonly: boolean, priority: number, properties: Property[], editor?: EditorDescription);
    static fromJSON(json: PropertiesFieldJSON | string | undefined): PropertiesField | undefined;
    properties: Array<Readonly<Property>>;
}

// @public
export interface PropertiesFieldJSON extends BaseFieldJSON {
    // (undocumented)
    properties: PropertyJSON[];
}

// @public
export interface Property {
    property: Readonly<PropertyInfo>;
    relatedClassPath: Readonly<RelationshipPathInfo>;
}

// Warning: (ae-forgotten-export) The symbol "PropertyEditorParametersBase" needs to be exported by the entry point presentation-common.d.ts
// 
// @public
export interface PropertyEditorJsonParameters extends PropertyEditorParametersBase {
    json: any;
    paramsType: PropertyEditorParameterTypes.Json;
}

// @public
export interface PropertyEditorMultilineParameters extends PropertyEditorParametersBase {
    height?: number;
    paramsType: PropertyEditorParameterTypes.Multiline;
}

// @public
export const enum PropertyEditorParameterTypes {
    // (undocumented)
    Json = "Json",
    // (undocumented)
    Multiline = "Multiline",
    // (undocumented)
    Range = "Range",
    // (undocumented)
    Slider = "Slider"
}

// @public
export interface PropertyEditorRangeParameters extends PropertyEditorParametersBase {
    max?: number;
    min?: number;
    paramsType: PropertyEditorParameterTypes.Range;
}

// @public
export interface PropertyEditorSliderParameters extends PropertyEditorParametersBase {
    intervalsCount?: number;
    isVertical?: boolean;
    max: number;
    min: number;
    paramsType: PropertyEditorParameterTypes.Slider;
}

// @public
export interface PropertyEditorsSpecification {
    editorName: string;
    // Warning: (ae-forgotten-export) The symbol "PropertyEditorParameters" needs to be exported by the entry point presentation-common.d.ts
    parameters?: PropertyEditorParameters[];
    propertyName: string;
}

// @public
export interface PropertyGroup extends GroupingSpecificationBase {
    createGroupForSingleItem?: boolean;
    createGroupForUnspecifiedValues?: boolean;
    groupingValue?: PropertyGroupingValue;
    imageId?: string;
    propertyName: string;
    ranges?: PropertyRangeGroupSpecification[];
    sortingValue?: PropertyGroupingValue;
    specType: GroupingSpecificationTypes.Property;
}

// @public
export const enum PropertyGroupingValue {
    DisplayLabel = "DisplayLabel",
    PropertyValue = "PropertyValue"
}

// @public
export interface PropertyInfo {
    // (undocumented)
    classInfo: ClassInfo;
    // (undocumented)
    enumerationInfo?: EnumerationInfo;
    // (undocumented)
    kindOfQuantity?: KindOfQuantityInfo;
    // (undocumented)
    name: string;
    // (undocumented)
    type: string;
}

// @public
export const propertyInfoFromJSON: (json: PropertyInfoJSON) => PropertyInfo;

// @public
export interface PropertyInfoJSON {
    // (undocumented)
    classInfo: ClassInfoJSON;
    // (undocumented)
    enumerationInfo?: EnumerationInfo;
    // (undocumented)
    kindOfQuantity?: KindOfQuantityInfo;
    // (undocumented)
    name: string;
    // (undocumented)
    type: string;
}

// @public
export interface PropertyJSON {
    // (undocumented)
    property: PropertyInfoJSON;
    // (undocumented)
    relatedClassPath: RelationshipPathInfoJSON;
}

// @public
export interface PropertyRangeGroupSpecification {
    fromValue: string;
    imageId?: string;
    label?: string;
    toValue: string;
}

// @public
export enum PropertyValueFormat {
    // (undocumented)
    Array = "Array",
    // (undocumented)
    Primitive = "Primitive",
    // (undocumented)
    Struct = "Struct"
}

// @public
export const enum QuerySpecificationTypes {
    // (undocumented)
    ECPropertyValue = "ECPropertyValue",
    // (undocumented)
    String = "String"
}

// @public
export class RegisteredRuleset implements IDisposable, Ruleset {
    constructor(ruleset: Ruleset, uniqueIdentifier: string, disposeFunc: (ruleset: RegisteredRuleset) => void);
    // (undocumented)
    dispose(): void;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly rules: Rule[];
    // (undocumented)
    readonly supplementationInfo: SupplementationInfo | undefined;
    // (undocumented)
    readonly supportedSchemas: SchemasSpecification | undefined;
    // (undocumented)
    toJSON(): Ruleset;
    // (undocumented)
    readonly uniqueIdentifier: string;
    // (undocumented)
    readonly vars: VariablesGroup[] | undefined;
}

// @public
export interface RelatedClassInfo {
    isForwardRelationship: boolean;
    isPolymorphicRelationship: boolean;
    relationshipInfo: ClassInfo;
    sourceClassInfo: ClassInfo;
    targetClassInfo: ClassInfo;
}

// @public
export const relatedClassInfoFromJSON: (json: RelatedClassInfoJSON) => RelatedClassInfo;

// @public
export interface RelatedClassInfoJSON {
    // (undocumented)
    isForwardRelationship: boolean;
    // (undocumented)
    isPolymorphicRelationship: boolean;
    // (undocumented)
    relationshipInfo: ClassInfoJSON;
    // (undocumented)
    sourceClassInfo: ClassInfoJSON;
    // (undocumented)
    targetClassInfo: ClassInfoJSON;
}

// @public
export interface RelatedInstanceNodesSpecification extends ChildNodeSpecificationBase, DefaultGroupingPropertiesContainer {
    instanceFilter?: string;
    relatedClasses?: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    relationships?: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    requiredDirection?: RelationshipDirection;
    skipRelatedLevel?: number;
    specType: RuleSpecificationTypes.RelatedInstanceNodes;
    supportedSchemas?: string[];
}

// @public
export interface RelatedInstanceSpecification {
    alias: string;
    class: SingleSchemaClassSpecification;
    isRequired?: boolean;
    relationship: SingleSchemaClassSpecification;
    requiredDirection: RelationshipDirection.Forward | RelationshipDirection.Backward;
}

// @public
export interface RelatedPropertiesSpecification {
    isPolymorphic?: boolean;
    nestedRelatedProperties?: RelatedPropertiesSpecification[];
    // Warning: (ae-forgotten-export) The symbol "RelatedPropertiesSpecialValues" needs to be exported by the entry point presentation-common.d.ts
    propertyNames?: string[] | RelatedPropertiesSpecialValues;
    relatedClasses?: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    relationshipMeaning?: RelationshipMeaning;
    relationships?: MultiSchemaClassesSpecification | MultiSchemaClassesSpecification[];
    requiredDirection?: RelationshipDirection;
}

// @public
export const enum RelationshipDirection {
    Backward = "Backward",
    Both = "Both",
    Forward = "Forward"
}

// @public
export const enum RelationshipMeaning {
    RelatedInstance = "RelatedInstance",
    SameInstance = "SameInstance"
}

// @public
export type RelationshipPathInfo = RelatedClassInfo[];

// @public
export type RelationshipPathInfoJSON = RelatedClassInfoJSON[];

// @public
export interface RequestOptions<TIModel> {
    imodel: TIModel;
    locale?: string;
}

// @public (undocumented)
export interface RequestOptionsWithRuleset<TIModel> extends RequestOptions<TIModel> {
    rulesetId: string;
}

// @public
export interface RootNodeRule extends NavigationRuleBase {
    autoExpand?: boolean;
    ruleType: RuleTypes.RootNodes;
}

// @public (undocumented)
export interface RpcRequestOptions {
    // (undocumented)
    clientId?: string;
    // (undocumented)
    clientStateId?: string;
}

// @public
export class RpcRequestsHandler implements IDisposable {
    // Warning: (ae-forgotten-export) The symbol "Props" needs to be exported by the entry point presentation-common.d.ts
    constructor(props?: Props);
    readonly clientId: string;
    readonly clientStateId: string | undefined;
    // (undocumented)
    computeSelection(options: SelectionScopeRequestOptions<IModelToken>, ids: Id64String[], scopeId: string): Promise<KeySet>;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    getContent(options: ContentRequestOptions<IModelToken>, descriptorOrOverrides: Descriptor | DescriptorOverrides, keys: KeySet): Promise<Content | undefined>;
    // (undocumented)
    getContentAndSize(options: ContentRequestOptions<IModelToken>, descriptorOrOverrides: Descriptor | DescriptorOverrides, keys: KeySet): Promise<ContentResponse>;
    // (undocumented)
    getContentDescriptor(options: ContentRequestOptions<IModelToken>, displayType: string, keys: KeySet, selection: SelectionInfo | undefined): Promise<Descriptor | undefined>;
    // (undocumented)
    getContentSetSize(options: ContentRequestOptions<IModelToken>, descriptorOrOverrides: Descriptor | DescriptorOverrides, keys: KeySet): Promise<number>;
    // (undocumented)
    getDisplayLabel(options: LabelRequestOptions<IModelToken>, key: InstanceKey): Promise<string>;
    // (undocumented)
    getDisplayLabels(options: LabelRequestOptions<IModelToken>, keys: InstanceKey[]): Promise<string[]>;
    // (undocumented)
    getDistinctValues(options: ContentRequestOptions<IModelToken>, descriptor: Descriptor, keys: KeySet, fieldName: string, maximumValueCount: number): Promise<string[]>;
    // (undocumented)
    getFilteredNodePaths(options: HierarchyRequestOptions<IModelToken>, filterText: string): Promise<NodePathElement[]>;
    // (undocumented)
    getNodePaths(options: HierarchyRequestOptions<IModelToken>, paths: InstanceKey[][], markedIndex: number): Promise<NodePathElement[]>;
    // (undocumented)
    getNodes(options: Paged<HierarchyRequestOptions<IModelToken>>, parentKey?: NodeKey): Promise<Node[]>;
    // (undocumented)
    getNodesAndCount(options: Paged<HierarchyRequestOptions<IModelToken>>, parentKey?: NodeKey): Promise<NodesResponse>;
    // (undocumented)
    getNodesCount(options: HierarchyRequestOptions<IModelToken>, parentKey?: NodeKey): Promise<number>;
    // (undocumented)
    getSelectionScopes(options: SelectionScopeRequestOptions<IModelToken>): Promise<SelectionScope[]>;
    // (undocumented)
    registerClientStateHolder(holder: IClientStateHolder<any>): void;
    request<TResult, TOptions extends RpcRequestOptions & {
        imodel: IModelToken;
    }, TArg = any>(context: any, func: (token: IModelToken, options: Omit<TOptions, "imodel">, ...args: TArg[]) => PresentationRpcResponse<TResult>, options: TOptions, ...args: TArg[]): Promise<TResult>;
    sync(token: IModelToken): Promise<void>;
    // (undocumented)
    unregisterClientStateHolder(holder: IClientStateHolder<any>): void;
}

// @public (undocumented)
export interface RpcResponse<TResult = undefined> {
    // (undocumented)
    errorMessage?: string;
    // (undocumented)
    result: TResult;
    // (undocumented)
    statusCode: PresentationStatus;
}

// Warning: (ae-forgotten-export) The symbol "CustomizationRule" needs to be exported by the entry point presentation-common.d.ts
// Warning: (ae-forgotten-export) The symbol "NavigationRule" needs to be exported by the entry point presentation-common.d.ts
// 
// @public
export type Rule = CustomizationRule | NavigationRule | ContentRule | ContentModifier;

// @public
export interface Ruleset {
    id: string;
    rules: Rule[];
    supplementationInfo?: SupplementationInfo;
    supportedSchemas?: SchemasSpecification;
    vars?: VariablesGroup[];
}

// @public (undocumented)
export type RulesetManagerState = Ruleset[];

// @public (undocumented)
export namespace RulesetManagerState {
    const // (undocumented)
    STATE_ID = "rulesets";
}

// @public
export class RulesetsFactory {
    createSimilarInstancesRuleset(field: Field, record: Item): {
        ruleset: Ruleset;
        description: string;
    };
}

// @public (undocumented)
export interface RulesetVariablesState {
    // (undocumented)
    [rulesetId: string]: Array<[string, VariableValueTypes, VariableValue]>;
}

// @public (undocumented)
export namespace RulesetVariablesState {
    const // (undocumented)
    STATE_ID = "ruleset variables";
}

// @public
export const enum RuleSpecificationTypes {
    // (undocumented)
    AllInstanceNodes = "AllInstanceNodes",
    // (undocumented)
    AllRelatedInstanceNodes = "AllRelatedInstanceNodes",
    // (undocumented)
    ContentInstancesOfSpecificClasses = "ContentInstancesOfSpecificClasses",
    // (undocumented)
    ContentRelatedInstances = "ContentRelatedInstances",
    // (undocumented)
    CustomNode = "CustomNode",
    // (undocumented)
    CustomQueryInstanceNodes = "CustomQueryInstanceNodes",
    // (undocumented)
    InstanceNodesOfSpecificClasses = "InstanceNodesOfSpecificClasses",
    // (undocumented)
    RelatedInstanceNodes = "RelatedInstanceNodes",
    // (undocumented)
    SelectedNodeInstances = "SelectedNodeInstances"
}

// @public
export const enum RuleTypes {
    // (undocumented)
    CheckBox = "CheckBox",
    // (undocumented)
    ChildNodes = "ChildNodes",
    // (undocumented)
    Content = "Content",
    // (undocumented)
    ContentModifier = "ContentModifier",
    // (undocumented)
    DisabledSorting = "DisabledSorting",
    // (undocumented)
    Grouping = "Grouping",
    // (undocumented)
    ImageIdOverride = "ImageIdOverride",
    // (undocumented)
    InstanceLabelOverride = "InstanceLabelOverride",
    // (undocumented)
    LabelOverride = "LabelOverride",
    // (undocumented)
    PropertySorting = "PropertySorting",
    // (undocumented)
    RootNodes = "RootNodes",
    // (undocumented)
    StyleOverride = "StyleOverride"
}

// @public
export interface SameLabelInstanceGroup extends GroupingSpecificationBase {
    specType: GroupingSpecificationTypes.SameLabelInstance;
}

// @public
export interface SchemasSpecification {
    isExclude?: boolean;
    schemaNames: string[];
}

// @public
export interface SelectClassInfo {
    isSelectPolymorphic: boolean;
    pathToPrimaryClass: RelationshipPathInfo;
    relatedPropertyPaths: RelationshipPathInfo[];
    selectClassInfo: ClassInfo;
}

// @public
export interface SelectClassInfoJSON {
    // (undocumented)
    isSelectPolymorphic: boolean;
    // (undocumented)
    pathToPrimaryClass: RelationshipPathInfoJSON;
    // (undocumented)
    relatedPropertyPaths: RelationshipPathInfoJSON[];
    // (undocumented)
    selectClassInfo: ClassInfoJSON;
}

// @public
export interface SelectedNodeInstancesSpecification extends ContentSpecificationBase {
    acceptableClassNames?: string[];
    acceptablePolymorphically?: boolean;
    acceptableSchemaName?: string;
    onlyIfNotHandled?: boolean;
    specType: RuleSpecificationTypes.SelectedNodeInstances;
}

// @public
export interface SelectionInfo {
    // (undocumented)
    level?: number;
    // (undocumented)
    providerName: string;
}

// @public
export interface SelectionScope {
    // (undocumented)
    description?: string;
    // (undocumented)
    id: string;
    // (undocumented)
    label: string;
}

// @public
export interface SelectionScopeRequestOptions<TIModel> extends RequestOptions<TIModel> {
}

// @public (undocumented)
export type SelectionScopeRpcRequestOptions = RpcRequestOptions & Omit<SelectionScopeRequestOptions<IModelToken>, "imodel">;

// @public
export interface SingleSchemaClassSpecification {
    className: string;
    schemaName: string;
}

// @public
export enum SortDirection {
    // (undocumented)
    Ascending = 0,
    // (undocumented)
    Descending = 1
}

// Warning: (ae-forgotten-export) The symbol "PropertySortingRule" needs to be exported by the entry point presentation-common.d.ts
// Warning: (ae-forgotten-export) The symbol "DisabledSortingRule" needs to be exported by the entry point presentation-common.d.ts
// 
// @public
export type SortingRule = PropertySortingRule | DisabledSortingRule;

// @public
export enum StandardNodeTypes {
    // (undocumented)
    DisplayLabelGroupingNode = "DisplayLabelGroupingNode",
    // (undocumented)
    ECClassGroupingNode = "ECClassGroupingNode",
    // (undocumented)
    ECInstanceNode = "ECInstanceNode",
    // (undocumented)
    ECPropertyGroupingNode = "ECPropertyGroupingNode"
}

// @public
export interface StringQuerySpecification extends QuerySpecificationBase {
    query: string;
    specType: QuerySpecificationTypes.String;
}

// @public
export interface StructTypeDescription extends BaseTypeDescription {
    // Warning: (ae-forgotten-export) The symbol "StructFieldMemberDescription" needs to be exported by the entry point presentation-common.d.ts
    // 
    // (undocumented)
    members: StructFieldMemberDescription[];
    // (undocumented)
    valueFormat: PropertyValueFormat.Struct;
}

// @public
export interface StyleOverride extends RuleBase, ConditionContainer {
    backColor?: string;
    condition?: string;
    fontStyle?: string;
    foreColor?: string;
    ruleType: RuleTypes.StyleOverride;
}

// @public
export interface SubCondition extends ConditionContainer {
    condition?: string;
    // Warning: (ae-forgotten-export) The symbol "ChildNodeSpecification" needs to be exported by the entry point presentation-common.d.ts
    specifications?: ChildNodeSpecification[];
    subConditions?: SubCondition[];
}

// @public (undocumented)
export type Subtract<T, K> = Omit<T, keyof K>;

// @public
export interface SupplementationInfo {
    supplementationPurpose: string;
}

// @public
export type TypeDescription = PrimitiveTypeDescription | ArrayTypeDescription | StructTypeDescription;

// @public (undocumented)
export type Value = string | number | boolean | undefined | ValuesMap | ValuesArray | NestedContentValue[];

// @public (undocumented)
export function valueFromJSON(json: ValueJSON): Value;

// @public (undocumented)
export type ValueJSON = string | number | boolean | null | ValuesMapJSON | ValuesArrayJSON | NestedContentValueJSON[];

// @public (undocumented)
export interface ValuesArray extends Array<Value> {
}

// @public (undocumented)
export function valuesArrayFromJSON(json: ValuesArrayJSON): ValuesArray;

// @public (undocumented)
export interface ValuesArrayJSON extends Array<ValueJSON> {
}

// @public
export interface ValuesDictionary<T> {
    // (undocumented)
    [key: string]: T;
}

// @public (undocumented)
export interface ValuesMap extends ValuesDictionary<Value> {
}

// @public (undocumented)
export function valuesMapFromJSON(json: ValuesMapJSON): ValuesMap;

// @public (undocumented)
export interface ValuesMapJSON extends ValuesDictionary<ValueJSON> {
}

// @public
export interface Variable {
    defaultValue?: string;
    id: string;
    label: string;
    type?: VariableValueType;
}

// @public
export interface VariablesGroup {
    label: string;
    nestedGroups?: VariablesGroup[];
    vars: Variable[];
}

// @public
export type VariableValue = boolean | string | number | number[] | Id64String[];

// @public
export const enum VariableValueType {
    Int = "IntValue",
    ShowHide = "ShowHide",
    String = "StringValue",
    YesNo = "YesNo"
}

// @public
export const enum VariableValueTypes {
    Bool = "bool",
    Id64 = "id64",
    Id64Array = "id64[]",
    Int = "int",
    IntArray = "int[]",
    String = "string"
}


// (No @packageDocumentation comment for this package)

```
