# Schema Customization

<!-- TODO
COMMENT: This is really about dynamic metadata, not data. Or you could just call it extended metadata... the point is not that it is changing (it is not), it is simply metadata that extends beyond the current state of BIS.
-->

## Introduction

While BIS models a significant portion of the world of built infrastructure, and new discipline-specific domain schemas are being added all the time, there will inevitably be a need to store data not-yet-covered by BIS. Some common cases where this situation may arise are:

- Customizations and extensions to existing BIS concepts (often per-project or per-company)
- Vendor-specific information
- Transfer of information from other infrastructure-related databases (e.g. via iModel bridges).
- Modeling of concepts that do not currently exist in BIS.
- The need to add unstructured information to Elements.

This page discusses strategies available for creating and controlling this data, referred to as "custom data", and provides best practice advice. Custom data should be modeled differently depending on the nature of the data and how the property definitions and values vary.

### Existing customization options

- Element Aspects - Instances of an element aspect class add properties to  a specific element instance and is owned by that element.
- JSON Properties - Every Element has a Json property (JsonProperties) which can be used for ad-hoc addition of values without a schema update.
- [Element Types](TypeDefinitionElement) - Instances of an element type class add properties to a number of element instances and is referenced by those elements.  An element is 'of the type' of the element type it references.
- Derived Classes - A derived class may add new properties and inherits properties from the base class.  A derived class inherits the domain handler used for the base class.
- Adding properties to existing classes - Adds new properties directly to that class which are inherited to all derived classes.

NOTES:

- The users will want their customizations to FEEL like first class properties so they must show up in the UI, be searchable and perform similar to bentley delivered properties.

- Json Properties are only discoverable by walking the instances in the model and query performance is not the same.  Keys must be unique to avoid conflicts.

- Element Aspects which can be applied to a class can be identified using Element aspect relationships.  The relationship could also specify that the aspect is 'required' by setting multiplicity on the aspect side to 1..1.  The base ElementOwnsXxxxAspect relationships are concrete so how do we limit the aspects shown in the UI?  Do we rely on the derived relationship?

- Element Types have a similar problem to Element Aspects.  How to we show the user only the types which really matter to them given the generic nature of many of the relationships?

- Derived classes and adding properties to existing classes is the most direct way to customize but can cause property conflicts.  So properties should be named with a unique prefix.

- Properties that vary per class or type should be modeled using property definitions, properties which vary per instance should be modeled using Json or aspects.

- Properties that vary per class or type should be modeled using property definitions, properties which vary per instance should be modeled using Json.

- Schema versioning when customizing a schema:

- Schema versioning only works when there is a single stream of edits.  When a schema is edited by individual organizations or is generated by model the schema version is meaningless.

- Our API requires that the schema version be incremented for each schema update.  This can be a problem user edits and for generated schemas used by most bridges.  For user edits the user version might equal a new version we release.  For both multiple different schemas will have the same version.

### iModel Table Layout

|bis_Element|Secondary Table|Overflow Table|
|---|---|---|
|12 Columns|64 Columns (Max)*|Unbounded # of Columns|

*This is the number I was quoted but I my experiments show the number to be 51

## Customization goals

### Requirements

- Allow users to add custom properties in a schema in a contained manner
- Enable Bentley updates to merge conflict free into customized schemas
- Have zero impact on ECDb runtime performance
- Limit performance and complication to schema import/export time
- Must be able to remove user added properties

### Nicerements

- Enable domains to reduce the number of properties delivered by default in their schemas by enabling them to provide a large set of predefined properties that user can add as they need.
- User customizations should feel like they are part of the schema
- Be able to get the primary schema 100% back to the original state

### Explicitly Excluded from Requirements

- Changing display labels and units
- Adding custom attributes to items in the schema
- Adding new ECEntityClass, ECStructClass, ECCustomAttributeClass, ECRelationshipClass, ECEnumeration, PropertyCategory, KindOfQuantity, Unit, UnitSystem, Phenomenon

## Customization Options

### Customization as a BIS concept via Element Extensions

Summary: Add new mandatory related instances.  Similar in implementation to ElementAspects.  Properties must be explicitly joined in.

### Customization as an EC concept via extension schemas

Summary: Add new properties to existing classes.  Properties become part of class but are namespaced or grouped to avoid conflicts with other extension schemas or updates to the primary schema.

#### Idea 1 - Add Property Library and Property Group types

```xml
<ECPropertyLibrary schemaName="MyPropertyLibrary" alias="mppp" version="01.00.00">
    <ECPropertyGroup name="MyPipeProps">
        <ECProperty propertyName="FriendlyName" typeName="string" />
        <ECProperty propertyName="Radius" typeName="double" />
    </ECPropertyGroup>
    <ECPropertyGroup name="MyValveProps">
        <ECProperty propertyName="MyProperty" typeName="string" />
        <ECProperty propertyName="MyOtherProperty" typeName="double" />
    </ECPropertyGroup>
</ECPropertyLibrary>
```

```xml
<ECSchema schemaName="ProcessPhysical" alias="pphys" version="01.00.00">
    <ECSchemaReference name="BisCore" version="01.00.00" alias="bis"/>
    <ECPropertyLibraryReference name="MyProcessPhysicalProperties" version="01.00.00" alias="mppp" />
    <ECEntityClass typeName="Pipe">
        <BaseClass>bis:PhysicalElement</BaseClass>
        <ECProperty propertyName="mppp_FriendlyName" typeName="string" origin="mppp:MyPipeProps.FriendlyName" />
    </ECEntityClass>
    <ECEntityClass typeName="Valve">
        <BaseClass>bis:PhysicalElement"</BaseClass>
        <ECStructProperty propertyName="mppp_MyValveProps" typeName="mppp:MyValveProps" origin="mppp:MyValveProps">
    </ECEntityClass>
</ECSchema>
```

#### Idea 2 - Add Extension schema type which only allows abstract entity classes.

Primary schema and extension schema(s?) would be merged by ECObjects into a 'compiled' schema with the same name and version as the primary, but with an attribute identifying that the origin of the added property

```xml
<ECSchemaExtension name="ProcessPhysical_Ext_Colin" alias="cExt" version="01.00.00" extends="ProcessPhysical.01.00.00">
    <ECEntityClass typeName="Pipe" modifier="Abstract">
        <ECProperty propertyName="FriendlyName" typeName="string" />
    </ECEntityClass>
</ECSchemaExtension>

<ECSchema schemaName="ProcessPhysical" alias="pphys" version="01.00.00">
    <ECSchemaReference name="BisCore" version="01.00.00" alias="bis"/>
    <ExtendedBy name="ProcessPhysical_Ext_Colin" version="01.00.00" alias="cExt" />
    <ECEntityClass typeName="Pipe">
        <BaseClass>bis:PhysicalElement</BaseClass>
        <ECProperty propertyName="cExt_FriendlyName" typeName="string" origin="cExt" />
    </ECEntityClass>
</ECSchema>
```

## Vendor Data and Related Catalogs

Vendors will often need to define Element subclasses and associated Type subclasses. For example a pump vendor might define a Pump subclass (BigCo:MonsterPump) and a related PumpType subclass (BigCo:MonsterPumpType).

BigCo:MonsterPumpType might define four new properties:

- ModelNumber
- Power
- InletDiameter
- OutletDiameter

 BigCo:MonsterPump might define one new property:

- OutletLength

When BigCo's pump catalog is distributed, it will include:

- BigCo:MonsterPump class definition
- BigCo:MonsterPumpType class definition
- Multiple BigCo:MonsterPumpType instances (defining the pump types available for purchase)

<!-- TODO
QUESTION: *IN PRACTICE, DOES THIS MEAN THAT IF I WANT TO CHANGE A PUMP FROM BIGCO TO LITTLECO, THEN I NEED TO CHANGE THE CLASS OF PUMP AS WELL (IE - I NEED TO DELETE AND RECREATED THE PUMP)?*
-->

## Data Imported from Other Databases (including via iModel Bridges)

The technology (often iModel bridges) that converts data from other databases into BIS data will usually need to convert from the class structure in the native database to a BIS class structure. It is rare that a BIS schema will work "out of the box". Typically a dynamic schema will need to be defined by the converter and then the data converted from the native DB into instance of the new dynamic schema's classes (likely along with some instances of standard BIS classes).

## Dynamic Schema Minor Change Considerations

As dynamic schemas are extensions of BIS schemas, they must follow the rules of BIS schemas to prevent upgrade problems. These rules are defined in [Schema Versioning and Generations](./schema-versioning-and-generations.md). The most notable of these rules is that classes and properties cannot be removed or significantly redefined. In general, only additions to schemas are allowed.

## Minor (BIS) Schema Upgrade Considerations

As defined in [Schema Versioning and Generations](./schema-versioning-and-generations.md), BIS schemas may be upgraded at almost any time within a generation. The classes in dynamic schemas always subclass from BIS classes, so they may be affected by these minor upgrades at almost anytime.

The biggest danger from these minor schema upgrades is that a BIS class may add a property that has the same name as a property in a dynamic subclass. This class will cause ????????????? when the upgraded schema is imported into a BIS repository.

Class name conflicts (a class being added in BIS that has the same name as a class in a dynamic schema) is not a technical problem as the classes are scoped by the name of the schema that contains them. The duplicate class names can cause user confusion, however.

## Generational (BIS) Schema Upgrade Considerations

As defined in [Schema Versioning and Generations](./schema-versioning-and-generations.md), generational changes allow radical changes to schemas and must be accompanied by code that understands how to map data (Elements and Models) from one generation of schemas to another. The generational mapping code can potentially be very complex; for example, it may include:

- 1:1, 1:N, N:1, N:N instance mapping
- 1:1, 1:N, N:1, N:N property mapping
- Moving of properties between classes (as a simple case, from PhysicalElementType subclass to its related PhysicalElement subclass)
- Rearrangement of Model hierarchy

There needs to be a default strategy for converting the dynamic schemas to descent from the new BIS schemas, and for the conversion of dynamic data. We cannot rely on custom code to perform the upgrade; the entity that created the custom schemas may not even be in business any more.
