# Working with 64-bit IDs

Every [Entity]($backend) within an [IModel]($common) is identified by a unique 64-bit integer ID. Most code within imodel.js which refers to entities does not actually instantiate those entities as Javascript objects; instead they simply refer to them by their IDs. For example, a [ViewDefinition]($backend) element has members called `categorySelectorId` and `displayStyleId` which specify the IDs of the [CategorySelector]($backend) and [DisplayStyle]($backend) elements associated with the view. IDs are particularly important in communication between the front-end and the back-end. For example, [IModelConnection.queryEntityIds]($frontend) executes a query and returns the IDs of those entities satisfying the query; while [IModelConnection.Elements.getProps]($frontend) accepts a set of element IDs and returns a JSON representation of each specified element.

The 64 bits of an ID are divided into two parts:

* The upper 24 bits contain the [BriefcaseId]($backend) identifying the briefcase which originally created the entity.
* The lower 40 bits contain the entity's "local" ID, unique within the context of a single briefcase.

An ID is considered either "valid" (identifies an existing entity) or "invalid" (does not identify any existing entity). The latter is represented by the 64-bit value `0`. An invalid ID does not necessarily indicate an error - for example, an [Element]($backend) which has no parent element stores an invalid ID as its parent ID.

A local ID of 0 is illegal.

A briefcase ID of 0xffffff indicates "no briefcase". It is used instead to produce "transient" IDs which refer to non-persistent entities. Transient IDs are chiefly used by [Decorator]($frontend)s to produce decoration graphics with which the user can interact by clicking on our mousing over them. [IModelConnection.transientIds]($frontend) supplies a mechanism for obtaining a unique transient ID.

## TypeScript representation of a 64-bit ID

Because TypeScript lacks support for the full range of 64-bit integer values, IDs are represented as strings. A string must meet either of the following criteria in order to be considered a well-formed representation of an ID:

* It holds the value "0", indicating an invalid ID; or
* It holds a hexadecimal representation of a 64-bit integer, indicating a valid ID.

A well-formed *valid* ID string meets the following criteria:

* It begins with the prefix "0x".
* The first hexadecimal digit following the prefix is a non-zero lowercase hexadecimal digit (i.e., in the range [a-z1-9].
* If no briefcase ID is present, the remainder of the string consists of no more than 9 lowercase hexadecimal digits.
* If a briefcase ID is present, the remainder of the string consists of the briefcase ID as no more than 5 lowercase hexadecimal digits, followed by exactly 10 lowercase hexadecimal digits representing the local ID, of which one must be non-zero.

## Id64 and Id64String

The type alias [Id64String]($bentleyjs-core) is used extensively throughout the imodel.js API to indicate that a function argument, return type, or object property is assumed to be a well-formed ID string according to the above criteria.

The [Id64]($bentleyjs-core) class wraps a well-formed ID string inside a Javascript object, and also provides APIs for producing well-formed ID strings from various inputs. It is rarely necessary - and usually quite wasteful - to instantiate an Id64 object rather than simply using an Id64String. Exceptions exist for functions which accept arguments of several types and need to perform type-switching using `instanceof Id64`.

The following static Id64 methods can produce well-formed Id64Strings:

* [Id64.fromJSON]($bentleyjs-core) produces an Id64String from its JSON representation.
* [Id64.fromString]($bentleyjs-core) normalizes a string value into a well-formed Id64String.
* [Id64.fromLocalAndBriefcaseIds]($bentleyjs-core) concatenates integer briefcase and local IDs into an Id64String.
* [Id64.fromUint32Pair]($bentleyjs-core) concatenates a pair of 32-bit integers into an Id64String.

Id64.fromJSON and Id64.fromString should be used when your code has a string value which may represent an ID but may not be well-formed - e.g., it may contain uppercase hexadecimal digits, leading or trailing whitespace, and so on. Examples include strings originating from user input or from some web service. IDs originating from calls to the back-end can be expected to be well-formed.

Id64 also provides static methods for interrogating ID strings:
* [Id64.isValid]($bentleyjs-core), [Id64.isInvalid]($bentleyjs-core), and [Id64.isTransient]($bentleyjs-core) determine the type of ID represented by a well-formed ID string.
* [Id64.isId64]($bentleyjs-core) determines whether an arbitrary string value contains a well-formed ID string.
* [Id64.getLocalId]($bentleyjs-core) and [Id64.getBriefcaseId]($bentleyjs-core) extract the local and briefcase IDs from a well-formed ID string.

